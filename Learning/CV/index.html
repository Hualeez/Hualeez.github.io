<!DOCTYPE html>
<html lang="en">

<!-- Head tag (contains Google-Analytics、Baidu-Tongji)-->
<head>
  <!-- Google Analytics -->
  
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-xxxxxx-xx"></script>
    <script type="text/javascript">
      window.dataLayer = window.dataLayer || [];

      function gtag() {
        dataLayer.push(arguments);
      }
      gtag('js', new Date());

      gtag('config', 'UA-xxxxxx-xx');
    </script>
  

  <!-- Baidu Tongji -->
  
    <script type="text/javascript">
      // Originial
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  <!-- Baidu Push -->
  
    <script>
      (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
      })();
    </script>
  

  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>

  <meta name="google-site-verification" content="lxDfCplOZbIzjhG34NuQBgu2gdyRlAtMB4utP5AgEBc"/>
  <meta name="baidu-site-verification" content="PpzM9WxOJU"/>

  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="description" content="这里是Hualingz，一个乐观主义者"/>
  <meta name="keyword" content="Hualingz,hualeez,hualingz,cyc"/>
  <link rel="shortcut icon" href="/img/avatar/fin_32.png"/>

  <!-- Place this tag in your head or just before your close body tag. -->
  <script async="async" defer="defer" src="https://buttons.github.io/buttons.js"></script>

  
    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css"/>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/beantech.min.css"/>

    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css"/>
    <link rel="stylesheet" href="/css/widget.css"/>
    <link rel="stylesheet" href="/css/rocket.css"/>
    <link rel="stylesheet" href="/css/signature.css"/>
    <link rel="stylesheet" href="/css/catalog.css"/>
    <link rel="stylesheet" href="/css/livemylife.css"/>

    
      <!-- wave start -->
      <link rel="stylesheet" href="/css/wave.css"/>
      <!-- wave end -->
    

    
      <!-- top start (article top hot config) -->
      <link rel="stylesheet" href="/css/top.css"/>
      <!-- top end -->
    

    
      <!-- ThemeColor start -->
      <link rel="stylesheet" href="/css/scroll.css"/>
      <!-- ThemeColor end -->
    

    
      <!-- viewer start (Picture preview) -->
      <link rel="stylesheet" href="/css/viewer.min.css"/>
      <!-- viewer end -->
    

    
      <!-- Search start -->
      <link rel="stylesheet" href="/css/search.css"/>
      <!-- Search end -->
    

    
      <!-- ThemeColor start -->
      <link rel="stylesheet" href="/css/themecolor.css"/>
      <!-- ThemeColor end -->
    

    

    
      <!-- gitalk start -->
      <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"> -->
      <link rel="stylesheet" href="/css/gitalk.css"/>
      <!-- gitalk end -->
    
  

  <!-- Custom Fonts -->
  <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
  <!-- Hux change font-awesome CDN to qiniu -->
  <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" type="text/css">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

  <!-- Hux Delete, sad but pending in China <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'> <link
  href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/ css'> -->

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]> <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script> <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script> <![endif]-->

  <!-- ga & ba script hoook -->
  <link rel="canonical" href="http://Hualingz.cn/Learning/CV/">
  <title>
    
      CV复习版 - Hualingz_Channel
    
  </title>
<meta name="generator" content="Hexo 5.4.2"></head>


<!-- hack iOS CSS :active style -->

	<body ontouchstart="" class="body--light body--dark">


		<!-- ThemeColor -->
		
		<!-- ThemeColor -->
<style type="text/css">
  .body--light {
    --light-mode: none;
    --dark-mode: block;
  }
  .body--dark {
    --light-mode: block;
    --dark-mode: none;
  }
  i.mdui-icon.material-icons.light-mode {
    display: var(--light-mode);
  }
  i.mdui-icon.material-icons.dark-mode {
    display: var(--dark-mode);
  }
</style>
<div class="toggle" onclick="document.body.classList.toggle('body--dark')">
  <i class="mdui-icon material-icons light-mode"></i>
  <i class="mdui-icon material-icons dark-mode"></i>
</div>
<script>
  //getCookieValue
  function getCookieValue(a) {
    var b = document.cookie.match('(^|[^;]+)\\s*' + a + '\\s*=\\s*([^;]+)');
    return b
      ? b.pop()
      : '';
  }
  let themeMode = 'dark';
  if (getCookieValue('sb-color-mode') && (getCookieValue('sb-color-mode') !== themeMode)) {
    let dbody = document.body.classList;
    themeMode === 'dark' ? dbody.remove('body--dark') : dbody.add('body--dark');
  }

  //setCookieValue
  var toggleBtn = document.querySelector(".toggle");
  toggleBtn.addEventListener("click", function () {
    var e = document.body.classList.contains("body--dark");
    var cookieString = e
      ? "dark"
      : "light";
    var exp = new Date();
    exp.setTime(exp.getTime() + 3 * 24 * 60 * 60 * 1000); //3天过期
    document.cookie = "sb-color-mode=" + cookieString + ";expires=" + exp.toGMTString() + ";path=/";
  });
</script>

		

		<!-- Gitter -->
		
		<!-- Gitter -->
<!-- Docs:https://gitter.im/?utm_source=left-menu-logo -->
<script>
  ((window.gitter = {}).chat = {}).options = {
    room: 'your-community/your-room'
  };
</script>
<script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script>

		

		<!-- Navigation (contains search)-->
		<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header page-scroll">
      <button type="button" class="navbar-toggle">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">Hualingz_Channel</a>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <!-- Known Issue, found by Hux: <nav>'s height woule be hold on by its content. so, when navbar scale out, the <nav> will cover tags. also mask any touch event of tags, unfortunately. -->
    <div id="huxblog_navbar">
      <div class="navbar-collapse">
        <ul class="nav navbar-nav navbar-right">
          <li>
            <a href="/">首页</a>
          </li>

          
          
          
          
          <li>
            <a href="/about/">
              
              关于
              
              
            </a>
          </li>
          
          
          
          
          
          <li>
            <a href="/categories/">
              
              分类
              
              
            </a>
          </li>
          
          
          
          <li>
            <a href="/tags/">
              
              标签
              
              
            </a>
          </li>
          
          

          
          <li>
            <a class="popup-trigger">
              <span class="search-icon"></span>搜索</a>
          </li>
          

          <!-- LangSelect -->
          
          
          
          
          
        </ul>
      </div>
    </div>
    <!-- /.navbar-collapse -->
  </div>
  <!-- /.container -->
</nav>
<!-- progress -->
<div id="progress">
  <div class="line" style="width: 0%;"></div>
</div>

<script>
  // Drop Bootstarp low-performance Navbar Use customize navbar with high-quality material design animation in high-perf jank-free CSS3 implementation
  var $body = document.body;
  var $toggle = document.querySelector('.navbar-toggle');
  var $navbar = document.querySelector('#huxblog_navbar');
  var $collapse = document.querySelector('.navbar-collapse');

  $toggle.addEventListener('click', handleMagic)

  function handleMagic(e) {
    if ($navbar.className.indexOf('in') > 0) {
      // CLOSE
      $navbar.className = " ";
      // wait until animation end.
      setTimeout(function() {
        // prevent frequently toggle
        if ($navbar.className.indexOf('in') < 0) {
          $collapse.style.height = "0px"
        }
      }, 400)
    } else {
      // OPEN
      $collapse.style.height = "auto"
      $navbar.className += " in";
    }
  }
</script>


		<!-- Post Header (contains intro-header、signature、wordcount、busuanzi、waveoverlay) -->
		<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->

  <style type="text/css">
    .body--light {
      /* intro-header */
      --intro-header-background-image-url-home: url('/img/header_img/newhome_bg.jpg');
      --intro-header-background-image-url-post: url('');
      --intro-header-background-image-url-page: url('/img/header_img/archive_bg2.jpg');
    }
    .body--dark {
      --intro-header-background-image-url-home: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url('/img/header_img/newhome_bg.jpg');
      --intro-header-background-image-url-post: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url('');
      --intro-header-background-image-url-page: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url('/img/header_img/archive_bg2.jpg');
    }

    header.intro-header {
       /*post*/
        background-image: var(--intro-header-background-image-url-post);
        /* background-image: url(''); */
      
    }

    
      #signature {/*signature*/
        background-image: url('/img/signature/vincent-white.png');
      }
    
  </style>





<header class="intro-header">
  <!-- Signature -->
  <div id="signature">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
          
          <div class="post-heading">
            <div class="tags">
              
              <a class="tag" href="/tags/#浙江大学" title="浙江大学">浙江大学</a>
              
              <a class="tag" href="/tags/#CV计算机视觉" title="CV计算机视觉">CV计算机视觉</a>
              
            </div>
            <h1>CV复习版</h1>
            <h2 class="subheading">Hualingz</h2>
            <span class="meta">
              Posted by Hualingz on
              2023-02-16
            </span>


            
            <!-- WordCount start -->
            <div class="blank_box"></div>
            <span class="meta">
              Estimated Reading Time <span class="post-count">36</span> Minutes
            </span>
            <div class="blank_box"></div>
            <span class="meta">
              Words <span class="post-count">9.3k</span> In Total
            </span>
            <div class="blank_box"></div>
            <!-- WordCount end -->
            
            
            <!-- 不蒜子统计 start -->
            <span class="meta" id="busuanzi_container_page_pv">
              Viewed <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span> Times
            </span>
            <!-- 不蒜子统计 end -->
            


          </div>
          
        </div>
      </div>
    </div>
  </div>

  
  <!-- waveoverlay start -->
  <div class="preview-overlay">
    <svg class="preview-waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
      <defs>
        <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path>
      </defs>
      <g class="preview-parallax">
        <use xlink:href="#gentle-wave" x="48" y="0" fill=var(--gentle-wave1)></use>
        <use xlink:href="#gentle-wave" x="48" y="3" fill=var(--gentle-wave2)></use>
        <use xlink:href="#gentle-wave" x="48" y="5" fill=var(--gentle-wave3)></use>
        <use xlink:href="#gentle-wave" x="48" y="7" fill=var(--gentle-wave)></use>
      </g>
    </svg>
  </div>
  <!-- waveoverlay end -->
  

</header>



		<!-- Main Content (Post contains
	Pager、
	tip、
	socialshare、
	gitalk、gitment、disqus-comment、
	Catalog、
	Sidebar、
	Featured-Tags、
	Friends Blog、
	anchorjs、
	) -->
		<!-- Modify by Yu-Hsuan Yen -->
<!-- Post Content -->
<article>
  <div class="container">
    <div class="row">
      <!-- Post Container -->
      <div class="col-lg-8 col-lg-offset-1 col-md-10 col-md-offset-1 post-container">

        <h1 id="l1">L1</h1>
<h3 id="线性变换">线性变换</h3>
<ul>
<li>Scale
<ul>
<li><span class="math inline">\(a(x_a,y_a)\)</span></li>
<li><span class="math inline">\(b(s_xx_a,s_yy_a)\)</span></li>
<li><span class="math inline">\(b=Sa\)</span></li>
<li><span class="math inline">\(S=\begin{bmatrix}s_x\ 0\\0\
s_y\end{bmatrix}\)</span></li>
</ul></li>
<li>Reflection
<ul>
<li><span class="math inline">\(b=(-x_a,y_a)\)</span></li>
<li><span class="math inline">\(S=\begin{bmatrix}-1 \ 0\\0\
1\end{bmatrix}\)</span></li>
</ul></li>
<li>Shear
<ul>
<li><span class="math inline">\(b=(x_a+ay_a,y_a)\)</span></li>
<li><span class="math inline">\(S=\begin{bmatrix}1 \ a\\0\
1\end{bmatrix}\)</span></li>
<li><strong>变换矩阵中的(1,0)和(a,1)就是原来的两个标准基的变换后的新标准基</strong></li>
</ul></li>
<li>Rotation
<ul>
<li>逆时针转<span class="math inline">\(\theta\)</span>度</li>
<li>标准基
<ul>
<li>(1,0)变为(cos<span class="math inline">\(\theta\)</span>,sin<span class="math inline">\(\theta\)</span>)</li>
<li>(0,1)变为(-sin<span class="math inline">\(\theta\)</span>,cos<span class="math inline">\(\theta\)</span>)</li>
</ul></li>
<li>矩阵
<ul>
<li><span class="math inline">\(S=\begin{bmatrix}cos\theta\
-sin\theta\\sin\theta\ cos\theta\end{bmatrix}\)</span></li>
</ul></li>
</ul></li>
<li>线性变换
<ul>
<li><span class="math inline">\(b=Sa\)</span></li>
<li><span class="math inline">\(\begin{bmatrix}x&#39;\\y&#39;\end{bmatrix}=\begin{bmatrix}a
\ b\\c\ d\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}\)</span></li>
</ul></li>
<li>平移translate
<ul>
<li><span class="math inline">\(x&#39;=x+t_x\)</span></li>
<li><span class="math inline">\(y&#39;=y+t_y\)</span></li>
</ul></li>
<li>仿射变换
<ul>
<li><span class="math inline">\(\begin{bmatrix}x&#39;\\y&#39;\end{bmatrix}=\begin{bmatrix}a
\ b\\c\
d\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}+\begin{bmatrix}t_x\\t_y\end{bmatrix}\)</span></li>
<li>想要写成b=Sa的形式</li>
<li>升维：
<ul>
<li><span class="math inline">\(\begin{bmatrix}x&#39;\\y&#39;\\1\end{bmatrix}=\begin{bmatrix}a
\ b\ t_x\\c\ d\ t_y\\0\ 0\
1\end{bmatrix}\begin{bmatrix}x\\y\\1\end{bmatrix}\)</span></li>
</ul></li>
</ul></li>
<li>反变换
<ul>
<li>逆变换的矩阵是原变换矩阵的逆</li>
<li>几何变换不一定有逆变换</li>
</ul></li>
</ul>
<h1 id="l2">L2</h1>
<h3 id="小孔相机">小孔相机</h3>
<ul>
<li>底片上的每个点会接收到很多点的光，造成模糊，因此需要<strong>小孔成像</strong>
<ul>
<li>小孔成像下，会有一一对应的关系，孔要足够小</li>
<li>这个孔叫<code>光圈aperture</code>，孔不是越小越好
<ul>
<li>进光量</li>
<li>衍射效应</li>
</ul></li>
</ul></li>
<li>透镜：
<ul>
<li>焦距：平行光线交汇点<span class="math inline">\(\frac{1}{f}=\frac{1}{i}+\frac{1}{o}\)</span>
<ul>
<li>物距不变，焦距大，图像远</li>
<li>物距不变，焦距小，图像近</li>
</ul></li>
<li>放大率magnification：<span class="math inline">\(放大率=\frac{h_i}{h_o}=\frac{i}{o}\)</span></li>
</ul></li>
<li>FOV
<ul>
<li>底片长度有限，只能接收到某个角度内的光线，这个角度就是FOV
<ul>
<li><img src="/Learning/CV/image-20221227173717397.png" alt="image-20221227173717397" style="zoom:67%;"></li>
</ul></li>
<li>底片大小固定的情况下，焦距越大，AOV越小；焦距越小，AOV越大。</li>
</ul></li>
<li>传感器尺寸Sensor size，即底片大小</li>
<li>光圈Aperture，透镜的受光面积，由透镜直径表示。
<ul>
<li>光圈的增大缩小影响图像的亮度。</li>
<li>影响清晰度，大光圈可以模糊图像</li>
</ul></li>
<li>F-number
<ul>
<li>我们的光圈大小都是和f有关的
<ul>
<li><span class="math inline">\(D=\frac{f}{N}\)</span></li>
<li>这里的D为光圈直径，f为焦距，N即为F-number</li>
</ul></li>
</ul></li>
<li>Lens Defocus
<ul>
<li>像距物距产生偏移，本来一个点在相平面的成像是一个点，结果会成为一个原型的模糊圈。</li>
<li><span class="math inline">\(\frac{b}{D}=\frac{|i&#39;-i|}{i},b=\frac{D}{i}|i&#39;-i|=\frac{f}{iN}|i&#39;-i|\)</span></li>
</ul></li>
<li>Depth of Field景深
<ul>
<li>产生圆形模糊范围内的物体的最大偏移</li>
<li>比如我们产生了直径c的模糊，那么有一个最近的物距和最远的物距，两个差值即为景深</li>
</ul></li>
</ul>
<h3 id="透视变换公式">透视变换公式</h3>
<ul>
<li>3D世界坐标系到2D图像的坐标系的变换。</li>
<li>光轴、相机中心、图像中心</li>
<li>在现实中的点<span class="math inline">\(P=(x,y,z)\)</span></li>
<li>平面上的表示<span class="math inline">\(p=(u,v)=(f\frac{x}{z},f\frac{y}{z})\)</span></li>
<li>这不是一个线性的变换。为了线性变换，我们写作<span class="math inline">\((f\frac{x}{z},f\frac{y}{z},1)\)</span></li>
<li>那么齐次坐标下的表达就是<span class="math inline">\((fx,fy,z)\)</span></li>
<li>那么就可以这么表示：
<ul>
<li><span class="math inline">\(\begin{bmatrix}f\ 0\ 0\ 0\\0\ f\ 0\
0\\0\ 0\ 1\
0\end{bmatrix}\begin{bmatrix}x\\y\\z\\1\end{bmatrix}三维坐标=\begin{bmatrix}fx\\
fy\\
z\end{bmatrix}齐次坐标\approx\begin{bmatrix}f\frac{x}{z}\\f\frac{y}{z}\\1\end{bmatrix}二维坐标\)</span></li>
<li>变换矩阵<span class="math inline">\(S=\begin{bmatrix}f\ 0\ 0\ 0\\0\
f\ 0\ 0\\0\ 0\ 1\ 0\end{bmatrix}\)</span></li>
</ul></li>
<li>损失深度信息</li>
<li>性质：保持线性、长度、角度</li>
</ul>
<h3 id="灭点">灭点</h3>
<ul>
<li>透视平行线的交点</li>
<li>灭点告诉我们线的方向，灭点可能在图像外</li>
<li><img src="/Learning/CV/image-20221227182831664.png" alt="image-20221227182831664" style="zoom:67%;"></li>
</ul>
<h4 id="灭线">灭线</h4>
<ul>
<li>灭点构成的线</li>
<li>平面上任意一组平行线定义一个消失点，所有这些消失点的并集就是消失线</li>
<li>注意，不同的平面定义不同的消失线</li>
<li>消失线的方向告诉我们这个平面的方向</li>
</ul>
<h4 id="失真distortion">失真Distortion</h4>
<h4 id="perspective-distortion">Perspective Distortion</h4>
<p>由于透视近大远小引起的失真</p>
<p><img src="/Learning/CV/image-20221227183800819.png" alt="image-20221227183800819" style="zoom:67%;"></p>
<ul>
<li>外部的柱子显得更大</li>
<li><strong>失真不是由于镜头缺陷造成的</strong></li>
</ul>
<h4 id="radial-distortion">Radial Distortion</h4>
<ul>
<li><strong>由不完美的镜片引起</strong></li>
<li>通过透镜边缘的光线更明显
<ul>
<li>Pin cushion，往里面凹</li>
<li>Barrel，往外面凸</li>
</ul></li>
</ul>
<h3 id="正射投影orthographic-projection">正射投影Orthographic
projection</h3>
<ul>
<li>透视投影的特殊情况，图像中的点的坐标是实际中的坐标</li>
<li>从COP到PP的距离是无限的</li>
<li>变换矩阵<span class="math inline">\(S=\begin{bmatrix}1\ 0\ 0\ 0\\0\
1\ 0\ 0\\0\ 0\ 0\ 1\end{bmatrix}\)</span></li>
</ul>
<h3 id="快门shutter">快门Shutter</h3>
<ul>
<li>曝光过程
<ul>
<li>后幕帘开启</li>
<li>前幕帘开启，开始曝光</li>
<li>后幕帘关闭，曝光结束</li>
<li>前幕帘关闭</li>
</ul></li>
<li>快门速度：控制曝光时间
<ul>
<li>太长：模糊、亮度太大</li>
<li>太短：很暗</li>
</ul></li>
</ul>
<h3 id="rolling-shutter-effect">Rolling Shutter Effect</h3>
<ul>
<li>快门一开就开始曝光，每个像素是同时曝光的，<strong>Rolling
Shutter的开门是一行一行打开的</strong>，不是一下子全部打开</li>
<li>因此会<strong>造成延迟</strong></li>
</ul>
<h3 id="颜色color">颜色Color</h3>
<ul>
<li>光的波长决定了光的颜色</li>
<li>RGB：三种颜色</li>
<li>HSV：颜色离散化，亮度，饱和度</li>
</ul>
<h4 id="bayer-filter贝尔滤波器">Bayer Filter贝尔滤波器</h4>
<ul>
<li>分成若干个2*2的格子，两个记录Green，一个记录Red，一个记录Blue，人对绿色敏感。</li>
<li>那么RGB值，就可以由1+2产生，非本单元记录的通道可以使用相邻插值。</li>
<li><img src="/Learning/CV/image-20221227190201417.png" alt="image-20221227190201417" style="zoom:67%;"></li>
</ul>
<h2 id="l3">L3</h2>
<h3 id="图像处理">图像处理</h3>
<h4 id="亮度变化">亮度变化</h4>
<ul>
<li>对像素值进行变换，对RGB的值变换</li>
<li><span class="math inline">\(output(x,y)=f(input(x,y))\)</span></li>
<li>曲线S-curve就是暗的更暗，亮的更亮</li>
<li>如果是对角线就什么都没变</li>
</ul>
<h4 id="卷积">卷积</h4>
<ul>
<li><span class="math inline">\((f*g)(x)=\int f(y)g(x-y)dy\)</span></li>
<li><span class="math inline">\(f(y)\)</span>为filter</li>
<li><span class="math inline">\(g(x-y)\)</span>为输入信号</li>
<li><span class="math inline">\((f*g)(x)\)</span>为输出信号</li>
</ul>
<h5 id="二维卷积">二维卷积</h5>
<ul>
<li><span class="math inline">\((f*g)(x,y)=\sum
f(i,j)I(x-i,y-j)\)</span></li>
<li>假设是个2*2的filter，那么ij都只有两个取值</li>
</ul>
<h4 id="模糊">模糊</h4>
<p>使用卷积核，如均值模糊、高斯模糊等</p>
<ul>
<li>均值滤波器</li>
<li>高斯卷积核
<ul>
<li><span class="math inline">\(f(i,j)=\frac{1}{2\pi
\sigma^2}e^{-\frac{i^2+j^2}{2\sigma^2}}\)</span></li>
<li><strong><span class="math inline">\(\sigma\)</span>越大越模糊</strong></li>
</ul></li>
</ul>
<h4 id="锐化sharpen">锐化Sharpen</h4>
<ul>
<li><span class="math inline">\(\begin{bmatrix}0\ -1\ 0\\-1\ 5\ -1\\0\
-1\ 0\end{bmatrix}\)</span></li>
<li>sharpening是增大高频成分
<ul>
<li><span class="math inline">\(I\)</span>为原始图像</li>
<li><span class="math inline">\(I=I-blur(I)\)</span>为高频</li>
<li><span class="math inline">\(I=I+(I-blur(I))\)</span>为sharpen的图像</li>
</ul></li>
</ul>
<h4 id="求梯度边缘检测">求梯度，边缘检测</h4>
<ul>
<li>左边的减去右边的或者上边的减去下边的</li>
<li><span class="math inline">\(\begin{bmatrix}-1\ 0\ 1\\-2\ 0\ 2\\-1\
0\ 1\end{bmatrix}\)</span></li>
<li><span class="math inline">\(\begin{bmatrix}-1\ -2\ -1\\0\ 0\ 0\\1\
2\ 1\end{bmatrix}\)</span></li>
</ul>
<h4 id="双边滤波">双边滤波</h4>
<ul>
<li>用途：去除图像的噪声，但是保护边缘</li>
<li>高斯滤波器和梯度滤波器的叠加作用</li>
<li>在平均时只考虑一侧的平均，变成像<span class="math inline">\(G\times
f\)</span>的滤波器</li>
<li>卷积核取决于图像的内容</li>
</ul>
<h3 id="图像尺寸变换">图像尺寸变换</h3>
<h5 id="减小尺寸">减小尺寸</h5>
<ul>
<li>降采样
<ul>
<li>将连续的变成了离散的，Aliasing</li>
<li>摩尔纹、Wagon Wheel illusion</li>
</ul></li>
<li>Aliasing
<ul>
<li>信号改变太快而采样太慢</li>
<li>当采样频率慢
<ul>
<li>低频信号：充分采样，合理重构</li>
<li>高频信号采样不足：不正确的重构似乎来自低频信号</li>
</ul></li>
<li>频域：
<ul>
<li>一个信号用傅里叶变换后的函数的频率分布</li>
<li>在时域采样就是频域周期延拓[频域采样][https://www.zhihu.com/question/20236413]</li>
</ul></li>
<li>如何避免aliasing
<ul>
<li>增大采样频率</li>
<li>Anti-aliasing：采样前过滤掉高频</li>
</ul></li>
</ul></li>
</ul>
<h5 id="增大尺寸">增大尺寸</h5>
<ul>
<li>上采样
<ul>
<li>Bilinear Interpolation
<ul>
<li>取四个最近的点，加权平均，权就是面积</li>
<li><img src="/Learning/CV/image-20221228151739287.png" alt="image-20221228151739287" style="zoom:67%;"></li>
</ul></li>
</ul></li>
</ul>
<h4 id="改变图像比例">改变图像比例</h4>
<p>Seam Caving</p>
<ul>
<li>将不重要的压缩掉，如何自动完成这个操作？</li>
<li>裁剪掉<strong>梯度变化小的地方</strong></li>
<li>衡量像素的重要还是不重要？
<ul>
<li>就是梯度变化</li>
<li><span class="math inline">\(E(I)=|\frac{\partial I}{\partial
x}|+|\frac{\partial I}{\partial y}|\)</span></li>
</ul></li>
<li>如何实现？
<ul>
<li>卷积，使用edge detect的卷积</li>
<li>如何丢掉每一行中的10个像素？
<ul>
<li>希望一条曲线能够穿过一列的要扔掉的像素，找到10条曲线就行。</li>
</ul></li>
<li>找梯度最小的一条曲线，最短路径问题</li>
</ul></li>
</ul>
<h2 id="l4">L4</h2>
<h3 id="优化">优化</h3>
<h4 id="梯度下降法">梯度下降法</h4>
<ul>
<li>p：梯度下降方向</li>
<li><span class="math inline">\(\alpha\)</span>：步长</li>
<li><span class="math inline">\(x\leftarrow x+\alpha p\)</span></li>
<li>下降方向如何确定：
<ul>
<li>找到下降方向最快的</li>
<li>即求导梯度的反方向<span class="math inline">\(J_F\)</span></li>
<li><span class="math inline">\(x=x-\alpha J_F(x)\)</span></li>
</ul></li>
<li>步长如何确定：
<ul>
<li><span class="math inline">\(\alpha\)</span>不能太大也不能太小</li>
<li>我们需要找到一个最佳的<span class="math inline">\(\alpha\)</span></li>
<li>使用backtracking
<ul>
<li>初始化<span class="math inline">\(\alpha\)</span>一个较大的值</li>
<li>减小<span class="math inline">\(\alpha\)</span>直到，<span class="math inline">\(\phi(\alpha)\leq \phi(0)+\gamma
\phi&#39;(0)\alpha\)</span></li>
<li><span class="math inline">\(\gamma \in (0,1)\)</span></li>
<li>收敛较慢</li>
</ul></li>
</ul></li>
</ul>
<h4 id="牛顿法">牛顿法</h4>
<ul>
<li><span class="math inline">\(F(x_k+\Delta x)=F(x_k)+J_F\Delta
x+\frac{1}{2}\Delta x^TH_F\Delta x\)</span></li>
<li>找一个使得上式最小的<span class="math inline">\(\Delta
x\)</span></li>
<li><span class="math inline">\(\Delta x = -H_F^{-1}J_F^T\)</span></li>
</ul>
<h4 id="高斯牛顿法">高斯牛顿法</h4>
<ul>
<li><span class="math inline">\(\hat x =
argmin_{x}||R(x)||^2_2\)</span></li>
<li>对误差函数进行展开
<ul>
<li>这里<span class="math inline">\(R(x)=\begin{bmatrix}b_i-f(x_i)\\...\\b_j-f(x_j)\end{bmatrix}\)</span></li>
<li><span class="math inline">\(||R(x_k+\Delta
x)||^2_2=||R(x_k)+J_R\Delta x||^2_2\)</span></li>
<li><span class="math inline">\(=||R(x_k)||^2_2+2R(x_k)^TJ_R\Delta
x+\Delta x^TJ_R^TJ_R\Delta x\)</span></li>
<li><span class="math inline">\(J_R^TJ_R\Delta
x+J_R^TR(x_k)=0\)</span></li>
<li><span class="math inline">\(J_R\)</span>是R(x)的Jabobian</li>
</ul></li>
<li><span class="math inline">\(\Delta x =
-(J_R^TJ_R)^{-1}J_R^TR(x_k)\)</span></li>
<li>在牛顿法里我们是<span class="math display">\[\Delta
x=-H_F^{-1}J_F^{T}=-H_F^{-1}J_F^{T}R(x)\]</span></li>
<li>用了<span class="math inline">\(J_R\)</span>代替了黑塞矩阵的计算</li>
</ul>
<p>【Levenberg-Marquardt】求逆会出错，我们可以加一个修正项</p>
<ul>
<li><span class="math inline">\(\Delta x = -(J_R^TJ_R+\lambda
I)^{-1}J_R^TR(x_k)\)</span></li>
<li><span class="math inline">\(\lambda\)</span>很小</li>
</ul>
<h3 id="outlierinlier">Outlier&amp;Inlier</h3>
<ul>
<li>Inlier：服从模型假设</li>
<li>Outlier：与假设有显著差异</li>
</ul>
<h3 id="ransac">RANSAC</h3>
<p>Random Sample Concensus随机抽样共识</p>
<ul>
<li>解决outlier的</li>
<li>主要思想：
<ul>
<li>内值的分布是相似的，而异常值的分布差异很大</li>
<li>使用数据点对进行投票</li>
</ul></li>
</ul>
<h3 id="正则化">正则化</h3>
<p>为了防止过拟合，正则化的作用：</p>
<ul>
<li>控制参数幅度，不让模型过于复杂</li>
<li>限制参数搜索空间</li>
</ul>
<h5 id="l2-1">L2</h5>
<ul>
<li>L2规范化：<span class="math inline">\(||x||_2=\sum_ix_i^2\)</span></li>
<li>L2正则化：
<ul>
<li><span class="math inline">\(min_x||Ax-b||^2_2\)</span></li>
<li>s.t.<span class="math inline">\(||x||_2\leq 1\)</span></li>
</ul></li>
</ul>
<h5 id="l1-1">L1</h5>
<ul>
<li>L1规范化：<span class="math inline">\(||x||_1=\sum_i|x_i|\)</span></li>
<li>L1正则化：
<ul>
<li><span class="math inline">\(min_x||Ax-b||^2_2\)</span></li>
<li>s.t.<span class="math inline">\(||x||_1\leq 1\)</span></li>
</ul></li>
</ul>
<h2 id="l5">L5</h2>
<h3 id="特征匹配">特征匹配</h3>
<p>步骤</p>
<ul>
<li>特征点检测</li>
<li>提取描述符</li>
<li>特征点匹配</li>
</ul>
<h4 id="harris-operator">Harris Operator</h4>
<ul>
<li>首先找到H，协方差矩阵
<ul>
<li><span class="math inline">\(H=\sum_{(u,v)}w(u,v)\begin{bmatrix}I_x^2\ \
I_xI_y\\I_xI_y\ \ I_y^2\end{bmatrix}\)</span></li>
<li><span class="math inline">\(I_x=\frac{\partial f}{\partial
x},I_y=\frac{\partial f}{\partial y}\)</span></li>
<li><span class="math inline">\(f\)</span>为像素值的函数</li>
</ul></li>
<li>计算特征值，有两个梯度变化大的，就是角点，那么两个特征值就会变大。</li>
<li><img src="/Learning/CV/image-20221024122105586.png" alt="image-20221024122105586" style="zoom:33%;"></li>
<li><span class="math inline">\(f=\frac{\lambda_1\lambda_2}{\lambda_1+\lambda_2}=\frac{det(H)}{trace(H)}\)</span></li>
<li>f是corner response</li>
</ul>
<h4 id="harris-detector">Harris Detector</h4>
<ul>
<li>计算每个像素处的导数</li>
<li>在每个像素周围的高斯窗口中计算协方差矩阵H</li>
<li>计算角响应函数f</li>
<li>阈值f</li>
<li>求响应函数的局部极大值(nonmaximum删除)</li>
</ul>
<p>好的算子需要有好的不变性：</p>
<ul>
<li>光度变换</li>
<li>平移</li>
<li>旋转</li>
<li>缩放</li>
</ul>
<p>Harris Detector的不变性</p>
<ul>
<li>部分不变到仿射强度变化</li>
<li>平移不变性</li>
<li>旋转不变性</li>
<li>缩放<strong>不是</strong>不变的</li>
</ul>
<p>既然对缩放是有改变的，我们如何找到最好的尺度？</p>
<ul>
<li>关键思想：找到给出局部最大值的尺度</li>
</ul>
<h3 id="blob-detector">Blob Detector</h3>
<p>找极值点，即使用<span class="math inline">\(I_{xx}+I_{yy}\)</span>判断最大最小值，拉普拉斯算子</p>
<p>使用卷积计算<span class="math inline">\(\nabla ^2=\frac{\partial
^2}{\partial x^2}+\frac{\partial ^2}{\partial y^2}\)</span></p>
<p>卷积核：</p>
<ul>
<li>x方向的：<span class="math inline">\(\frac{\partial ^2f}{\partial
x^2}=f(x+1)+f(x-1)-2f(x)=\begin{bmatrix}1\ -2\
1\end{bmatrix}\)</span></li>
<li>y方向的：<span class="math inline">\(\frac{\partial ^2f}{\partial
y^2}=f(y+1)+f(y-1)-2f(y)=\begin{bmatrix}1\\-2\\1\end{bmatrix}\)</span></li>
<li>复合一下获得<strong>拉普拉斯滤波器</strong>
<ul>
<li>Laplacian Filter</li>
<li><figure>
<img src="/Learning/CV/image-20221024122239817.png" alt="image-20221024122239817">
<figcaption aria-hidden="true">image-20221024122239817</figcaption>
</figure></li>
</ul></li>
</ul>
<h5 id="高斯拉普拉斯算子log">高斯拉普拉斯算子LoG</h5>
<ul>
<li>拉普拉斯对噪音很敏感</li>
<li>使用LoG
<ul>
<li>先用高斯滤波器平滑图像</li>
<li>再用拉普拉斯算子计算</li>
</ul></li>
<li><span class="math inline">\(\nabla ^2G=\frac{\partial ^2G}{\partial
x^2}+\frac{\partial ^2G}{\partial y^2}\)</span></li>
<li>scale of LoG被高斯的<span class="math inline">\(\sigma\)</span>控制</li>
<li>因此我们用不同的σ去做卷积获得不同大小的blob</li>
</ul>
<h5 id="高斯差值dog">高斯差值DoG</h5>
<p>对拉普拉斯高斯的近似，LoG能被两个高斯的差值近似，即<span class="math inline">\(\nabla
^2G_{\sigma}=G_{\sigma_1}-G_{\sigma_2}\)</span></p>
<figure>
<img src="/Learning/CV/image-20221017152149576.png" alt="image-20221017152149576">
<figcaption aria-hidden="true">image-20221017152149576</figcaption>
</figure>
<ul>
<li>计算高效，一般使用这个来计算</li>
</ul>
<h3 id="sift">SIFT</h3>
<p>如何描述特征？</p>
<ul>
<li>每一个像素有一个梯度，梯度有一个朝向</li>
<li>把所有像素的梯度放在一起，有一个梯度方向的直方图</li>
<li>用这个直方图作为描述子，就是区域内梯度朝向的分布</li>
<li><figure>
<img src="/Learning/CV/image-20221017152843237.png" alt="image-20221017152843237">
<figcaption aria-hidden="true">image-20221017152843237</figcaption>
</figure></li>
</ul>
<p>不变性？</p>
<ul>
<li>强度变化：有不变性，只需要方向，不需要大小</li>
<li>旋转变化：没有不变性，直方图平移，normalize一下就可以了
<ul>
<li>构造descriptor时，让主朝向在第一位</li>
</ul></li>
<li>缩放变化：没有不变性，在detection的阶段就处理了，在detection阶段的scale确定了就要处理</li>
</ul>
<h3 id="matching">Matching</h3>
<p>如何进行匹配？</p>
<p>定义两个描述符的距离，算一个相似度，取最相似的，相似度的衡量，计算两个descriptor的距离，距离小，相似。对于图1的一个特征点，从图2中找到距离最小的描述符对应的特征点。</p>
<p><strong>但是如果有重复的纹理，就不一定有唯一解了，如何解决？</strong></p>
<h5 id="ratio-test">Ratio test</h5>
<ul>
<li><span class="math inline">\(Ratio\ score
=||f_1-f_2||/||f_1-f_2&#39;||\)</span></li>
<li>f2为最相似的，f2‘为第二相似的，那么ratio
score接近于1，说明是没有奇异性的，那么我们就不要这个点了。</li>
</ul>
<p>Mutual nearest neighbor</p>
<p>另一种策略：找到相互最近的邻居</p>
<p>f2是l2中f1的最近邻居</p>
<p>f1是l1中f2最近的邻居</p>
<h3 id="motion-estimation">Motion Estimation</h3>
<ul>
<li>Feature-tracking
<ul>
<li>我们需要跟踪<strong>每一个特征点</strong>在视频每一帧的位置</li>
<li>侧重在视频中，时序关系</li>
<li>output：displacement of sparse points稀疏点的位移</li>
</ul></li>
<li>Optical flow
<ul>
<li>我们希望恢复图像中每<strong>一个像素</strong>的运动</li>
<li>output：dense displacement field密集位移场</li>
</ul></li>
</ul>
<h4 id="lucas-kanade-method">Lucas-Kanade Method</h4>
<ul>
<li><p>假设图像中有特征点，从时刻t到时刻t+1，通过运动估计得到时刻t+1的点的位置，查看我们预测的位置和真实位置的误差。</p>
<figure>
<img src="/Learning/CV/image-20221024133724813.png" alt="image-20221024133724813">
<figcaption aria-hidden="true">image-20221024133724813</figcaption>
</figure>
<p>就是求每一个点对应的<strong>平移向量</strong>。</p>
<ul>
<li>我们可以用feature mapping做，但是时序上的特征无法很好的体现。</li>
<li>Lucas-Kanade方法的假设
<ul>
<li>小位移：点的位置变化不会太大</li>
<li>亮度恒常性：前后帧对应点的亮度值不会太大变化。</li>
<li>空间相干性：空间上的连续性，相邻的点运动比较一致</li>
</ul></li>
</ul></li>
<li><p>Brightness Constancy Equation：</p>
<ul>
<li><span class="math inline">\(I(x,y,t)=I(x+u,y+v,t+1)\)</span></li>
<li>我们要求解的就是u和v</li>
<li>$I $是我们的图像，是没有表达式的</li>
</ul></li>
<li><p>Small Motion：</p>
<ul>
<li>使用泰勒展开：</li>
<li><span class="math inline">\(I(x+u,y+v,t+1)=I(x,y,z)+I_xu+I_yv+I_t\)</span></li>
<li><span class="math inline">\(I_x,I_y\)</span>就是关于图像的导数，使用卷积可以求</li>
<li><span class="math inline">\(I_t\)</span>是关于时间的导数，就是第一张图的xy上的像素值减去第二张图同样位置的xy的像素值</li>
<li>那么我们就得到了</li>
<li><span class="math inline">\(I_xu+I_yv+I_t=0\)</span></li>
<li><span class="math inline">\(\nabla I[u\ v]^T+I_t=0\)</span></li>
<li>只有一个方程无法计算u和v</li>
</ul></li>
<li><p>Spatial coherence</p>
<ul>
<li>相邻的点我们可以假设u和v是一样的</li>
<li>那么我们的方程就变多了</li>
</ul></li>
</ul>
<p><span class="math inline">\(\nabla I[u\ v]^T+I_t=0\)</span></p>
<p>我们现在一个方程，两个未知数(u,v)，假设我们的u，v满足以上的方程，如果</p>
<p><span class="math inline">\(\nabla I[u&#39;\ v&#39;]^T=0\)</span></p>
<p>那么(u+u',v+v')也满足这个方程。</p>
<h4 id="孔径问题">孔径问题</h4>
<p>对一个点而言，垂直于图像梯度方向的移动无法确定。孔径问题。</p>
<p>假设我们使用5*5的窗口，那么我们就有25个方程。</p>
<p><img src="/Learning/CV/image-20221024135723035.png" alt="image-20221024135723035" style="zoom:50%;"></p>
<p>两个变量25个方程如何解决？我们找一组u，v使得误差最小，即优化问题。</p>
<p><span class="math inline">\(min_{d}||Ad-b||^2\)</span></p>
<p>求导，找零点。<span class="math inline">\((A^TA)d=A^Tb\)</span></p>
<p>那么有：</p>
<p><img src="/Learning/CV/image-20221024135916154.png" alt="image-20221024135916154" style="zoom:50%;"></p>
<p>那么想要有唯一解，有要求<span class="math inline">\((A^TA)\)</span>满秩，保证其可逆，有<strong>两个不为0的特征值</strong>。</p>
<p>有稳定的解时，<span class="math inline">\((A^TA)\)</span>的两个特征值要比较大</p>
<p>这个与corner detector比较类似。换言之，角点的optimal
flow更容易追踪。</p>
<h2 id="l6">L6</h2>
<h4 id="图像的拼接">图像的拼接</h4>
<p>将一张图进行变换，与另一张图重合。改变图像的形状，不改变强度。</p>
<p>Global Warping：对所有点改变位置的规律是一致的。</p>
<p>Parametric Warping：变换可以用参数表示。</p>
<p><span class="math inline">\(p&#39;=T(p)\)</span></p>
<ul>
<li>Scale缩放</li>
<li>Reflection反转</li>
<li>Shear剪切</li>
<li>Rotation旋转</li>
<li>Tanslation可以用升维的方式，齐次坐标</li>
</ul>
<p>仿射变换(线性变换+平移)的最后一行要是[0 0 1]，如果不是呢？</p>
<p><strong>仿射变换的自由度为6</strong></p>
<p>投影变换（单应性），投影变换的最后一行可以不是[0 0
1]，但是我们约束了变换矩阵的模为1，<strong>因此投影变换的自由度为8</strong></p>
<ul>
<li>平移自由度2</li>
<li>欧式变换平移+旋转自由度2+1</li>
<li>相似变换平移+旋转+缩放2+1+1</li>
<li>仿射自由度6</li>
<li>投影自由度8</li>
</ul>
<h4 id="图像的缝合">图像的缝合</h4>
<p>通过matching获得对应点，计算变换矩阵T</p>
<p><span class="math inline">\(\begin{bmatrix}x&#39;\\y&#39;\\1\end{bmatrix}=T\begin{bmatrix}x\\y\\1\end{bmatrix}\)</span></p>
<ol type="1">
<li>对于仿射变换，我们有6个自由度，我们需要3对匹配点来解</li>
</ol>
<p><img src="/Learning/CV/image-20221024152023588.png" alt="image-20221024152023588" style="zoom:50%;"></p>
<p><img src="/Learning/CV/image-20221024152037877.png" alt="image-20221024152037877" style="zoom:50%;"></p>
<p>对于n对点的情况下，我么使用最小二乘法，优化问题求解</p>
<p><span class="math inline">\(t=(A^TA)^{-1}A^Tb\)</span></p>
<ol start="2" type="1">
<li><p>对于投影变换，我们有9个未知数，当然可以用模长限制为8个未知数。</p>
<p>我们需要至少4对点来求解。</p>
<p><img src="/Learning/CV/image-20221024152327926.png" alt="image-20221024152327926" style="zoom:50%;"></p>
<p>这里的分母是1，使用齐次化的方法。</p>
<p><img src="/Learning/CV/image-20221024152341345.png" alt="image-20221024152341345" style="zoom:50%;"></p>
<p><img src="/Learning/CV/image-20221024152400202.png" alt="image-20221024152400202" style="zoom:50%;"></p>
<h4 id="ransac-1">RANSAC</h4>
<ol type="1">
<li>Randomly choose s samples随机选s个sample
<ul>
<li>Typically s = minimum sample size that lets you fit a model</li>
</ul></li>
<li>Fit a model (e.g., transformation matrix) to those samples
<ul>
<li>fit一个模型</li>
</ul></li>
<li>Count the number of inliers that approximately fit the model
<ul>
<li>计算inlier数量</li>
</ul></li>
<li>Repeat N times
<ul>
<li>重复N次</li>
</ul></li>
<li>Choose the model that has the largest set of inliers
<ul>
<li>挑选最多inliner的model</li>
</ul></li>
</ol></li>
</ol>
<h2 id="l7">L7</h2>
<h3 id="structure-from-motion">Structure From Motion</h3>
<h4 id="camera-model">Camera Model</h4>
<ul>
<li>相机摆在一个位置pose</li>
<li>将现实的坐标点进行几何变换，到相机坐标中
<ul>
<li>坐标系转换，从世界坐标系到相机坐标系：外参矩阵</li>
<li>透视投影，图像平面图像传感器的映射：内参矩阵</li>
</ul></li>
</ul>
<h5 id="坐标转换">坐标转换</h5>
<p>从世界坐标系到相机坐标系的旋转矩阵为R，相机位置为<span class="math inline">\(C_w\)</span></p>
<p><img src="/Learning/CV/image-20221031134907479.png" alt="image-20221031134907479" style="zoom:50%;"></p>
<p>那么变换为<span class="math inline">\(X_c=R(X_w-C_w)\)</span></p>
<p><span class="math inline">\(X_c=RX_w+t,t=-RC_w\)</span></p>
<p>我们同样可以用一个4×4的矩阵表示，就是<strong>外参矩阵<span class="math inline">\(M_{ext}\)</span></strong></p>
<p><img src="/Learning/CV/image-20221031135249734.png" alt="image-20221031135249734" style="zoom:50%;"></p>
<h5 id="透视投影">透视投影</h5>
<p>相机坐标系的三维坐标要转换成像平面的二维坐标</p>
<p><span class="math inline">\(x_c=\begin{bmatrix}x_c\\y_c\\z_c\end{bmatrix}\)</span></p>
<p><span class="math inline">\(x_i=f\begin{bmatrix}x_c/z_c\\y_c/z_c\\1\end{bmatrix}\)</span></p>
<h5 id="像平面到传感器的映射">像平面到传感器的映射</h5>
<p>到上面那一步的单位还是mm，我们需要的是pixel。</p>
<p>假设我们的分辨率为<span class="math inline">\(m_x,m_y\)</span></p>
<p><span class="math inline">\(u=m_xf\frac{x_c}{z_c}+c_x\)</span></p>
<p><span class="math inline">\(v=m_yf\frac{y_c}{z_c}+c_y\)</span></p>
<p>那么在齐次坐标系下：</p>
<p><span class="math inline">\(\begin{bmatrix}u\\v\\1\end{bmatrix}=\begin{bmatrix}f_x\
0\ c_x\\0\ f_y\ c_y\\0\ 0\
1\end{bmatrix}\begin{bmatrix}x_c\\y_c\\z_c\end{bmatrix}=\begin{bmatrix}f_x\
0\ c_x\ 0\\0\ f_y\ c_y\ 0\\0\ 0\ 1\
0\end{bmatrix}\begin{bmatrix}x_c\\y_c\\z_c\\1\end{bmatrix}\)</span></p>
<p><span class="math inline">\(f_x=m_xf\)</span></p>
<p><span class="math inline">\(f_y=m_yf\)</span></p>
<p>这个就是相机的<strong>内参矩阵3×4<span class="math inline">\(M_{int}\)</span></strong></p>
<h5 id="投影矩阵">投影矩阵</h5>
<p><span class="math inline">\(u=M_{int}M_{ext}x_w\)</span></p>
<p>我们记内参矩阵×外参矩阵为<strong>投影矩阵P</strong></p>
<h4 id="相机标定">相机标定</h4>
<p>给我一张图像，如何找这个内参矩阵和外参矩阵的参数呢？如何在世界坐标系下计算相机的位置和方向？相机标定。</p>
<ol type="1">
<li><p>捕获具有已知几何形状的物体的图像，例如校准板，<strong>得到一些角点的世界坐标</strong></p></li>
<li><p>对其进行拍照，通过角点检测匹配，知道三维点对应的<strong>二维坐标</strong></p></li>
<li><p>对于场景和图像中的每个对应点，带入计算投影矩阵的参数</p>
<figure>
<img src="/Learning/CV/image-20221230180427217.png" alt="image-20221230180427217">
<figcaption aria-hidden="true">image-20221230180427217</figcaption>
</figure></li>
<li><p>解优化问题</p>
<p>像前面的图像缝合的一样的方法，我们进行约束</p>
<p><img src="/Learning/CV/image-20221031142010472.png" alt="image-20221031142010472" style="zoom:80%;"></p>
<p><span class="math inline">\(||p||^2=1\)</span></p>
<p>求解<span class="math inline">\(Ap=0\)</span></p>
<p>即<span class="math inline">\(min_p||Ap||^2\)</span></p></li>
<li><p>可以证明矩阵<span class="math inline">\(A^TA\)</span>的特征向量<span class="math inline">\(p\)</span>具有最小的特征值<span class="math inline">\(λ\)</span>是解。</p></li>
</ol>
<p>我们获得了P的参数就获得了P矩阵，接下来我们要求<span class="math inline">\(M_{int},M_{ext}\)</span></p>
<p>我们对P矩阵左边的3×3的矩阵使用QR分解获得上三角阵K和一个正交矩阵R。</p>
<p>那么我们知道K就是内参矩阵的左边3×3的，R是我们的旋转矩阵，我们还需要一个平移参数t。</p>
<p>根据公式我们知道<span class="math inline">\(t=K^{-1}\begin{bmatrix}p_{14}\\p_{24}\\p_{34}\end{bmatrix}\)</span></p>
<h4 id="pnp问题">PnP问题</h4>
<p>求解<strong>世界坐标系和相机坐标系</strong>的位置关系，给定3D-2D对应</p>
<p>我们有6个未知数：旋转3个，平移3个</p>
<p>也是6DoF，6自由度位置位置问题</p>
<p><strong>最少三对点，但是三对点不够！</strong></p>
<h4 id="位姿估计">位姿估计</h4>
<p>类似于视觉定位，获得<strong>物体在相机坐标系</strong>下的旋转和平移是怎么样的</p>
<h3 id="sfm">SfM</h3>
<ul>
<li>假设每个相机的内在矩阵K都是已知的</li>
<li>找到几个可靠的对应点</li>
<li>求出相对相机位置t和方向R</li>
<li>寻找场景点的三维位置</li>
</ul>
<h5 id="特征匹配获得匹配的特征点对">特征匹配：获得匹配的特征点对</h5>
<h5 id="通过对应关系求解两个相机的相对位置">通过对应关系，求解两个相机的相对位置</h5>
<p><img src="/Learning/CV/image-20221031151346221.png" alt="image-20221031151346221" style="zoom:67%;"></p>
<ul>
<li>极线：极平面和像平面的交线</li>
<li>极点：相机连线和像平面的交点，即相机在另一个相机中成像的点</li>
<li>P点的极平面：点P和相机位置形成的平面</li>
<li>极线约束：
<ul>
<li>极平面的法向量：<span class="math inline">\(n=t\times
x_l\)</span>,t是两个相机的位移，<span class="math inline">\(x_l\)</span>是P点到左边相机的的向量</li>
<li><span class="math inline">\(x_l·(t\times x_l)=0\)</span></li>
<li><figure>
<img src="/Learning/CV/image-20221031152004860.png" alt="image-20221031152004860">
<figcaption aria-hidden="true">image-20221031152004860</figcaption>
</figure></li>
<li>将左边的l坐标替换为r的</li>
<li><span class="math inline">\(E=T_{×}R\)</span></li>
<li><span class="math inline">\(x_l^TEx_r=0\)</span></li>
</ul></li>
<li><strong>当我们知道了E，我们可以通过奇异值分解获得<span class="math inline">\(T_×\)</span>和<span class="math inline">\(R\)</span>，即可以获得t和R</strong></li>
</ul>
<h4 id="如何获得e">如何获得E？</h4>
<p>我们的<span class="math inline">\(x_l,x_r\)</span>都是三维坐标，如果我们只有二维坐标呢？</p>
<p><span class="math inline">\(z_l\begin{bmatrix}u_l\\v_l\\1\end{bmatrix}=\begin{bmatrix}z_lu_l\\z_lv_l\\z_l\end{bmatrix}=\begin{bmatrix}f_x^l\
0\ o_x^l\\0f_y^l\ o_y^l\\ 0\ 0\
1\end{bmatrix}\begin{bmatrix}x_l\\y_l\\z_l\end{bmatrix}=K_l\begin{bmatrix}x_l\\y_l\\z_l\end{bmatrix}\)</span></p>
<p><span class="math inline">\(z_r\begin{bmatrix}u_r\\v_r\\1\end{bmatrix}=\begin{bmatrix}z_ru_r\\z_rv_r\\z_r\end{bmatrix}=\begin{bmatrix}f_x^r\
0\ o_x^r\\0f_y^r\ o_y^r\\ 0\ 0\
1\end{bmatrix}\begin{bmatrix}x_r\\y_r\\z_r\end{bmatrix}=K_r\begin{bmatrix}x_r\\y_r\\z_r\end{bmatrix}\)</span></p>
<p>那么极线约束就变成了</p>
<p><span class="math inline">\([u_l\ v_l\
1]{K_l^{-1}}^TEK_r^{-1}\begin{bmatrix}u_r\\v_r\\1\end{bmatrix}=0\)</span></p>
<p><span class="math inline">\(F={K_l^{-1}}^TEK_r^{-1}\)</span></p>
<p><span class="math inline">\([u_l\ v_l\
1]F\begin{bmatrix}u_r\\v_r\\1\end{bmatrix}=0\)</span></p>
<p><span class="math inline">\(E=K_l^TFK_r\)</span></p>
<p>这里的F可以替换为kF，增加一个任意的缩放，这里我们可以添加限制为<span class="math inline">\(||f||^2=1\)</span></p>
<h4 id="相对相机姿态估计">相对相机姿态估计</h4>
<ol type="1">
<li>对于每个对应i，写出外极约束。<img src="/Learning/CV/image-20221230193948657.png" alt="image-20221230193948657"></li>
<li>重新排列项以形成线性系统。<img src="/Learning/CV/image-20221230194006163.png" alt="image-20221230194006163"></li>
<li>求基本矩阵F的最小二乘解。我们想让Af尽可能接近0，且<span class="math inline">\(||f||^2=1\)</span></li>
<li>解出了F，我们计算E，<span class="math inline">\(E=K_l^TFK_r\)</span></li>
<li>从E中解出R和t，奇异值分解</li>
</ol>
<h3 id="triangulation">Triangulation</h3>
<p><strong>给定相应的二维特征点和摄像机参数，如何找到场景点的三维坐标?</strong></p>
<p>给定了二维特征点和相机内参，我么可以计算出三维点。</p>
<p><span class="math inline">\(\hat u_l=M_{int}^l\hat x_l\)</span></p>
<p><span class="math inline">\(\hat u_r=M_{int}^r\hat x_r\)</span></p>
<p><span class="math inline">\(\hat x_l=M_{ext}^l\hat x_r\)</span></p>
<p>我们有</p>
<p><span class="math inline">\(\hat u_l=P_l \hat x_r\)</span></p>
<p><span class="math inline">\(\hat u_r = M_{int}^r\hat x_r\)</span></p>
<figure>
<img src="/Learning/CV/image-20221230194722032.png" alt="image-20221230194722032">
<figcaption aria-hidden="true">image-20221230194722032</figcaption>
</figure>
<figure>
<img src="/Learning/CV/image-20221230194728712.png" alt="image-20221230194728712">
<figcaption aria-hidden="true">image-20221230194728712</figcaption>
</figure>
<h4 id="sequential-structure-from-motion">Sequential Structure from
Motion</h4>
<ol type="1">
<li>初始化相机运动和场景结构</li>
<li>对于每个额外的视图
<ol type="1">
<li>利用新相机图像中所有可见的已知三维点，确定新相机的投影矩阵</li>
<li>优化和扩展结构:计算新的3D点，重新优化现有的点，也被这台相机看到</li>
</ol></li>
<li>细化结构和运动:束调整</li>
</ol>
<h2 id="l8">L8</h2>
<h4 id="深度感知">深度感知</h4>
<ul>
<li>主动：雷达传感器、结构光、active stereo立体视觉</li>
<li>被动：Structure From Motion、stereo立体视觉</li>
</ul>
<h4 id="stereo-vision">Stereo Vision</h4>
<p>两只眼睛看一个东西，使用视差，从而感知距离。</p>
<p>假设相机相对位置已经固定，如何估计<strong>所有点</strong>的深度？</p>
<p>给定了<span class="math inline">\(X_L\)</span>，<span class="math inline">\(X_R\)</span>一定在极线上！具体位置和<span class="math inline">\(X_L\)</span>对应的具体深度有关</p>
<p><img src="/Learning/CV/image-20221231094937861.png" alt="image-20221231094937861" style="zoom:67%;"></p>
<p>我们搜索匹配点时，只需要沿着极线寻找即可。</p>
<p>当两个相机水平，极线就是水平的，最好寻找！</p>
<h4 id="depth-from-disparity">Depth from disparity</h4>
<p>视差，就是两个极点之间的距离，即<span class="math inline">\(x_2-x_1\)</span></p>
<p><span class="math inline">\(disparity=x-x&#39;=\frac{Bf}{z}\)</span></p>
<p>这里的B是两个相机的距离，即Baseline，f为焦距，z为深度</p>
<ul>
<li>B小：深度误差大</li>
<li>B大：困难的搜索问题</li>
</ul>
<p><img src="/Learning/CV/image-20221231095421382.png" alt="image-20221231095421382" style="zoom:67%;"></p>
<p><strong>当epipolar line不是水平的时候怎么办？</strong></p>
<p>图像矫正，实际的相平面不是满足水平的。我们假设我们调整了相机获得了水平线的虚相机平面，原平面和虚平面有一一对应关系。使用几何变换。</p>
<p><strong>匹配</strong>：我们的匹配是在及线上进行搜索，然后计算不相似度（距离），选择距离最小的就是匹配</p>
<h4 id="stereo-reconstruction-pipeline">Stereo reconstruction
pipeline</h4>
<ol type="1">
<li>校准相机</li>
<li>纠正图像</li>
<li>计算视差</li>
<li>估计深度</li>
</ol>
<p><strong>误差</strong>：存在相机标定的误差、图像分辨率差、遮挡误差、违反亮度恒定误差、纹理稀少存在误差</p>
<h3 id="multi-view-stereo">Multi-view Stereo</h3>
<p>优点</p>
<ul>
<li>可以匹配窗口使用超过1个邻居，给一个更强的约束</li>
<li>如果你有很多潜在的邻居，可以选择邻居的最佳子集来匹配每个参考图像</li>
<li>能否为每个参考帧重建一个深度图，并合并成一个完整的3D模型</li>
</ul>
<p>对每一个视角，我们取其周围的视角的一起计算深度图，每一个视角都会有一个深度图</p>
<p>计算每个点的深度时，我们尝试不同深度与周围视角的误差，取最小的误差的深度。</p>
<p>对于一个ref
view，我们想知道其深度，那么我们就尝试一个深度，将这个深度代入到neighbor
view中进行计算误差，寻找误差最小的深度。</p>
<h4 id="plane-sweep">Plane-Sweep</h4>
<p>对于一个像素的深度为d，那么我们投影到其他的邻居相机中计算误差，这个过程可以直接在平面上进行，更高效计算。就是说我们对所有的像素尝试一个深度，进行计算误差。</p>
<p><img src="/Learning/CV/image-20221107151621273.png" alt="image-20221107151621273" style="zoom:67%;"></p>
<ul>
<li>平行于参考相机图像平面的扫描平面族</li>
<li>将每个平面投影到相邻视图(通过单应性)并比较像素值</li>
</ul>
<p>最后得到了Cost
Volumes，是一个3D数组，它存储所有像素在所有深度的误差。类似于穷举。</p>
<p><img src="/Learning/CV/image-20221107151755752.png" alt="image-20221107151755752" style="zoom:67%;"></p>
<h3 id="d-representations">3D Representations</h3>
<ul>
<li>点云：一系列3D点
<ul>
<li>+容易获取</li>
<li>-空间开销大</li>
<li>-缺少点与点之间连接关系</li>
</ul></li>
<li>体素：Occupancy、Signed Distance（SDF）
<ul>
<li>Voxel
<ul>
<li>三维的离散化的格子</li>
<li>voxel，立方体的值代表这个点是否被占用。</li>
<li>+规则表示，容易送入网络学习</li>
<li>+可以处理任意拓扑结构</li>
<li>-随着分辨率增加，内存呈立方级增长</li>
<li>-物体表示不够精细</li>
<li>-纹理不友好</li>
</ul></li>
<li>SDF：点到形状边界的距离，距离由一个度规定义，通常是欧几里得距离
<ul>
<li>+可以精细建模细节，理论上分辨率无穷</li>
<li>+内存占用少</li>
<li>+网络易于学习</li>
<li>-需后处理得到显式几何结构</li>
</ul></li>
</ul></li>
<li>Mesh：网格
<ul>
<li>通常是三角网格</li>
<li>+高质量描述 3D 几何结构</li>
<li>+内存占有较少</li>
<li>+纹理友好</li>
<li>-网络难以学习</li>
<li>-不同物体类别需要不同的mesh模板</li>
</ul></li>
<li>Occupancy Function
<ul>
<li>使用一个函数划分一个边界面</li>
<li>+可以精细建模细节，理论上分辨率无穷</li>
<li>+内存占用少</li>
<li>+网络易于学习</li>
<li>-需后处理得到显式几何结构</li>
</ul></li>
</ul>
<h4 id="重建方法">重建方法</h4>
<ul>
<li>深度图转化为体素
<ul>
<li>KinectFusion,</li>
<li>Poisson reconstruction</li>
</ul></li>
</ul>
<h5 id="泊松重建">泊松重建</h5>
<p>输入点云，输出体素</p>
<h4 id="marching-cubes">Marching cubes</h4>
<p>从Volume提取Mesh</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MC算法实际上是一个分而治之的方法，因为其将等值面的抽取分布于每一个体素<span class="comment">(voxel)</span>中进行。对于每个被处理的体素，以三角面片来逼近其内部的等值面。每个体素是一个小立方体<span class="comment">(cube)</span>，在构造三角面片的处理过程中对每个体素都“扫描”一遍，就好像是一个处理器在这些体素上移动一样，也因此而得名。</span><br></pre></td></tr></table></figure>
<h2 id="l9">L9</h2>
<h3 id="线性分类器">线性分类器</h3>
<ul>
<li>输入：image</li>
<li>输出：类别的得分</li>
</ul>
<p>数据驱动，我们输入一系列的数据集（图像和标签），训练一个分类器，用以分类新的图像</p>
<p><span class="math inline">\(f(x,W)\)</span>，x为图像，W为参数</p>
<p><span class="math inline">\(f(x,W)=Wx+b\)</span></p>
<h5 id="loss-function">Loss Function</h5>
<p>MSE loss：<span class="math inline">\(min_w\sum_i(y_i-f_w(x_i))^2\)</span></p>
<p>能用MSEloss给分类任务吗？不能，标签是离散的，分数是实数</p>
<p>类标签可以看作概率</p>
<ul>
<li>将分数转换为概率
<ul>
<li>softmax：<span class="math inline">\(\sigma(z)_j=\frac{e^{z_j}}{\sum_k
e^{z_k}}\)</span></li>
</ul></li>
<li>计算预测和真实概率之间的交叉熵
<ul>
<li><span class="math inline">\(-\sum c_i\ log(p_i)\)</span></li>
<li>ci为类别，pi为该类别的概率</li>
</ul></li>
</ul>
<h3 id="神经网络">神经网络</h3>
<p>一般的全连接的神经网络是线性的（感知机），如何变成非线性的？</p>
<ul>
<li><span class="math inline">\(f(x,W)=Wx+b\)</span></li>
<li><span class="math inline">\(f(x,W)=\sigma(Wx+b)\)</span></li>
<li>增加一个激活函数Relu、sigmoid等</li>
</ul>
<h4 id="多层感知机">多层感知机</h4>
<p>可以写成函数表达式，比如有一个隐藏层的多层感知机</p>
<p><span class="math inline">\(f(x)=\sigma
(W_2(\sigma(W_1x+b_1))+b_2)\)</span></p>
<h3 id="卷积神经网络">卷积神经网络</h3>
<p>我们可以通过局部模式来识别图像，我们使用卷积来实现类似的识别</p>
<p>基本模式：<strong>卷积、非线性化（激活）、池化</strong></p>
<h4 id="二维卷积-1">二维卷积</h4>
<p>图像大小：image size</p>
<p>卷积核大小：Filter size</p>
<ul>
<li>输出feature map大小：image size-Filter size+1</li>
<li>有Padding和stride的情况：（image size-Filter
size+Padding*2）/Stride</li>
</ul>
<p>如果有通道，那么我们的卷积核也要是对应通道数的</p>
<h5 id="pooling">Pooling</h5>
<ul>
<li>Max Pooling：将区域内的值合并后设置为最大值</li>
<li>Average Pooling：：区域内的值合并后全部是平均值</li>
</ul>
<h4 id="为什么用卷积神经网络">为什么用卷积神经网络</h4>
<p>卷积神经网络能够用卷积的方式从原信息中提取"<strong>部分特定的信息</strong>(信息跟卷积核相关)",且对于二维的图像来说是原生支持的(不需要处理),这就保留了图像中的空间信息,而空间信息是具有可平移性质的</p>
<h3 id="神经网络的训练">神经网络的训练</h3>
<p>梯度下降法训练神经网络</p>
<ul>
<li>设定参数</li>
<li>计算损失函数</li>
<li>进行梯度下降：backpropagation</li>
</ul>
<ol type="1">
<li>通过网络转发数据，得到丢失</li>
<li>Backprop计算梯度</li>
<li>使用渐变更新参数</li>
<li>如果未融合，请执行步骤1</li>
</ol>
<h3 id="data">Data</h3>
<p>数据的分割，我们的数据集可以分为train、test和validation</p>
<p>只分为train和test的话，我们不知道它在新数据上的表现</p>
<h4 id="data-augmentation">Data augmentation</h4>
<p>数据增强，我们可以将同一个训练图像进行几何变换等方式产生新的屯连图像，从而扩大我们的数据集。</p>
<h3 id="过拟合">过拟合</h3>
<p>参数过于复杂的情况，我们可以添加<strong>Cross
validation</strong>、<strong>早停</strong>、<strong>正则化项</strong>、<strong>Dropout</strong>、<strong>数据增强</strong>等来避免。</p>
<h2 id="l10">L10</h2>
<h3 id="语义分割">语义分割</h3>
<p>用类别标签标记图像中的每个像素不要区分实例，将每一个像素给一个分类的标签</p>
<ul>
<li>效率很低，并且全局信息较少。</li>
</ul>
<p>Sliding window，我们使用滑动的窗口，用CNN来判定窗口中心的分类</p>
<h4 id="全卷积神经网络">全卷积神经网络</h4>
<ul>
<li>一次性做出预测</li>
<li>训练的损失函数是什么?逐像素交叉熵</li>
</ul>
<p>该网络在前面两步跟CNN的结构是一样的，但是在CNN网络Flatten的时候，FCN网络将之换成了一个卷积核size为5x5，输出通道为50的卷积层，之后的全连接层都换成了1x1的卷积层。</p>
<h4 id="unpooling">Unpooling</h4>
<ul>
<li>Bed of Nails
<ul>
<li><img src="/Learning/CV/image-20221231201036344.png" alt="image-20221231201036344" style="zoom:50%;"></li>
</ul></li>
<li>Nearest Neighbor
<ul>
<li><img src="/Learning/CV/image-20221231201053482.png" alt="image-20221231201053482" style="zoom:50%;"></li>
</ul></li>
<li>Bilinear Interpolation
<ul>
<li><img src="/Learning/CV/image-20221231201304585.png" alt="image-20221231201304585" style="zoom:50%;"></li>
</ul></li>
<li>Bicubic Interpolation
<ul>
<li><img src="/Learning/CV/image-20221231201320935.png" alt="image-20221231201320935" style="zoom:50%;"></li>
</ul></li>
</ul>
<h3 id="object-detection">Object detection</h3>
<p>输入：一张RGB图像</p>
<p>输出：一些bounding box，包裹检测的物体</p>
<h4 id="detecting-a-single-object">Detecting a single object</h4>
<p>一张图像，输入到全连接神经网络中输出1000个分类的概率预测</p>
<p>同时输入到一个输出4维度的box坐标、</p>
<p>这样我们获得了物体的label以及bounding box的位置</p>
<h4 id="detecting-multiple-objects">Detecting multiple objects</h4>
<p>每张图像需要不同数量的输出</p>
<p>将CNN应用于图像的许多不同作物，CNN将每个作物分类为对象或背景</p>
<p>假设box的大小为h*w</p>
<ul>
<li>x的可能位置W-w+1</li>
<li>y的可能位置H-h+1</li>
<li>bbox的所有可能位置(W-w+1)*(H-h+1)</li>
</ul>
<p>显然这样子太难算了</p>
<h5 id="region-proposals">Region proposals</h5>
<ul>
<li>找到一组可能涵盖所有对象的小盒子</li>
<li>通常是基于启发式的
<ul>
<li>通过过分割</li>
</ul></li>
<li>跑得相对快：选择性搜索在CPU上几秒钟内提供2000个区域建议</li>
</ul>
<h4 id="r-cnn">R-CNN</h4>
<p>对于我们可能区域，进行计算，把每一个区域进行resize到224*224，输入到CNN</p>
<p>进行class scores和bbox的预测</p>
<p>使用分数选择要输出的区域建议的子集</p>
<h4 id="评价指标">评价指标</h4>
<p>IoU：</p>
<ul>
<li><span class="math inline">\(IoU=\frac{Area\ of Intersection}{Area\
of\ Union}\)</span></li>
<li>IoU越大说明和真实的越接近，越好</li>
</ul>
<h4 id="fast-r-cnn">Fast R-CNN</h4>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fast RCNN与RCNN的不同主要在于Fast RCNN引入了ROI Pooling，在RCNN中，在进行卷积操作之前一般都是先将图片分割与形变到固定尺寸，这也正是RCNN的劣势之处，这会让图像产生形变，或者图像变得过小，使一些特征产生了损失，继而对之后的特征选择产生巨大影响，所以引入了ROI Pooling.</span><br></pre></td></tr></table></figure>
<ul>
<li>获得可能区域</li>
<li>对于这些区域进行resize，<strong>进行Rol
Pooling</strong>，即输入的图像大小不固定，输出的feature map大小固定</li>
<li>输入到CNN</li>
</ul>
<h4 id="faster-r-cnn">Faster R-CNN</h4>
<p>Faster RCNN 与 Fast
RCNN的区别主要是引入了区域生成网络RPN候选框提取模块。</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RPN的工作步骤如下：</span><br><span class="line">- 在feature map（特征图）上滑动窗口（anchors）</span><br><span class="line">- 建一个神经网络用于物体分类+框位置的回归</span><br><span class="line">- 滑动窗口的位置提供了物体的大体位置信息</span><br><span class="line">- 框的回归提供了框更精确的位置</span><br><span class="line">其实RPN最终就是在原图尺度上，设置了密密麻麻的候选Anchor，然后用cnn去判断哪些Anchor是里面有目标的positive <span class="built_in">anchor</span>，哪些是没目标的negative <span class="built_in">anchor</span>。所以，仅仅是个二分类而已！</span><br></pre></td></tr></table></figure>
<ul>
<li>获得可能区域，<strong>使用RPN生成候选区域</strong></li>
<li>对于这些区域进行resize，进行Rol Pooling</li>
<li>输入到CNN</li>
</ul>
<h2 id="l12">L12</h2>
<h3 id="hdr">HDR</h3>
<p>High Dynamic Range Imaging</p>
<ul>
<li><p>Exposure：曝光<span class="math inline">\(Exposure=Gain\times
Irradiance\times Time\)</span></p>
<ul>
<li>Gain：由ISO控制</li>
<li>Irradiance：辐照度，由光圈aperture大小控制</li>
<li>Time：由快门时间shutter speed控制</li>
</ul></li>
<li><p>ISO：感光度</p>
<ul>
<li><pre><code>  感光度是衡量底片对于光的灵敏程度，由敏感度测量学及测量数个数值来决定，国际标准化组织标准为ISO 6。对于光较不敏感的底片，需要曝光更长的时间以达到跟较敏感底片相同的成像，因此通常被称为慢速底片。高度敏感的底片因而称为快速底片。</code></pre></li>
<li>Iso的副作用：由于噪声被放大，图像变得非常模糊。</li>
</ul></li>
<li><p>拍照时，平均曝光应在传感器测量范围的中间。这样照片的明暗部分都有细节。</p></li>
</ul>
<h4 id="dynamic-range">Dynamic Range</h4>
<p>某一数值(如亮度)的最大值与最小值之比。</p>
<ul>
<li>比如8位的RGB的图像的Dynamic Range就是256：1</li>
<li>real world的Dynamic Range是100000：1</li>
<li>我们用了256：1的Dynamic Range来表示现实世界的100000：1的Dynamic
Range</li>
</ul>
<h5 id="image-formation-model">Image Formation Model</h5>
<p>假设图像像素(x, y)的场景亮度为L(x, y)</p>
<ul>
<li><span class="math inline">\(I(x,y)=clip[t_i*L(x,y)+noise]\)</span></li>
</ul>
<ol type="1">
<li><p>曝光括弧：在不同曝光下捕捉多个LDR图像Lower Dynamic Range</p></li>
<li><p>合并：将它们合并成一个HDR图像</p>
<ol type="1">
<li><p>在每个图像中找到“有效的”像素：noise0.05&lt;pixel&lt;0.95clipping</p></li>
<li><p>适当地对有效像素值进行加权</p>
<p>权重如何确定？合理的像素值除以曝光时间<span class="math inline">\(pixel\ value/t_i\)</span></p></li>
<li><p>形成一个新的像素值作为有效像素值的加权平均值</p></li>
</ol></li>
</ol>
<h5 id="tone-mapping如何将hdr图像12-bit在8-bit的sdr上显示"><strong>Tone
Mapping</strong>如何将HDR图像12-bit在8-bit的SDR上显示？</h5>
<ul>
<li>线性压缩：<span class="math inline">\(X\rarr aX\)</span></li>
<li>gamma压缩：<span class="math inline">\(X\rarr
aX^\gamma\)</span></li>
</ul>
<p><img src="/Learning/CV/image-20221205145806066.png" alt="image-20221205145806066" style="zoom:67%;"></p>
<h3 id="deblurring">Deblurring</h3>
<p>为什么会模糊</p>
<ul>
<li>失焦：被摄对象不在景深内</li>
<li>运动模糊：移动的物体或不稳定的相机</li>
</ul>
<p>如何获得更加清晰的图像</p>
<ul>
<li>准确的焦点</li>
<li>快速的快门速度
<ul>
<li>大光圈导致模糊</li>
<li>高Iso导致模糊</li>
</ul></li>
<li>使用硬件设备：三脚架、云台等</li>
</ul>
<h4 id="模糊的数学模型">模糊的数学模型</h4>
<p><strong>散焦的模糊模式取决于光圈形状，抖动的模糊模式取决于相机的轨迹</strong></p>
<ul>
<li>模糊过程可以用卷积来描述
<ul>
<li>blurred image = clear image × blur kernel</li>
</ul></li>
<li>模糊后的图像称为卷积核</li>
</ul>
<h5 id="nbid">NBID</h5>
<p>未知的clear image和已知的kernel</p>
<h5 id="bid">BID</h5>
<p>未知的clear image和未知的kernel</p>
<h5 id="对于nbid去卷积">对于NBID去卷积</h5>
<p><span class="math inline">\(G=F\otimes
H\)</span>，F是我们要求的，G和H是已知的</p>
<p>我们对其进行傅里叶变换</p>
<p><span class="math inline">\(FFT(G)=FFT(F\otimes H)=FFT(F)\times
FFT(H)\)</span></p>
<p><span class="math inline">\(FFT(F)=FFT(G)\div FFT(H)\)</span></p>
<p>逆傅里叶变换得到F</p>
<p><span class="math inline">\(F=IFFT(FFT(G)\div FFT(H))\)</span></p>
<p>也可以用优化来计算</p>
<p><span class="math inline">\(MSE=||G-F\otimes H||_2^2\)</span></p>
<p>Deconvolution is ill-posed</p>
<h2 id="l12-1">L12</h2>
<h3 id="gan">GAN</h3>
<p>GAN：生成对抗网络</p>
<ul>
<li>生成网络：CNN等能够生成图片的网络</li>
<li>对抗网络：一个鉴别器，判别输入的图像是合成的图像还是真实的图像。</li>
<li><figure>
<img src="/Learning/CV/image-20221212135136065.png" alt="image-20221212135136065">
<figcaption aria-hidden="true">image-20221212135136065</figcaption>
</figure></li>
<li>D：Fake输出接近1，Real输出接近0</li>
<li>GAN网络的训练：
<ul>
<li>D的训练：<span class="math inline">\(argmax_D
E_{x,y}[logD(G(x))+log(1-D(y))]\)</span></li>
<li>G的训练：<span class="math inline">\(argmin_GE_{x,y}[logD(G(x))+log(1-D(y))]\)</span></li>
<li>一起训练：<span class="math inline">\(argmin_Gmax_DE_{x,y}[logD(G(x))+log(1-D(y))]\)</span></li>
</ul></li>
<li>D可以看作是训练G的损失函数
<ul>
<li>叫做对抗性损失</li>
<li>学习而不是手工设计</li>
</ul></li>
</ul>


        <hr>
        <!-- Pager -->
        <ul class="pager">
          
          <li class="previous">
            <a href="/Learning/操作系统/" data-toggle="tooltip" data-placement="top" title="操作系统">&larr; Previous Post</a>
          </li>
          
          
          <li class="next">
            <a href="/Learning/机器学习/" data-toggle="tooltip" data-placement="top" title="机器学习">Next Post &rarr;</a>
          </li>
          
        </ul>

        
        <!-- tip start -->
        <!-- tip -->
<!-- tip start -->
<div class="tip">
  <p>
    
      如果您喜欢此博客或发现它对您有用，则欢迎对此发表评论。 也欢迎您共享此博客，以便更多人可以参与。 如果博客中使用的图像侵犯了您的版权，请与作者联系以将其删除。 谢谢 ！
    
  </p>
</div>
<!-- tip end -->

        <!-- tip end -->
        

        
        <!-- Sharing Srtart -->
        <!-- Social Social Share Post -->
<!-- Docs:https://github.com/overtrue/share.js -->

<div class="social-share" data-initialized="true" data-disabled="tencent ,douban ,qzone ,linkedin ,facebook ,google ,diandian" data-wechat-qrcode-helper="" align="center">
  <ul class="list-inline text-center social-share-ul">
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon icon-twitter">
        <i class="fa fa-twitter fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a class="social-share-icon icon-wechat">
        <i class="fa fa-weixin fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon icon-weibo">
        <i class="fa fa-weibo fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon icon-qq">
        <i class="fa fa-qq fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon" href="mailto:?subject=CV复习版&body=Hi,I found this website and thought you might like it http://Hualingz.cn/Learning/CV/">
        <i class="fa fa-envelope fa-1x" aria-hidden="true"></i>
      </a>
    </li>
  </ul>
</div>

<!-- css & js -->
<!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css"> -->
<script defer="defer" async="true" src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>

        <!-- Sharing End -->
        
        <hr>

        <!-- comments start -->
        <!-- 1. gitalk comment -->

  <!-- gitalk start -->
  <!-- Docs:https://github.com/gitalk/gitalk/blob/master/readme-cn.md -->

  <div id="gitalk-container"></div>

  
    <!-- <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.js"></script> -->
    <script src="/js/comment/gitalk.js"></script>
  

  <script>
    var gitalk = new Gitalk({
      clientID: '',
      clientSecret: '',
      repo: '',
      owner: '',
      admin: '',
      id: 'Thu Feb 16 2023 18:53:29 GMT+0800', // Ensure uniqueness and length less than 50
      distractionFreeMode: false, // Facebook-like distraction free mode
      perPage: 10,
      pagerDirection: 'last',
      createIssueManually: false,
      language: 'en',
      proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token'
    });
    gitalk.render('gitalk-container');

    var gtFolded = () => {
      setTimeout(function () {
        let markdownBody = document.getElementsByClassName("markdown-body");
        let list = Array.from(markdownBody);
        list.forEach(item => {
          if (item.clientHeight > 250) {
            item.classList.add('gt-comment-body-folded');
            item.style.maxHeight = '250px';
            item.title = 'Click to Expand';
            item.onclick = function () {
              item.classList.remove('gt-comment-body-folded');
              item.style.maxHeight = '';
              item.title = '';
              item.onclick = null;
            };
          }
        })
      }, 800);
    }
  </script>

  <!-- gitalk end -->


<!-- 2. gitment comment -->


<!-- 3. disqus comment -->


        <!-- comments end -->
        <hr>

      </div>

      <!-- Catalog: Tabe of Content -->
      <!-- Table of Contents -->

    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">目录</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#l1"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">L1</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2"><span class="toc-nav-number">1.0.1.</span> <span class="toc-nav-text">线性变换</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#l2"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">L2</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%B0%8F%E5%AD%94%E7%9B%B8%E6%9C%BA"><span class="toc-nav-number">2.0.1.</span> <span class="toc-nav-text">小孔相机</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E9%80%8F%E8%A7%86%E5%8F%98%E6%8D%A2%E5%85%AC%E5%BC%8F"><span class="toc-nav-number">2.0.2.</span> <span class="toc-nav-text">透视变换公式</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E7%81%AD%E7%82%B9"><span class="toc-nav-number">2.0.3.</span> <span class="toc-nav-text">灭点</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E7%81%AD%E7%BA%BF"><span class="toc-nav-number">2.0.3.1.</span> <span class="toc-nav-text">灭线</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%A4%B1%E7%9C%9Fdistortion"><span class="toc-nav-number">2.0.3.2.</span> <span class="toc-nav-text">失真Distortion</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#perspective-distortion"><span class="toc-nav-number">2.0.3.3.</span> <span class="toc-nav-text">Perspective Distortion</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#radial-distortion"><span class="toc-nav-number">2.0.3.4.</span> <span class="toc-nav-text">Radial Distortion</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%AD%A3%E5%B0%84%E6%8A%95%E5%BD%B1orthographic-projection"><span class="toc-nav-number">2.0.4.</span> <span class="toc-nav-text">正射投影Orthographic
projection</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%BF%AB%E9%97%A8shutter"><span class="toc-nav-number">2.0.5.</span> <span class="toc-nav-text">快门Shutter</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#rolling-shutter-effect"><span class="toc-nav-number">2.0.6.</span> <span class="toc-nav-text">Rolling Shutter Effect</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E9%A2%9C%E8%89%B2color"><span class="toc-nav-number">2.0.7.</span> <span class="toc-nav-text">颜色Color</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#bayer-filter%E8%B4%9D%E5%B0%94%E6%BB%A4%E6%B3%A2%E5%99%A8"><span class="toc-nav-number">2.0.7.1.</span> <span class="toc-nav-text">Bayer Filter贝尔滤波器</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#l3"><span class="toc-nav-number">2.1.</span> <span class="toc-nav-text">L3</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86"><span class="toc-nav-number">2.1.1.</span> <span class="toc-nav-text">图像处理</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E4%BA%AE%E5%BA%A6%E5%8F%98%E5%8C%96"><span class="toc-nav-number">2.1.1.1.</span> <span class="toc-nav-text">亮度变化</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%8D%B7%E7%A7%AF"><span class="toc-nav-number">2.1.1.2.</span> <span class="toc-nav-text">卷积</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#%E4%BA%8C%E7%BB%B4%E5%8D%B7%E7%A7%AF"><span class="toc-nav-number">2.1.1.2.1.</span> <span class="toc-nav-text">二维卷积</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E6%A8%A1%E7%B3%8A"><span class="toc-nav-number">2.1.1.3.</span> <span class="toc-nav-text">模糊</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E9%94%90%E5%8C%96sharpen"><span class="toc-nav-number">2.1.1.4.</span> <span class="toc-nav-text">锐化Sharpen</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E6%B1%82%E6%A2%AF%E5%BA%A6%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B"><span class="toc-nav-number">2.1.1.5.</span> <span class="toc-nav-text">求梯度，边缘检测</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%8F%8C%E8%BE%B9%E6%BB%A4%E6%B3%A2"><span class="toc-nav-number">2.1.1.6.</span> <span class="toc-nav-text">双边滤波</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%9B%BE%E5%83%8F%E5%B0%BA%E5%AF%B8%E5%8F%98%E6%8D%A2"><span class="toc-nav-number">2.1.2.</span> <span class="toc-nav-text">图像尺寸变换</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#%E5%87%8F%E5%B0%8F%E5%B0%BA%E5%AF%B8"><span class="toc-nav-number">2.1.2.0.1.</span> <span class="toc-nav-text">减小尺寸</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#%E5%A2%9E%E5%A4%A7%E5%B0%BA%E5%AF%B8"><span class="toc-nav-number">2.1.2.0.2.</span> <span class="toc-nav-text">增大尺寸</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E6%94%B9%E5%8F%98%E5%9B%BE%E5%83%8F%E6%AF%94%E4%BE%8B"><span class="toc-nav-number">2.1.2.1.</span> <span class="toc-nav-text">改变图像比例</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#l4"><span class="toc-nav-number">2.2.</span> <span class="toc-nav-text">L4</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-nav-number">2.2.1.</span> <span class="toc-nav-text">优化</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95"><span class="toc-nav-number">2.2.1.1.</span> <span class="toc-nav-text">梯度下降法</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E7%89%9B%E9%A1%BF%E6%B3%95"><span class="toc-nav-number">2.2.1.2.</span> <span class="toc-nav-text">牛顿法</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E9%AB%98%E6%96%AF%E7%89%9B%E9%A1%BF%E6%B3%95"><span class="toc-nav-number">2.2.1.3.</span> <span class="toc-nav-text">高斯牛顿法</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#outlierinlier"><span class="toc-nav-number">2.2.2.</span> <span class="toc-nav-text">Outlier&amp;Inlier</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#ransac"><span class="toc-nav-number">2.2.3.</span> <span class="toc-nav-text">RANSAC</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%AD%A3%E5%88%99%E5%8C%96"><span class="toc-nav-number">2.2.4.</span> <span class="toc-nav-text">正则化</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#l2-1"><span class="toc-nav-number">2.2.4.0.1.</span> <span class="toc-nav-text">L2</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#l1-1"><span class="toc-nav-number">2.2.4.0.2.</span> <span class="toc-nav-text">L1</span></a></li></ol></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#l5"><span class="toc-nav-number">2.3.</span> <span class="toc-nav-text">L5</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E7%89%B9%E5%BE%81%E5%8C%B9%E9%85%8D"><span class="toc-nav-number">2.3.1.</span> <span class="toc-nav-text">特征匹配</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#harris-operator"><span class="toc-nav-number">2.3.1.1.</span> <span class="toc-nav-text">Harris Operator</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#harris-detector"><span class="toc-nav-number">2.3.1.2.</span> <span class="toc-nav-text">Harris Detector</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#blob-detector"><span class="toc-nav-number">2.3.2.</span> <span class="toc-nav-text">Blob Detector</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#%E9%AB%98%E6%96%AF%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E7%AE%97%E5%AD%90log"><span class="toc-nav-number">2.3.2.0.1.</span> <span class="toc-nav-text">高斯拉普拉斯算子LoG</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#%E9%AB%98%E6%96%AF%E5%B7%AE%E5%80%BCdog"><span class="toc-nav-number">2.3.2.0.2.</span> <span class="toc-nav-text">高斯差值DoG</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#sift"><span class="toc-nav-number">2.3.3.</span> <span class="toc-nav-text">SIFT</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#matching"><span class="toc-nav-number">2.3.4.</span> <span class="toc-nav-text">Matching</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#ratio-test"><span class="toc-nav-number">2.3.4.0.1.</span> <span class="toc-nav-text">Ratio test</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#motion-estimation"><span class="toc-nav-number">2.3.5.</span> <span class="toc-nav-text">Motion Estimation</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#lucas-kanade-method"><span class="toc-nav-number">2.3.5.1.</span> <span class="toc-nav-text">Lucas-Kanade Method</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%AD%94%E5%BE%84%E9%97%AE%E9%A2%98"><span class="toc-nav-number">2.3.5.2.</span> <span class="toc-nav-text">孔径问题</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#l6"><span class="toc-nav-number">2.4.</span> <span class="toc-nav-text">L6</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%9B%BE%E5%83%8F%E7%9A%84%E6%8B%BC%E6%8E%A5"><span class="toc-nav-number">2.4.0.1.</span> <span class="toc-nav-text">图像的拼接</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%9B%BE%E5%83%8F%E7%9A%84%E7%BC%9D%E5%90%88"><span class="toc-nav-number">2.4.0.2.</span> <span class="toc-nav-text">图像的缝合</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#ransac-1"><span class="toc-nav-number">2.4.0.3.</span> <span class="toc-nav-text">RANSAC</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#l7"><span class="toc-nav-number">2.5.</span> <span class="toc-nav-text">L7</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#structure-from-motion"><span class="toc-nav-number">2.5.1.</span> <span class="toc-nav-text">Structure From Motion</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#camera-model"><span class="toc-nav-number">2.5.1.1.</span> <span class="toc-nav-text">Camera Model</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2"><span class="toc-nav-number">2.5.1.1.1.</span> <span class="toc-nav-text">坐标转换</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1"><span class="toc-nav-number">2.5.1.1.2.</span> <span class="toc-nav-text">透视投影</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#%E5%83%8F%E5%B9%B3%E9%9D%A2%E5%88%B0%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9A%84%E6%98%A0%E5%B0%84"><span class="toc-nav-number">2.5.1.1.3.</span> <span class="toc-nav-text">像平面到传感器的映射</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#%E6%8A%95%E5%BD%B1%E7%9F%A9%E9%98%B5"><span class="toc-nav-number">2.5.1.1.4.</span> <span class="toc-nav-text">投影矩阵</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A"><span class="toc-nav-number">2.5.1.2.</span> <span class="toc-nav-text">相机标定</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#pnp%E9%97%AE%E9%A2%98"><span class="toc-nav-number">2.5.1.3.</span> <span class="toc-nav-text">PnP问题</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E4%BD%8D%E5%A7%BF%E4%BC%B0%E8%AE%A1"><span class="toc-nav-number">2.5.1.4.</span> <span class="toc-nav-text">位姿估计</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#sfm"><span class="toc-nav-number">2.5.2.</span> <span class="toc-nav-text">SfM</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#%E7%89%B9%E5%BE%81%E5%8C%B9%E9%85%8D%E8%8E%B7%E5%BE%97%E5%8C%B9%E9%85%8D%E7%9A%84%E7%89%B9%E5%BE%81%E7%82%B9%E5%AF%B9"><span class="toc-nav-number">2.5.2.0.1.</span> <span class="toc-nav-text">特征匹配：获得匹配的特征点对</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#%E9%80%9A%E8%BF%87%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB%E6%B1%82%E8%A7%A3%E4%B8%A4%E4%B8%AA%E7%9B%B8%E6%9C%BA%E7%9A%84%E7%9B%B8%E5%AF%B9%E4%BD%8D%E7%BD%AE"><span class="toc-nav-number">2.5.2.0.2.</span> <span class="toc-nav-text">通过对应关系，求解两个相机的相对位置</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97e"><span class="toc-nav-number">2.5.2.1.</span> <span class="toc-nav-text">如何获得E？</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E7%9B%B8%E5%AF%B9%E7%9B%B8%E6%9C%BA%E5%A7%BF%E6%80%81%E4%BC%B0%E8%AE%A1"><span class="toc-nav-number">2.5.2.2.</span> <span class="toc-nav-text">相对相机姿态估计</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#triangulation"><span class="toc-nav-number">2.5.3.</span> <span class="toc-nav-text">Triangulation</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#sequential-structure-from-motion"><span class="toc-nav-number">2.5.3.1.</span> <span class="toc-nav-text">Sequential Structure from
Motion</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#l8"><span class="toc-nav-number">2.6.</span> <span class="toc-nav-text">L8</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E6%B7%B1%E5%BA%A6%E6%84%9F%E7%9F%A5"><span class="toc-nav-number">2.6.0.1.</span> <span class="toc-nav-text">深度感知</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#stereo-vision"><span class="toc-nav-number">2.6.0.2.</span> <span class="toc-nav-text">Stereo Vision</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#depth-from-disparity"><span class="toc-nav-number">2.6.0.3.</span> <span class="toc-nav-text">Depth from disparity</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#stereo-reconstruction-pipeline"><span class="toc-nav-number">2.6.0.4.</span> <span class="toc-nav-text">Stereo reconstruction
pipeline</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#multi-view-stereo"><span class="toc-nav-number">2.6.1.</span> <span class="toc-nav-text">Multi-view Stereo</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#plane-sweep"><span class="toc-nav-number">2.6.1.1.</span> <span class="toc-nav-text">Plane-Sweep</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#d-representations"><span class="toc-nav-number">2.6.2.</span> <span class="toc-nav-text">3D Representations</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E9%87%8D%E5%BB%BA%E6%96%B9%E6%B3%95"><span class="toc-nav-number">2.6.2.1.</span> <span class="toc-nav-text">重建方法</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#%E6%B3%8A%E6%9D%BE%E9%87%8D%E5%BB%BA"><span class="toc-nav-number">2.6.2.1.1.</span> <span class="toc-nav-text">泊松重建</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#marching-cubes"><span class="toc-nav-number">2.6.2.2.</span> <span class="toc-nav-text">Marching cubes</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#l9"><span class="toc-nav-number">2.7.</span> <span class="toc-nav-text">L9</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E7%BA%BF%E6%80%A7%E5%88%86%E7%B1%BB%E5%99%A8"><span class="toc-nav-number">2.7.1.</span> <span class="toc-nav-text">线性分类器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#loss-function"><span class="toc-nav-number">2.7.1.0.1.</span> <span class="toc-nav-text">Loss Function</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="toc-nav-number">2.7.2.</span> <span class="toc-nav-text">神经网络</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA"><span class="toc-nav-number">2.7.2.1.</span> <span class="toc-nav-text">多层感知机</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="toc-nav-number">2.7.3.</span> <span class="toc-nav-text">卷积神经网络</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E4%BA%8C%E7%BB%B4%E5%8D%B7%E7%A7%AF-1"><span class="toc-nav-number">2.7.3.1.</span> <span class="toc-nav-text">二维卷积</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#pooling"><span class="toc-nav-number">2.7.3.1.1.</span> <span class="toc-nav-text">Pooling</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="toc-nav-number">2.7.3.2.</span> <span class="toc-nav-text">为什么用卷积神经网络</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83"><span class="toc-nav-number">2.7.4.</span> <span class="toc-nav-text">神经网络的训练</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#data"><span class="toc-nav-number">2.7.5.</span> <span class="toc-nav-text">Data</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#data-augmentation"><span class="toc-nav-number">2.7.5.1.</span> <span class="toc-nav-text">Data augmentation</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E8%BF%87%E6%8B%9F%E5%90%88"><span class="toc-nav-number">2.7.6.</span> <span class="toc-nav-text">过拟合</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#l10"><span class="toc-nav-number">2.8.</span> <span class="toc-nav-text">L10</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2"><span class="toc-nav-number">2.8.1.</span> <span class="toc-nav-text">语义分割</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%85%A8%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="toc-nav-number">2.8.1.1.</span> <span class="toc-nav-text">全卷积神经网络</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#unpooling"><span class="toc-nav-number">2.8.1.2.</span> <span class="toc-nav-text">Unpooling</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#object-detection"><span class="toc-nav-number">2.8.2.</span> <span class="toc-nav-text">Object detection</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#detecting-a-single-object"><span class="toc-nav-number">2.8.2.1.</span> <span class="toc-nav-text">Detecting a single object</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#detecting-multiple-objects"><span class="toc-nav-number">2.8.2.2.</span> <span class="toc-nav-text">Detecting multiple objects</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#region-proposals"><span class="toc-nav-number">2.8.2.2.1.</span> <span class="toc-nav-text">Region proposals</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#r-cnn"><span class="toc-nav-number">2.8.2.3.</span> <span class="toc-nav-text">R-CNN</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87"><span class="toc-nav-number">2.8.2.4.</span> <span class="toc-nav-text">评价指标</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#fast-r-cnn"><span class="toc-nav-number">2.8.2.5.</span> <span class="toc-nav-text">Fast R-CNN</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#faster-r-cnn"><span class="toc-nav-number">2.8.2.6.</span> <span class="toc-nav-text">Faster R-CNN</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#l12"><span class="toc-nav-number">2.9.</span> <span class="toc-nav-text">L12</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#hdr"><span class="toc-nav-number">2.9.1.</span> <span class="toc-nav-text">HDR</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#dynamic-range"><span class="toc-nav-number">2.9.1.1.</span> <span class="toc-nav-text">Dynamic Range</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#image-formation-model"><span class="toc-nav-number">2.9.1.1.1.</span> <span class="toc-nav-text">Image Formation Model</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#tone-mapping%E5%A6%82%E4%BD%95%E5%B0%86hdr%E5%9B%BE%E5%83%8F12-bit%E5%9C%A88-bit%E7%9A%84sdr%E4%B8%8A%E6%98%BE%E7%A4%BA"><span class="toc-nav-number">2.9.1.1.2.</span> <span class="toc-nav-text">Tone
Mapping如何将HDR图像12-bit在8-bit的SDR上显示？</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#deblurring"><span class="toc-nav-number">2.9.2.</span> <span class="toc-nav-text">Deblurring</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E6%A8%A1%E7%B3%8A%E7%9A%84%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B"><span class="toc-nav-number">2.9.2.1.</span> <span class="toc-nav-text">模糊的数学模型</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#nbid"><span class="toc-nav-number">2.9.2.1.1.</span> <span class="toc-nav-text">NBID</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#bid"><span class="toc-nav-number">2.9.2.1.2.</span> <span class="toc-nav-text">BID</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#%E5%AF%B9%E4%BA%8Enbid%E5%8E%BB%E5%8D%B7%E7%A7%AF"><span class="toc-nav-number">2.9.2.1.3.</span> <span class="toc-nav-text">对于NBID去卷积</span></a></li></ol></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#l12-1"><span class="toc-nav-number">2.10.</span> <span class="toc-nav-text">L12</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#gan"><span class="toc-nav-number">2.10.1.</span> <span class="toc-nav-text">GAN</span></a></li></ol></li></ol></li></ol>
        
        </div>
      </aside>
    



      <!-- Sidebar Container -->
      <div class="
                col-lg-8 col-lg-offset-1
                col-md-10 col-md-offset-1
                sidebar-container">

        <!-- Featured Tags -->
        
        <section>
          <!-- no hr -->
          <h5>
            <a href="/tags/">特色标签</a>
          </h5>
          <div class="tags">
            
            <a class="tag" href="/tags/#浙江大学" title="浙江大学">浙江大学</a>
            
            <a class="tag" href="/tags/#CV计算机视觉" title="CV计算机视觉">CV计算机视觉</a>
            
          </div>
        </section>
        

        <!-- Friends Blog -->
        
        <hr>
        <h5>链友</h5>
        <ul class="list-inline">

          
        </ul>
        
      </div>
    </div>
  </div>
</article>



<!-- anchorjs start -->
<!-- async load function -->
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script type="text/javascript">
  // async load function
  function async (u, c) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) {
      o.addEventListener('load', function(e) {
        c(null, e);
      }, false);
    }
    s.parentNode.insertBefore(o, s);
  };
</script>
<script type="text/javascript">
  //anchor-js, Doc:http://bryanbraun.github.io/anchorjs/
  async ("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js", function() {
    anchors.options = {
      visible: 'hover',
      placement: 'left',
      // icon: 'ℬ'
      icon: '❡'
    };
    anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
  });
</script>
<style>
  /* place left on bigger screen */
  @media all and (min-width: 800px) {
    .anchorjs-link {
      position: absolute;
      left: -0.75em;
      font-size: 1.1em;
      margin-top: -0.1em;
    }
  }
</style>

<!-- anchorjs end -->



		<!-- Footer (contains ThemeColor、viewer) -->
		<!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center">
          

          
            <li>
              <a target="_blank" href="https://github.com/Hualeez">
                <span class="fa-stack fa-lg">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
          

          

          

          

          

          

          

        </ul>
        <p class="copyright text-muted">
          Copyright &copy;
          Hualingz
          2023
          <br>
          Theme by
          <a target="_blank" rel="noopener" href="http://beantech.org">BeanTech</a>
          <span style="display: inline-block; margin: 0 5px;">
            <i class="fa fa-heart"></i>
          </span>
          re-Ported by
          <a target="_blank" rel="noopener" href="https://v-vincen.life/">Live My Life</a>
          |
          <iframe style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0" width="91px" height="20px" src="https://ghbtns.com/github-btn.html?user=V-Vincen&repo=V-Vincen.github.io&type=star&count=true"></iframe>
        </p>
      </div>
    </div>
  </div>
</footer>

<a id="rocket" href="#top" class=""></a>


  <!-- jQuery -->
  <script type="text/javascript" src="/js/jquery.min.js"></script>
  <!-- Bootstrap Core JavaScript -->
  <script type="text/javascript" src="/js/bootstrap.min.js"></script>
  <!-- Custom Theme JavaScript -->
  <script type="text/javascript" src="/js/hux-blog.min.js"></script>
  <!-- catalog -->
  <script async="true" type="text/javascript" src="/js/catalog.js"></script>
  <!-- totop(rocket) -->
  <script async="true" type="text/javascript" src="/js/totop.js"></script>

  
    <!-- Busuanzi JavaScript -->
    <script async="async" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <!-- Scroll start -->
    <script async="async" type="text/javascript" src="/js/scroll.js"></script>
    <!-- Scroll end -->
  

  
    <!-- LangSelect start -->
    <script type="text/javascript" src="/js/langselect.js"></script>
    <!-- LangSelect end -->
  

  
    <!-- Mouseclick -->
    <script type="text/javascript" src="/js/mouseclick.js" content='The first step is as good as half over...,Laugh and grow fat...,Man proposes God disposes...,When all else is lost the future still remains...,Wasting time is robbing oneself...,Sharp tools make good work...,Cease to struggle and you cease to live...,A friend in need is a friend indeed...,Faith can move mountains...' color='#9933CC,#339933,#66CCCC,#FF99CC,#CCCCFF,#6666CC,#663399,#66CC99,#FF0033'></script>
  

  
    <!-- ribbon -->
    <script type="text/javascript" src="/js/ribbonDynamic.js"></script>
  

  






  <!-- viewer start -->
  <!-- viewer start (Picture preview) -->
  
    <script async="async" type="text/javascript" src="/js/viewer/viewer.min.js"></script>
    <script async="async" type="text/javascript" src="/js/viewer/pic-viewer.js"></script>
  

  <!-- viewer end -->


<script>
  // async load function
  function async (u, c) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) {
      o.addEventListener('load', function (e) {
        c(null, e);
      }, false);
    }
    s.parentNode.insertBefore(o, s);
  }

  // fastClick.js
  async ("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function () {
    var $nav = document.querySelector("nav");
    if ($nav)
      FastClick.attach($nav);
    }
  )
</script>

<!-- Because of the native support for backtick-style fenced code blocks right within the Markdown is landed in Github Pages, From V1.6, There is no need for Highlight.js, so Huxblog drops it officially. -
https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0 - https://help.github.com/articles/creating-and-highlighting-code-blocks/ -->
<!-- <script> async ("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function () { hljs.initHighlightingOnLoad(); }) </script> <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet"> -->

<!-- jquery.tagcloud.js -->
<!-- <script> // only load tagcloud.js in tag.html if ($('#tag_cloud').length !== 0) { async ("http://Hualingz.cn/js/jquery.tagcloud.js", function () { $.fn.tagcloud.defaults = { // size: { start: 1, end: 1, unit: 'em' }, color: {
start: '#bbbbee', end: '#0085a1' } }; $('#tag_cloud a').tagcloud(); }) } </script> -->


		<!-- Search -->
		
		<div class="popup search-popup local-search-popup">
  <span class="popup-btn-close">
    ESC
  </span>
  <div class="container">
    <div class="row">
      <!-- <div class="col-md-9 col-md-offset-1"> -->
      <div class="col-lg-9 col-lg-offset-1 col-md-10 col-md-offset-1 local-search-content">

        <div class="local-search-header clearfix">

          <div class="local-search-input-wrapper">
            <span class="search-icon">
              <i class="fa fa-search fa-lg" style="margin: 25px 10px 25px 20px;"></i>
            </span>
            <input autocomplete="off" placeholder="搜索..." type="text" id="local-search-input">
          </div>
        </div>
        <div id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>


  
    <script src="/js/ziploader.js"></script>
  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.json";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    // monitor main search box;
    var onPopupClose = function (e) {
      $('.popup').fadeOut(300);
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $('.popup').fadeIn(300);
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }
    // get search zip version
    $.get('/searchVersion.json?t=' + (+new Date()), function (res) {
      if (localStorage.getItem('searchVersion') !== res) {
        localStorage.setItem('searchVersion', res);
        initSearchJson();
      }
    });

    function initSearchJson() {
      initLoad(['/search.flv'], {
        loadOptions: {
          success: function (obj) {
            localStorage.setItem('searchJson', obj['search.json'])
          },
          error: function (e) {
            return console.log(e)
          }
        },
        returnOptions: {
          'json': TYPE_TEXT
        },
        mimeOptions: {
          'json': 'application/json'
        }
      })
    }
    // search function;
    var searchFunc = function (search_id, content_id) {
      'use strict';
      isfetched = true;
      var datas = JSON.parse(localStorage.getItem('searchJson'));
      // console.log(search_id)
      var input = document.getElementById(search_id);
      var resultContent = document.getElementById(content_id);
      var inputEventFunction = function () {
        var searchText = input.value.trim().toLowerCase();
        var keywords = searchText.split(/[\s\-]+/);
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        var resultItems = [];
        if (searchText.length > 0) {
          // perform local searching
          datas.forEach(function (data) {
            var isMatch = false;
            var hitCount = 0;
            var searchTextCount = 0;
            var title = data.title
              ? data.title.trim()
              : '';
            var titleInLowerCase = title.toLowerCase();
            var content = data.content
              ? data.content.trim().replace(/<[^>]+>/g, "")
              : '';
            var contentInLowerCase = content.toLowerCase();
            var articleUrl = decodeURIComponent(data.url);

            var date = data.date;
            var dateTime = date.replace(/T/, " ").replace(/.000Z/, "");
            var imgUrl = data.header_img;
            


            var indexOfTitle = [];
            var indexOfContent = [];
            // only match articles with not empty titles
            keywords.forEach(function (keyword) {
              function getIndexByWord(word, text, caseSensitive) {
                var wordLen = word.length;
                if (wordLen === 0) {
                  return [];
                }
                var startPosition = 0,
                  position = [],
                  index = [];
                if (!caseSensitive) {
                  text = text.toLowerCase();
                  word = word.toLowerCase();
                }
                while ((position = text.indexOf(word, startPosition)) > -1) {
                  index.push({position: position, word: word});
                  startPosition = position + wordLen;
                }
                return index;
              }
              indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
              indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
            });
            if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
              isMatch = true;
              hitCount = indexOfTitle.length + indexOfContent.length;
            }
            // show search results
            if (isMatch) {
              // sort index by position of keyword
              [indexOfTitle, indexOfContent].forEach(function (index) {
                index.sort(function (itemLeft, itemRight) {
                  if (itemRight.position !== itemLeft.position) {
                    return itemRight.position - itemLeft.position;
                  } else {
                    return itemLeft.word.length - itemRight.word.length;
                  }
                });
              });
              // merge hits into slices
              function mergeIntoSlice(text, start, end, index) {
                var item = index[index.length - 1];
                var position = item.position;
                var word = item.word;
                var hits = [];
                var searchTextCountInSlice = 0;
                while (position + word.length <= end && index.length != 0) {
                  if (word === searchText) {
                    searchTextCountInSlice++;
                  }
                  hits.push({position: position, length: word.length});
                  var wordEnd = position + word.length;
                  // move to next position of hit
                  index.pop();
                  while (index.length != 0) {
                    item = index[index.length - 1];
                    position = item.position;
                    word = item.word;
                    if (wordEnd > position) {
                      index.pop();
                    } else {
                      break;
                    }
                  }
                }
                searchTextCount += searchTextCountInSlice;
                return {hits: hits, start: start, end: end, searchTextCount: searchTextCountInSlice};
              }
              var slicesOfTitle = [];
              if (indexOfTitle.length != 0) {
                slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
              }
              var slicesOfContent = [];
              while (indexOfContent.length != 0) {
                var item = indexOfContent[indexOfContent.length - 1];
                var position = item.position;
                var word = item.word;
                // cut out 100 characters
                var start = position - 20;
                var end = position + 80;
                if (start < 0) {
                  start = 0;
                }
                if (end < position + word.length) {
                  end = position + word.length;
                }
                if (end > content.length) {
                  end = content.length;
                }
                slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
              }
              // sort slices in content by search text's count and hits' count
              slicesOfContent.sort(function (sliceLeft, sliceRight) {
                if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                  return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                  return sliceRight.hits.length - sliceLeft.hits.length;
                } else {
                  return sliceLeft.start - sliceRight.start;
                }
              });
              // select top N slices in content
              var upperBound = parseInt('1');
              if (upperBound >= 0) {
                slicesOfContent = slicesOfContent.slice(0, upperBound);
              }
              // highlight title and content
              function highlightKeyword(text, slice) {
                var result = '';
                var prevEnd = slice.start;
                slice.hits.forEach(function (hit) {
                  result += text.substring(prevEnd, hit.position);
                  var end = hit.position + hit.length;
                  result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                  prevEnd = end;
                });
                result += text.substring(prevEnd, slice.end);
                return result;
              }
              var resultItem = '';

              // if (slicesOfTitle.length != 0) {   resultItem += "<li><a target='_blank' href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>"; } else {   resultItem += "<li><a target='_blank' href='" +
              // articleUrl + "' class='search-result-title'>" + title + "</a>"; } slicesOfContent.forEach(function (slice) {   resultItem += "<a target='_blank' href='" + articleUrl + "'><p class=\"search-result\">" + highlightKeyword(content, slice) +
              // "...</p></a>"; }); resultItem += "</li>";

              if (slicesOfTitle.length != 0) {
                resultItem += "<a target='_blank' href='" + articleUrl + "' class='search-result'><div class='search-result-left'><div class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</div><time class='search-result-date'>" + dateTime + "</time>";
              } else {
                resultItem += "<a target='_blank' href='" + articleUrl + "' class='search-result'><div class='search-result-left'><div class='search-result-title'>" + title + "</div><time class='search-result-date'>" + dateTime + "</time>";
              }
              slicesOfContent.forEach(function (slice) {
                resultItem += "<p class=\"search-result-content\">" + highlightKeyword(content, slice) + "...</p>";
              });
              resultItem += "</div><div class='search-result-right'><img class='media-image' src='" + imgUrl + "' width='64px' height='48px'></img></div></a>";

              resultItems.push({item: resultItem, searchTextCount: searchTextCount, hitCount: hitCount, id: resultItems.length});
            }
          })
        };

        if (keywords.length === 1 && keywords[0] === "") {
          resultContent.innerHTML = '<div id="no-result"></div>'
        } else if (resultItems.length === 0) {
          resultContent.innerHTML = '<div id="no-result"></div>'
        } else {
          resultItems.sort(function (resultLeft, resultRight) {
            if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
              return resultRight.searchTextCount - resultLeft.searchTextCount;
            } else if (resultLeft.hitCount !== resultRight.hitCount) {
              return resultRight.hitCount - resultLeft.hitCount;
            } else {
              return resultRight.id - resultLeft.id;
            }
          });
          var searchResultList = '<div class=\"search-result-list\">';
          resultItems.forEach(function (result) {
            searchResultList += result.item;
          })
          searchResultList += "</div>";
          resultContent.innerHTML = searchResultList;
        }
      }
      if ('auto' === 'auto') {
        input.addEventListener('input', inputEventFunction);
      } else {
        $('.search-icon').click(inputEventFunction);
        input.addEventListener('keypress', function (event) {
          if (event.keyCode === 13) {
            inputEventFunction();
          }
        });
      }
      // remove loading animation
      $('body').css('overflow', '');
      proceedsearch();
    }
    // handle and trigger popup window;
    $('.popup-trigger').click(function (e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc('local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });
    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function (e) {
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 && $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });

    document.addEventListener('mouseup', (e) => {
      var _con = document.querySelector(".local-search-content");
      if (_con) {
        if (!_con.contains(e.target)) {
          onPopupClose();
        }
      }
    });
  </script>


		
	<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
