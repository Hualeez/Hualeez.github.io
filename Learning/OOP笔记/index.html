<!DOCTYPE html>
<html lang="en">

<!-- Head tag (contains Google-Analytics、Baidu-Tongji)-->
<head>
  <!-- Google Analytics -->
  
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-xxxxxx-xx"></script>
    <script type="text/javascript">
      window.dataLayer = window.dataLayer || [];

      function gtag() {
        dataLayer.push(arguments);
      }
      gtag('js', new Date());

      gtag('config', 'UA-xxxxxx-xx');
    </script>
  

  <!-- Baidu Tongji -->
  
    <script type="text/javascript">
      // Originial
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  <!-- Baidu Push -->
  
    <script>
      (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
      })();
    </script>
  

  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>

  <meta name="google-site-verification" content="lxDfCplOZbIzjhG34NuQBgu2gdyRlAtMB4utP5AgEBc"/>
  <meta name="baidu-site-verification" content="PpzM9WxOJU"/>

  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="description" content="这里是Hualingz，一个乐观主义者"/>
  <meta name="keyword" content="Hualingz,hualeez,hualingz,cyc"/>
  <link rel="shortcut icon" href="/img/avatar/fin_32.png"/>

  <!-- Place this tag in your head or just before your close body tag. -->
  <script async="async" defer="defer" src="https://buttons.github.io/buttons.js"></script>

  
    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css"/>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/beantech.min.css"/>

    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css"/>
    <link rel="stylesheet" href="/css/widget.css"/>
    <link rel="stylesheet" href="/css/rocket.css"/>
    <link rel="stylesheet" href="/css/signature.css"/>
    <link rel="stylesheet" href="/css/catalog.css"/>
    <link rel="stylesheet" href="/css/livemylife.css"/>

    
      <!-- wave start -->
      <link rel="stylesheet" href="/css/wave.css"/>
      <!-- wave end -->
    

    
      <!-- top start (article top hot config) -->
      <link rel="stylesheet" href="/css/top.css"/>
      <!-- top end -->
    

    
      <!-- ThemeColor start -->
      <link rel="stylesheet" href="/css/scroll.css"/>
      <!-- ThemeColor end -->
    

    
      <!-- viewer start (Picture preview) -->
      <link rel="stylesheet" href="/css/viewer.min.css"/>
      <!-- viewer end -->
    

    
      <!-- Search start -->
      <link rel="stylesheet" href="/css/search.css"/>
      <!-- Search end -->
    

    
      <!-- ThemeColor start -->
      <link rel="stylesheet" href="/css/themecolor.css"/>
      <!-- ThemeColor end -->
    

    

    
      <!-- gitalk start -->
      <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"> -->
      <link rel="stylesheet" href="/css/gitalk.css"/>
      <!-- gitalk end -->
    
  

  <!-- Custom Fonts -->
  <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
  <!-- Hux change font-awesome CDN to qiniu -->
  <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" type="text/css">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

  <!-- Hux Delete, sad but pending in China <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'> <link
  href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/ css'> -->

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]> <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script> <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script> <![endif]-->

  <!-- ga & ba script hoook -->
  <link rel="canonical" href="http://Hualingz.cn/Learning/OOP笔记/">
  <title>
    
      OOP笔记 - Hualingz_Channel
    
  </title>
<meta name="generator" content="Hexo 5.4.2"></head>


<!-- hack iOS CSS :active style -->

	<body ontouchstart="" class="body--light body--dark">


		<!-- ThemeColor -->
		
		<!-- ThemeColor -->
<style type="text/css">
  .body--light {
    --light-mode: none;
    --dark-mode: block;
  }
  .body--dark {
    --light-mode: block;
    --dark-mode: none;
  }
  i.mdui-icon.material-icons.light-mode {
    display: var(--light-mode);
  }
  i.mdui-icon.material-icons.dark-mode {
    display: var(--dark-mode);
  }
</style>
<div class="toggle" onclick="document.body.classList.toggle('body--dark')">
  <i class="mdui-icon material-icons light-mode"></i>
  <i class="mdui-icon material-icons dark-mode"></i>
</div>
<script>
  //getCookieValue
  function getCookieValue(a) {
    var b = document.cookie.match('(^|[^;]+)\\s*' + a + '\\s*=\\s*([^;]+)');
    return b
      ? b.pop()
      : '';
  }
  let themeMode = 'dark';
  if (getCookieValue('sb-color-mode') && (getCookieValue('sb-color-mode') !== themeMode)) {
    let dbody = document.body.classList;
    themeMode === 'dark' ? dbody.remove('body--dark') : dbody.add('body--dark');
  }

  //setCookieValue
  var toggleBtn = document.querySelector(".toggle");
  toggleBtn.addEventListener("click", function () {
    var e = document.body.classList.contains("body--dark");
    var cookieString = e
      ? "dark"
      : "light";
    var exp = new Date();
    exp.setTime(exp.getTime() + 3 * 24 * 60 * 60 * 1000); //3天过期
    document.cookie = "sb-color-mode=" + cookieString + ";expires=" + exp.toGMTString() + ";path=/";
  });
</script>

		

		<!-- Gitter -->
		
		<!-- Gitter -->
<!-- Docs:https://gitter.im/?utm_source=left-menu-logo -->
<script>
  ((window.gitter = {}).chat = {}).options = {
    room: 'your-community/your-room'
  };
</script>
<script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script>

		

		<!-- Navigation (contains search)-->
		<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header page-scroll">
      <button type="button" class="navbar-toggle">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">Hualingz_Channel</a>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <!-- Known Issue, found by Hux: <nav>'s height woule be hold on by its content. so, when navbar scale out, the <nav> will cover tags. also mask any touch event of tags, unfortunately. -->
    <div id="huxblog_navbar">
      <div class="navbar-collapse">
        <ul class="nav navbar-nav navbar-right">
          <li>
            <a href="/">首页</a>
          </li>

          
          
          
          
          <li>
            <a href="/about/">
              
              关于
              
              
            </a>
          </li>
          
          
          
          
          
          <li>
            <a href="/categories/">
              
              分类
              
              
            </a>
          </li>
          
          
          
          <li>
            <a href="/tags/">
              
              标签
              
              
            </a>
          </li>
          
          

          
          <li>
            <a class="popup-trigger">
              <span class="search-icon"></span>搜索</a>
          </li>
          

          <!-- LangSelect -->
          
          
          
          
          
        </ul>
      </div>
    </div>
    <!-- /.navbar-collapse -->
  </div>
  <!-- /.container -->
</nav>
<!-- progress -->
<div id="progress">
  <div class="line" style="width: 0%;"></div>
</div>

<script>
  // Drop Bootstarp low-performance Navbar Use customize navbar with high-quality material design animation in high-perf jank-free CSS3 implementation
  var $body = document.body;
  var $toggle = document.querySelector('.navbar-toggle');
  var $navbar = document.querySelector('#huxblog_navbar');
  var $collapse = document.querySelector('.navbar-collapse');

  $toggle.addEventListener('click', handleMagic)

  function handleMagic(e) {
    if ($navbar.className.indexOf('in') > 0) {
      // CLOSE
      $navbar.className = " ";
      // wait until animation end.
      setTimeout(function() {
        // prevent frequently toggle
        if ($navbar.className.indexOf('in') < 0) {
          $collapse.style.height = "0px"
        }
      }, 400)
    } else {
      // OPEN
      $collapse.style.height = "auto"
      $navbar.className += " in";
    }
  }
</script>


		<!-- Post Header (contains intro-header、signature、wordcount、busuanzi、waveoverlay) -->
		<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->

  <style type="text/css">
    .body--light {
      /* intro-header */
      --intro-header-background-image-url-home: url('/img/header_img/newhome_bg.jpg');
      --intro-header-background-image-url-post: url('');
      --intro-header-background-image-url-page: url('/img/header_img/archive_bg2.jpg');
    }
    .body--dark {
      --intro-header-background-image-url-home: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url('/img/header_img/newhome_bg.jpg');
      --intro-header-background-image-url-post: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url('');
      --intro-header-background-image-url-page: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url('/img/header_img/archive_bg2.jpg');
    }

    header.intro-header {
       /*post*/
        background-image: var(--intro-header-background-image-url-post);
        /* background-image: url(''); */
      
    }

    
      #signature {/*signature*/
        background-image: url('/img/signature/vincent-white.png');
      }
    
  </style>





<header class="intro-header">
  <!-- Signature -->
  <div id="signature">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
          
          <div class="post-heading">
            <div class="tags">
              
              <a class="tag" href="/tags/#浙江大学" title="浙江大学">浙江大学</a>
              
              <a class="tag" href="/tags/#OOP" title="OOP">OOP</a>
              
            </div>
            <h1>OOP笔记</h1>
            <h2 class="subheading">Hualingz</h2>
            <span class="meta">
              Posted by Hualingz on
              2022-06-26
            </span>


            
            <!-- WordCount start -->
            <div class="blank_box"></div>
            <span class="meta">
              Estimated Reading Time <span class="post-count">68</span> Minutes
            </span>
            <div class="blank_box"></div>
            <span class="meta">
              Words <span class="post-count">15.7k</span> In Total
            </span>
            <div class="blank_box"></div>
            <!-- WordCount end -->
            
            
            <!-- 不蒜子统计 start -->
            <span class="meta" id="busuanzi_container_page_pv">
              Viewed <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span> Times
            </span>
            <!-- 不蒜子统计 end -->
            


          </div>
          
        </div>
      </div>
    </div>
  </div>

  
  <!-- waveoverlay start -->
  <div class="preview-overlay">
    <svg class="preview-waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
      <defs>
        <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path>
      </defs>
      <g class="preview-parallax">
        <use xlink:href="#gentle-wave" x="48" y="0" fill=var(--gentle-wave1)></use>
        <use xlink:href="#gentle-wave" x="48" y="3" fill=var(--gentle-wave2)></use>
        <use xlink:href="#gentle-wave" x="48" y="5" fill=var(--gentle-wave3)></use>
        <use xlink:href="#gentle-wave" x="48" y="7" fill=var(--gentle-wave)></use>
      </g>
    </svg>
  </div>
  <!-- waveoverlay end -->
  

</header>



		<!-- Main Content (Post contains
	Pager、
	tip、
	socialshare、
	gitalk、gitment、disqus-comment、
	Catalog、
	Sidebar、
	Featured-Tags、
	Friends Blog、
	anchorjs、
	) -->
		<!-- Modify by Yu-Hsuan Yen -->
<!-- Post Content -->
<article>
  <div class="container">
    <div class="row">
      <!-- Post Container -->
      <div class="col-lg-8 col-lg-offset-1 col-md-10 col-md-offset-1 post-container">

        <h1 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h1><h2 id="WK1"><a href="#WK1" class="headerlink" title="WK1"></a>WK1</h2><h3 id="1-Buzzwords"><a href="#1-Buzzwords" class="headerlink" title="1. Buzzwords"></a>1. Buzzwords</h3><ul>
<li>responsibility-driven design 责任驱动设计，一个函数只做一个事情</li>
<li>encapsulation 封装</li>
<li>inheritance 继承</li>
<li>ploymorphic method calls 多态性</li>
<li>interface 接口</li>
<li>iterators 枚举</li>
<li>overriding 覆盖</li>
<li>coupling 耦合</li>
<li>cohesion 内聚</li>
<li>template 模板</li>
<li>collection classes 容器 </li>
<li>mutator methods 修改对象的方法<br>最上面三条是三大特性</li>
</ul>
<h3 id="2-Assessment"><a href="#2-Assessment" class="headerlink" title="2. Assessment"></a>2. Assessment</h3><ul>
<li>quiz-5</li>
<li>Assignment-10</li>
<li>7Labs-15</li>
<li>Project-15</li>
<li>Mid-Term Exam-5</li>
<li>Final Exam-50</li>
</ul>
<h3 id="3-Introduction-to-C"><a href="#3-Introduction-to-C" class="headerlink" title="3. Introduction to C++"></a>3. Introduction to C++</h3><ul>
<li>C++在C的基础上</li>
<li>C的知识帮助C++</li>
<li>C++支持更多种类的编程</li>
<li>C++提供了更多的特征</li>
</ul>
<h3 id="4-C-在C上的改进"><a href="#4-C-在C上的改进" class="headerlink" title="4. C++在C上的改进"></a>4. C++在C上的改进</h3><ul>
<li>Data Abstraction</li>
<li>References</li>
<li>Access control</li>
<li>Operator overloading</li>
<li>Initialization &amp; cleanup</li>
<li>More safe and powerful memory management</li>
<li>………………</li>
</ul>
<h3 id="5-C"><a href="#5-C" class="headerlink" title="5. C++"></a>5. C++</h3><ul>
<li>面向对象</li>
<li>面向过程</li>
</ul>
<h3 id="6-My-first-C-Program"><a href="#6-My-first-C-Program" class="headerlink" title="6. My first C++ Program"></a>6. My first C++ Program</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    cin &gt;&gt; age; </span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; age &lt;&lt;endl;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-String"><a href="#7-String" class="headerlink" title="7.  String"></a>7.  String</h3><ul>
<li><p>要添加头文件<string></string></p>
</li>
<li><p>定义变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化，赋值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运算</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = str + <span class="string">&quot;Mark&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>成员变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">len = name.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">string place = <span class="string">&quot;Hangzhou&quot;</span>;</span><br><span class="line">与下面一样的效果：</span><br><span class="line"><span class="function">string <span class="title">place</span><span class="params">(<span class="string">&quot;Hangzhou&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="WK2"><a href="#WK2" class="headerlink" title="WK2"></a>WK2</h2><h3 id="1-对象的指针"><a href="#1-对象的指针" class="headerlink" title="1. 对象的指针"></a>1. 对象的指针</h3><h4 id="1-1-基础的操作"><a href="#1-1-基础的操作" class="headerlink" title="1.1 基础的操作"></a>1.1 基础的操作</h4><ul>
<li>&amp; ：获得地址</li>
<li>*：获得指针所指向的对象</li>
<li>-&gt; : call the function</li>
</ul>
<h4 id="1-2-访问对象"><a href="#1-2-访问对象" class="headerlink" title="1.2 访问对象"></a>1.2 访问对象</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;<span class="comment">//不初始化时是空值</span></span><br><span class="line"><span class="built_in">string</span> *ps;<span class="comment">//不初始化时是不确定的！即指针指向的对象还不存在，仅仅是一个指针</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3-对象的赋值"><a href="#1-3-对象的赋值" class="headerlink" title="1.3 对象的赋值"></a>1.3 对象的赋值</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1,s2;</span><br><span class="line">s1=s2;</span><br><span class="line"><span class="built_in">string</span> *ps1,*ps2;</span><br><span class="line">ps1=ps2;</span><br></pre></td></tr></table></figure>

<ul>
<li>变量的赋值：把s2的值赋给s1</li>
<li>指针的赋值：把ps1变成ps2的地址</li>
</ul>
<h4 id="1-4-动态内存申请"><a href="#1-4-动态内存申请" class="headerlink" title="1.4 动态内存申请"></a>1.4 动态内存申请</h4><ul>
<li>new 运算符，与加减乘除的地位相同</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));<span class="comment">//两者效果一样，但是不能同时使用</span></span><br><span class="line"><span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*<span class="number">10</span>);<span class="comment">//两者效果一样，但是不能同时使用</span></span><br><span class="line"><span class="keyword">new</span> Stash;<span class="comment">//申请空间+初始化</span></span><br><span class="line">malloc<span class="comment">//申请空间，但是不会初始化</span></span><br></pre></td></tr></table></figure>

<p>   new：申请空间+初始化</p>
<p>   malloc：申请空间</p>
<ul>
<li>delete：收回空间前，调用析构函数清除掉这一块空间</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">delete</span> [] p;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>;<span class="comment">//4bytes</span></span><br><span class="line"><span class="type">int</span> *a = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];<span class="comment">//40bytes</span></span><br><span class="line">Student *q = <span class="keyword">new</span> <span class="built_in">Student</span>();<span class="comment">//16bytes</span></span><br><span class="line">Student *r = <span class="keyword">new</span> Student[<span class="number">10</span>];<span class="comment">//160bytes</span></span><br><span class="line"><span class="keyword">delete</span> p;<span class="comment">//4bytes被回收了</span></span><br><span class="line">a++;<span class="comment">//a指向了第二元素</span></span><br><span class="line"><span class="keyword">delete</span> [] a;</span><br><span class="line"><span class="keyword">delete</span> q;</span><br><span class="line"><span class="keyword">delete</span> r;</span><br><span class="line"><span class="keyword">delete</span> [] r;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不要用delete去释放没有申请的空间</p>
</li>
<li><p>不要用delete释放两次空间</p>
</li>
<li><p>用delete [ ]如果前面用了new [ ]</p>
</li>
<li><p>用delete 如果前面申请了空间</p>
</li>
<li><p>delete空指针是可以的</p>
</li>
</ul>
<h3 id="2-对象的引用"><a href="#2-对象的引用" class="headerlink" title="2. 对象的引用"></a>2. 对象的引用</h3><p>可以理解为给变量<strong>起别名</strong>，作用在引用上的<strong>所有</strong>操作事实上都是作用在该引用所绑定的对象上。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="type">char</span> *p = &amp;c;<span class="comment">//p是指针</span></span><br><span class="line"><span class="type">char</span> &amp; r = c;<span class="comment">//r是一个c的引用，相当于别名,相当于r的地址与x一样</span></span><br><span class="line"></span><br><span class="line">引用的规则：</span><br><span class="line">TypeName &amp; refname = name;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> &amp; y = x;</span><br><span class="line">y=k;</span><br><span class="line">cout&lt;&lt;x&lt;&lt;endl;<span class="comment">//输出k</span></span><br></pre></td></tr></table></figure>

<ul>
<li>不能是NULL，依赖于对象</li>
<li>不能用来代表新的变量</li>
<li>不能换绑，地址不能变了</li>
<li>不能用引用去引用引用</li>
<li>不能用指针指向引用，但是可以引用指针，即原变量的地址</li>
</ul>
<h3 id="3-对象与类"><a href="#3-对象与类" class="headerlink" title="3. 对象与类"></a>3. 对象与类</h3><h4 id="3-1-Point"><a href="#3-1-Point" class="headerlink" title="3.1 Point"></a>3.1 Point</h4><ul>
<li>在C中的结构定义</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">point</span>&#123;</span><br><span class="line">  <span class="type">float</span> x;</span><br><span class="line">  <span class="type">float</span> y;</span><br><span class="line">&#125;Point;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(Point* p,<span class="type">int</span> dx,<span class="type">int</span> dy)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> Point* p)</span></span>;</span><br><span class="line"></span><br><span class="line">Point a;</span><br><span class="line">a.x=<span class="number">1</span>;a.y=<span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> Point* p)</span></span>&#123;<span class="comment">//const 表示这个函数不会修改p的这个指针</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,p-&gt;x,p-&gt;y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(&amp;a);</span><br></pre></td></tr></table></figure>

<ul>
<li>C++中的类的定义</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> dx,<span class="type">int</span> dy)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">S::f</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ::<span class="built_in">f</span>();</span><br><span class="line">  ::a++;</span><br><span class="line">  a--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>resolver  “ : :”<br><class name>::<function name><br>  ::<function name><br>  表示右边这个函数是左边这个class的<br>  双冒号（::）用法</function></function></class></p>
<p>（1）表示“域操作符”<br>例：声明了一个类A，类A里声明了一个成员函数void f()，但没有在类的声明里给出f的定义，那么在类外定义f时，<br>就要写成void A::f()，表示这个f()函数是类A的成员函数。</p>
<p>（2）直接用在全局函数前，表示是全局函数<br>例：在VC里，你可以在调用API 函数里，在API函数名前加：：</p>
<p>（3）表示引用成员函数及变量，作用域成员运算符</p>
</li>
</ul>
<h3 id="4-对象"><a href="#4-对象" class="headerlink" title="4. 对象"></a>4. 对象</h3><h4 id="4-1-对象的定义"><a href="#4-1-对象的定义" class="headerlink" title="4.1 对象的定义"></a>4.1 对象的定义</h4><ul>
<li>Object &#x3D; Attributes属性 + Services服务</li>
<li>Data数据 ：the properties or status</li>
<li>Operations操作&#x2F;行为 ：the function</li>
</ul>
<h4 id="4-2-对象与结构"><a href="#4-2-对象与结构" class="headerlink" title="4.2 对象与结构"></a>4.2 对象与结构</h4><ul>
<li>结构在外面可以调用所有的东西</li>
<li>class在外面可以调用public，但是如果没有说明，默认全是private</li>
</ul>
<h4 id="4-3-this指针"><a href="#4-3-this指针" class="headerlink" title="4.3 this指针"></a>4.3 this指针</h4><p>指向结构体的指针</p>
<h2 id="WK3"><a href="#WK3" class="headerlink" title="WK3"></a>WK3</h2><h3 id="1-例子Ticket-Machine"><a href="#1-例子Ticket-Machine" class="headerlink" title="1. 例子Ticket Machine"></a>1. 例子Ticket Machine</h3><h4 id="1-1-Object-和Class的区别"><a href="#1-1-Object-和Class的区别" class="headerlink" title="1.1 Object 和Class的区别"></a>1.1 Object 和Class的区别</h4><ul>
<li>Object是Class的实例化</li>
<li>Class是一个类，类似于C中的type</li>
</ul>
<h4 id="1-2-OOP-Characteristics"><a href="#1-2-OOP-Characteristics" class="headerlink" title="1.2 OOP Characteristics"></a>1.2 OOP Characteristics</h4><ul>
<li>Everything is an object</li>
<li>A program is a bunch of objects telling each other <strong>what to do</strong> by <strong>sending messages</strong>.</li>
<li>Each object has its own memory made up of other objects.</li>
<li>Every object has a type.</li>
<li>All objects of a particular type can receive the same messages.</li>
</ul>
<h4 id="1-3-C’tor-and-D’tor"><a href="#1-3-C’tor-and-D’tor" class="headerlink" title="1.3 C’tor and D’tor"></a>1.3 C’tor and D’tor</h4> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> dx,<span class="type">int</span> dy)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>其中的init可以改为Point来初始化一个对象,这个叫<strong>构造函数</strong></li>
</ul>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Point</span>(<span class="type">int</span> x,<span class="type">int</span> y);</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> dx,<span class="type">int</span> dy)</span></span>;</span><br><span class="line">        ~ <span class="built_in">Point</span>();</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line">Point::<span class="built_in">Point</span>(<span class="type">int</span> x,<span class="type">int</span> y)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">    <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">&#125;</span><br><span class="line">Point::~<span class="built_in">Point</span>()&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;!&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Point <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span>,<span class="title">b</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">Point *p = <span class="keyword">new</span> <span class="built_in">Point</span>(<span class="number">5</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>默认的构造函数<br>是可以不用实参进行调用的构造函数</p>
<ol>
<li>没有带明显形参的构造函数</li>
<li>提供了默认实参的构造函数</li>
<li>若没有构造函数，则系统会构造默认的构造函数，但是这个函数不会做任何事情</li>
<li>合成默认构造函数总是不会初始化类的内置类型以及符合类型的数据成员</li>
<li>只有默认构造函数被编译器需要，系统才会合成</li>
</ol>
</li>
<li><p>析构函数<br>当对象结束生命周期会调用析构函数</p>
<ol>
<li><strong>构造函数可以有多个来构成重载，但是析构只能有一个</strong></li>
<li>构造函数可以有参数，析构函数不能有参数</li>
<li>没有显式写出析构函数，编译器会自动加上析构函数，但是这个析构函数什么也不会做</li>
<li>析构函数的执行在return之前，return表示结束</li>
<li>指针的析构只有在delete的时候触发，return也不会触发</li>
</ol>
</li>
<li><p>顺序:</p>
<ul>
<li><p>继承关系的构造析构顺序</p>
<ul>
<li>有类静态成员优先构造静态变量,按照定义的现后构造</li>
<li>先调用基类的构造函数<ul>
<li>先构造基类的成员变量</li>
<li>基类本身的构造函数</li>
</ul>
</li>
<li>派生类的构造<ul>
<li>先构造派生类的成员变量</li>
<li>派生类本身的构造函数</li>
</ul>
</li>
</ul>
</li>
<li><p>同一级别的构造函数</p>
<ol>
<li><p>类静态成员与声明的顺序无关，与继承关系也无关，根据定义的先后顺序初始化</p>
</li>
<li><p>类普通成员变量按照<strong>定义</strong>的顺序初始化，而不是构造函数里的list的顺序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> i=<span class="number">0</span>)&#123;</span><br><span class="line">        val=i;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~<span class="built_in">B</span>()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    B x;</span><br><span class="line">    B y;</span><br><span class="line">    <span class="comment">//这里的定义是先X后Y</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i=<span class="number">1</span>,<span class="type">int</span> j=<span class="number">2</span>):<span class="built_in">y</span>(<span class="number">2</span>),<span class="built_in">x</span>(<span class="number">1</span>)&#123;&#125;;<span class="comment">//这里的list是Y、X</span></span><br><span class="line">    ~<span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">A</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出为</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//即先初始化X再初始化Y</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>继承关系则是根据<strong>继承的先后</strong>顺序初始化</p>
</li>
<li><p>有虚函数的<strong>先初始化虚表指针</strong></p>
</li>
<li><p>执行<strong>初始化列表</strong></p>
</li>
<li><p>执行构造函数</p>
</li>
</ol>
</li>
<li><p><strong>析构的顺序是构造顺序的逆序</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="2-Class-类的定义"><a href="#2-Class-类的定义" class="headerlink" title="2. Class 类的定义"></a>2. Class 类的定义</h3><h4 id="2-1文件"><a href="#2-1文件" class="headerlink" title="2.1文件"></a>2.1文件</h4><ul>
<li>在C++中有分离的.h文件和.cpp文件<ul>
<li>Point.h（类定义）、Point.cpp（类函数）、main.cpp（主函数）</li>
<li>成员变量是private</li>
<li>很重要的原则</li>
</ul>
</li>
</ul>
<h2 id="WK4"><a href="#WK4" class="headerlink" title="WK4"></a>WK4</h2><h3 id="1-C-Program的structure"><a href="#1-C-Program的structure" class="headerlink" title="1. C++Program的structure"></a>1. C++Program的structure</h3><ul>
<li>declaration.h &#x2F;&#x2F;Header就是接口</li>
<li>declaration_funcs.cpp（#include声明头文件）</li>
<li>main.cpp</li>
</ul>
<h3 id="2-Standard-header-file-structure"><a href="#2-Standard-header-file-structure" class="headerlink" title="2. Standard header file structure"></a>2. Standard header file structure</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _POINT_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _POINT_H_</span></span><br><span class="line"><span class="comment">//Tpye declaration here</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>防止头文件重复添加</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _STUDENT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _STUDENT_H</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="2-1-tips"><a href="#2-1-tips" class="headerlink" title="2.1 tips"></a>2.1 tips</h4><ol>
<li>每个头文件有一个类声明</li>
<li>在文件名的相同前缀中与一个源文件关</li>
<li>头文件的内容用#ifndef #define #endif括起来</li>
</ol>
<ul>
<li><p>【讨论】两个文件互相包含的情况?</p>
</li>
<li><p>答：如果A.h和B.h要互相包含，那么在其中一个.h中去掉包含加入一个临时的class，在cpp的实际使用中再包含.h</p>
<p>A.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;B.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B* b;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">methodA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>A.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;A.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::methodA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b-&gt;<span class="built_in">methodB</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>B.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>; <span class="comment">// 重点，没有包含A.h,只是声明A为一个类型,与之前声明的A没有关系</span></span><br><span class="line">         <span class="comment">// 如果在此.h文件中使用A类型的任何属性方法都会报错</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A* a;<span class="comment">//使用的本文件声明的A类型</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">methodB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>B.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;B.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;A.h&quot;</span> <span class="comment">// 缺失这个包含会报错，此时才是给B.h中声明的A类定义</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B::methodB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a-&gt;<span class="built_in">methodA</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-Abstract"><a href="#3-Abstract" class="headerlink" title="3. Abstract"></a>3. Abstract</h3><p>抽象是一种忽略部分细节而将注意力集中在问题的更高层次上的能力。</p>
<p>模块化是将一个整体划分为定义良好的部分的过程，这些部分可以分别构建和检查，并以定义良好的方式进行交互。</p>
<h3 id="4-字段fields，参数parameters，本地变量local-variable"><a href="#4-字段fields，参数parameters，本地变量local-variable" class="headerlink" title="4. 字段fields，参数parameters，本地变量local variable"></a>4. 字段fields，参数parameters，本地变量local variable</h3><ul>
<li><p>所有三种类型的变量都能够存储适合于其定义类型的值。</p>
</li>
<li><p>字段定义在构造函数和方法之外。</p>
</li>
<li><p>字段用于存储贯穿对象生命周期的数据。因此，它们保持对象的当前状态。它们的生命周期与对象的生命周期相同。</p>
</li>
<li><p>字段具有类作用域:它们的可访问性扩展到整个类，因此可以在定义它们的类的任何构造函数或方法中使用它们。</p>
</li>
<li><p>只要字段被定义为private，就不能从定义类之外的任何地方访问它们。</p>
</li>
<li><p>形式参数和局部变量仅在构造函数或方法执行期间存在。它们的生存期只有单个调用的长度，因此它们的值会在调用之间丢失。因此，它们充当临时存储位置，而不是永久存储位置。</p>
</li>
<li><p>形参定义在构造函数或方法的头文件中。它们从外部接收值，由构成构造函数或方法调用一部分的实际参数值初始化。</p>
</li>
<li><p>形式参数的作用域仅限于其定义的构造函数或方法。</p>
</li>
<li><p>局部变量定义在构造函数或方法的函数体中。它们只能在其定义的构造函数或方法的主体内进行初始化和使用。</p>
</li>
<li><p>局部变量在表达式中使用之前必须初始化——它们没有默认值。</p>
</li>
<li><p>局部变量的作用域仅限于定义它们的块。在那个块以外的任何地方都无法进入。</p>
</li>
</ul>
<h3 id="5-Initialization和assignment"><a href="#5-Initialization和assignment" class="headerlink" title="5. Initialization和assignment"></a>5. Initialization和assignment</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Student</span>(string s,<span class="type">int</span> a):<span class="built_in">name</span>(s),<span class="built_in">age</span>(a)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Student</span>(string s,<span class="type">int</span> a)&#123;</span><br><span class="line">  name=s;</span><br><span class="line">  age=a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有何区别？</p>
<p>第一个是Initialization，在构造之前就附了初值</p>
<p>第二个是assignment，在构造函数内赋予初值</p>
<h4 id="5-1-函数重载"><a href="#5-1-函数重载" class="headerlink" title="5.1 函数重载"></a>5.1 函数重载</h4><p>在同一个作用域中可以存在多个函数名称相同但是<strong>形参列表不同</strong>的函数，这些我们成为重载函数。</p>
<ul>
<li><p>【注意】：<strong>函数的参数个数和类型都相同，只是返回值不同，这不是重载函数。</strong></p>
</li>
<li><p>【参数列表】：参数类型、参数个数、参数顺序，一个不同就是参数列表不同。</p>
</li>
<li><p>【特殊】：<strong>const关键字修饰函数</strong>可以区分重载函数，const关键字修饰参数时，要看传入的参数会不会被函数改变来决定能否区分重载</p>
</li>
<li><p>main函数不可重载</p>
</li>
<li><p>运算符重载</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> a,<span class="type">int</span> b):<span class="built_in">x</span>(a),<span class="built_in">y</span>(b)&#123;cout&lt;&lt;<span class="string">&quot;Ctor&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">Point</span>()&#123;cout&lt;&lt;<span class="string">&quot;Dtor&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    Point <span class="keyword">operator</span>+(Point a);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get_xy</span><span class="params">()</span></span>&#123;cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;y&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Point Point::<span class="keyword">operator</span>+(Point a)&#123;Point temp;temp.x=<span class="keyword">this</span>-&gt;x+a.x;temp.y=<span class="keyword">this</span>-&gt;y+a.y;<span class="keyword">return</span> temp;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Point <span class="title">b</span><span class="params">(<span class="number">4</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">    Point c = a+b;</span><br><span class="line">    c.<span class="built_in">get_xy</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="5-2-默认参数缺省"><a href="#5-2-默认参数缺省" class="headerlink" title="5.2 默认参数缺省"></a>5.2 默认参数缺省</h4><p>缺省参数的右边一定是缺省参数</p>
<img src="/Learning/OOP%E7%AC%94%E8%AE%B0/image-20220424122143515.png">

<h3 id="6-Container"><a href="#6-Container" class="headerlink" title="6.  Container"></a>6.  Container</h3><ul>
<li>STL &#x3D; Standard Template Library</li>
<li>容器在STL模板中</li>
<li>里面有一些<strong>数据结构Data Structure</strong>和<strong>算法Algorithm</strong>和<strong>迭代器Iterator</strong></li>
<li>有什么：<ul>
<li>vector：expandable array</li>
<li>deque：expandable array，expands at both ends</li>
<li>list：double linked</li>
<li>sets and maps</li>
<li>……</li>
</ul>
</li>
</ul>
<h2 id="WK5"><a href="#WK5" class="headerlink" title="WK5"></a>WK5</h2><h3 id="1-vector"><a href="#1-vector" class="headerlink" title="1. vector"></a>1. vector</h3><h4 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h4><ul>
<li>封装了<strong>动态大小的数组</strong>的顺序容器</li>
<li>能够存各种对象</li>
<li>可以简单地认为向量是一个能够放任意类型的动态数组</li>
</ul>
<h4 id="1-2-特性"><a href="#1-2-特性" class="headerlink" title="1.2 特性"></a>1.2 特性</h4><ul>
<li>顺序序列</li>
<li>动态数组</li>
<li>能够感知内存分配器</li>
</ul>
<h4 id="1-3-基本的函数"><a href="#1-3-基本的函数" class="headerlink" title="1.3 基本的函数"></a>1.3 基本的函数</h4><ol>
<li>构造函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;EleType&gt; c;</span><br><span class="line"><span class="function">vector&lt;EleType&gt; <span class="title">c1</span><span class="params">(c2)</span></span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>基本方法</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">V.<span class="built_in">size</span>():容器大小</span><br><span class="line">V.<span class="built_in">empty</span>():容器是否为空</span><br><span class="line">V.<span class="built_in">swap</span>(v2):将V和v2的全部内容交换</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>迭代器</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;EleType&gt;::iterator I;</span><br><span class="line">I.<span class="built_in">begin</span>():第一个位置</span><br><span class="line">I.<span class="built_in">end</span>():最后一个位置</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>元素访问</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">V.<span class="built_in">at</span>(index):访问index的数据</span><br><span class="line">V[index]:同上</span><br><span class="line">V.<span class="built_in">front</span>():第一个元素</span><br><span class="line">V.<span class="built_in">back</span>():最后一个元素</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>Add&#x2F;Remove&#x2F;Find</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">V.<span class="built_in">push_back</span>(ele):在最后插入ele<span class="comment">//调用构造函数</span></span><br><span class="line">V.<span class="built_in">pop_back</span>():在最后的删除</span><br><span class="line">V.<span class="built_in">insert</span>(pos,ele):在pos处插入ele</span><br><span class="line">V.<span class="built_in">erase</span>(pos):清除pos的元素</span><br><span class="line">V.<span class="built_in">clear</span>():清除全部</span><br><span class="line">V.<span class="built_in">find</span>(first,last,item)</span><br></pre></td></tr></table></figure>

<ul>
<li>【习题】下列创建vector容器对象的方法中，错误的是。</li>
<li>A.vector<int> v(10);</int></li>
<li>B.vector<int> v(10, 1);</int></li>
<li>C.vector<int> v{10, 1};</int></li>
<li>D.vector<int> v &#x3D; (10, 1);</int></li>
<li>答：D，A指的是创建大小为10的int类型的vector；B指的是创建大小为10的int类型的vector并且值全部为1；C指的是创建vector，里面内容有10，1，size为2.</li>
</ul>
<h3 id="2-list链表"><a href="#2-list链表" class="headerlink" title="2. list链表"></a>2. list链表</h3><h4 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h4><ul>
<li>相当于C的链表</li>
<li>Constructors</li>
<li>x.front( ) 和 x.back( <img src="/Learning/OOP%E7%AC%94%E8%AE%B0/image-20220325102200722.png"> alt&#x3D;”image-20220325102200722” style&#x3D;”zoom:50%;” &#x2F;&gt;</li>
</ul>
<h3 id="3-map"><a href="#3-map" class="headerlink" title="3. map"></a>3. map</h3><h4 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h4><ul>
<li>多个对,相当于python的字典</li>
<li>有key和value</li>
<li>查找使用key查找,找回一个value</li>
<li>example如电话本</li>
<li><strong>里面的二元组是按照key的顺序排列的。</strong></li>
</ul>
<h4 id="3-2-操作"><a href="#3-2-操作" class="headerlink" title="3.2 操作"></a>3.2 操作</h4><ul>
<li><p>构造</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;ktpye,vtype&gt; map_name; 可以构建两个type为一组的map</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加数据</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> Insert法</span><br><span class="line">    map_name.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;ktype,vtype&gt;(key,value));</span><br><span class="line"><span class="number">2.</span> 数组法<span class="comment">//用这个比较好</span></span><br><span class="line">    map_name[key]=value;</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 前向迭代器</span><br><span class="line">    map&lt;ktype,vtype&gt;::iterator it_name;</span><br><span class="line">  <span class="keyword">for</span>(it_name=map_name.<span class="built_in">begin</span>();it_name!=map_name.<span class="built_in">end</span>();it_name++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;key:&quot;</span>&lt;&lt;it_name-&gt;first&lt;&lt;<span class="string">&quot; value:&quot;</span>&lt;&lt;it_name-&gt;second&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">注意，这里的first和second分别对应了key和value</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span> 反向迭代器</span><br><span class="line">    map&lt;ktype,vtype&gt;::iterator it_name;</span><br><span class="line">  <span class="keyword">for</span>(it_name=map_name.<span class="built_in">rbegin</span>();it_name!=map_name.<span class="built_in">rend</span>();it_name++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;key:&quot;</span>&lt;&lt;it_name-&gt;first&lt;&lt;<span class="string">&quot; value:&quot;</span>&lt;&lt;it_name-&gt;second&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 数组形式</span><br><span class="line">  <span class="type">int</span> size = map_name.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=size;i++)&#123;</span><br><span class="line">        cout&lt;&lt;map_name[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map&lt;ktype,vtype&gt;::iterator it_name;</span><br><span class="line">it_name= map_name.<span class="built_in">find</span>(key);</span><br><span class="line">若返回为end则没找到</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iterator erase（iterator it) ;<span class="comment">//通过一个条目对象删除注意输入的是迭代器</span></span><br><span class="line">iterator erase（iterator first，iterator last）； <span class="comment">//删除一个范围</span></span><br><span class="line"><span class="function">size_type <span class="title">erase</span><span class="params">(<span class="type">const</span> Key&amp;key)</span></span>; <span class="comment">//通过关键字删除</span></span><br><span class="line"><span class="built_in">clear</span>()；<span class="comment">//就相当于enumMap.erase(enumMap.begin(),enumMap.end());</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>sort问题</p>
<p>Map 中的元素是自动按 key 升序排序,所以不能对 map 用 sort 函数。</p>
</li>
</ul>
<h4 id="Tips："><a href="#Tips：" class="headerlink" title="Tips："></a>Tips：</h4><p>嵌套使用时注意尖括号之间的空格，否则可能会被视作右移&gt;&gt;</p>
<h4 id="【迭代器】"><a href="#【迭代器】" class="headerlink" title="【迭代器】"></a>【迭代器】</h4><p>按照定义分为：正向、反向、常量正向、常量反向</p>
<p>按照功能分为：输入、输出、正向、双向、随机访问五种</p>
<h3 id="4-Function"><a href="#4-Function" class="headerlink" title="4. Function"></a>4. Function</h3><h4 id="4-1生存期和作用域"><a href="#4-1生存期和作用域" class="headerlink" title="4.1生存期和作用域"></a>4.1生存期和作用域</h4><ul>
<li>成员变量:作用域为类内部,生存期为跟随对象</li>
<li>全局变量:作用域为全部文件,生存期为长久的</li>
<li>局部变量:作用域为局部变量所在函数内,生存期为创建开始到函数调用完毕</li>
</ul>
<h4 id="4-2-生成函数"><a href="#4-2-生成函数" class="headerlink" title="4.2 生成函数"></a>4.2 生成函数</h4><ul>
<li>先进行初始化再进行生成函数,即private先赋值,但是会被生成函数覆盖。</li>
</ul>
<h4 id="4-3-重载overload"><a href="#4-3-重载overload" class="headerlink" title="4.3 重载overload"></a>4.3 重载overload</h4><ul>
<li>在同一个作用域内,可以生命几个功能类似的同名含糊,但是形式必须不同,如参数个数、类型或者、顺序</li>
<li>返回类型可以不同也可以相同</li>
<li>函数的重载仅仅是语法层面的,本质是不同的函数</li>
<li>重载的实现:C++代码在编译时会根据参数列表对函数进行重命名，例如void Swap(int a, int b)会被重命名为_Swap_int_int，void Swap(float x, float y)会被重命名为_Swap_float_float。当发生函数调用时，编译器会根据传入的实参去逐个匹配，以选择对应的函数，如果匹配失败，编译器就会报错，这叫做重载决议（Overload Resolution）。</li>
</ul>
<h4 id="4-4-默认函数default-argument"><a href="#4-4-默认函数default-argument" class="headerlink" title="4.4 默认函数default argument"></a>4.4 默认函数default argument</h4><ul>
<li>在函数里加一个默认值,调用时可以不写,会用这个默认值替代</li>
<li>要从右往左写</li>
<li>在声明里面可以写</li>
<li><strong>在定义里默认值是不能写的</strong></li>
</ul>
<h3 id="5-Friends"><a href="#5-Friends" class="headerlink" title="5. Friends"></a>5. Friends</h3><ul>
<li><strong>私有</strong>的成员可以授权给其他(朋友)使用</li>
<li><strong>声明friend要在本体类中声明</strong>,不能在类生成后再添加friend</li>
<li>子类的友元不能访问父类的保护成员。</li>
<li>基类的友元函数在派生类也是无效的，但这时可以将派生类转换成基类操作，是可以的。</li>
</ul>
<h3 id="6-class和struct的区别"><a href="#6-class和struct的区别" class="headerlink" title="6. class和struct的区别"></a>6. class和struct的区别</h3><ul>
<li>class默认为private的</li>
<li>struct是public的</li>
</ul>
<h4 id="7-Function的Way-in"><a href="#7-Function的Way-in" class="headerlink" title="7. Function的Way in"></a>7. Function的Way in</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Student i)</span></span>;</span><br><span class="line"><span class="comment">//在f里使用拷贝构造新的对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Student *p)</span></span>;</span><br><span class="line"><span class="comment">//传入指针，可以对p进行修改，如果不改可以用const更好</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Student&amp; i)</span></span>;</span><br><span class="line"><span class="comment">//传入引用，同上</span></span><br></pre></td></tr></table></figure>

<h4 id="8-Function的Way-out"><a href="#8-Function的Way-out" class="headerlink" title="8. Function的Way out"></a>8. Function的Way out</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Student <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//返回的是值，返回的值会从函数中复制出来用，当函数结束时，函数中的对应对象会被析构或结束，但复制出来使用的这一份仍然存在。</span></span><br><span class="line"><span class="function">Student* <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//函数如果返回的是引用，那么在函数调用时，引用的对象不会被复制，只是引用本身被复制了。使用这个引用的问题是，当函数结束时，引用的对象也同时被析构，因此引用会变成空引用。由于不会被复制，因此除非被赋予一个新的对象，否则如果被赋予的对象是引用或是指针，则会导致引用和指针直接连向将要被析构的函数内的对象，于是，当函数内的对象被析构时，引用就会为空，而指针则虽然找到了地址，但却因为对象的值被处理而出现失效的问题。</span></span><br><span class="line"><span class="function">Student&amp; <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//函数如果返回的是指针，那么在函数调用时，指针指向的对象不会被复制，只是指针本身被复制了一次，使用这个指针同样会有指向的对象被析构的危险，但如果将这个指针赋予了另一个指针，且指针指向的对象在堆中的话，则可以继续使用指针指向的堆中对象，因为这里对象的地址得到了继承。但如果是栈中的对象，则会出问题，因为栈中的对象会在函数结束时被自动析构。</span></span><br></pre></td></tr></table></figure>

<p>【错例】：这里函数中返回了一个局部变量的指针，这个局部变量在函数return时被释放，那么返回的A*就是错误的了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">A* <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A x =<span class="built_in">A</span>(<span class="number">1</span>); </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;in&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> &amp;x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">f</span>()-&gt;val&lt;&lt;endl;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="【tips】"><a href="#【tips】" class="headerlink" title="【tips】"></a>【tips】</h4><ol>
<li>Pass in an object if you want to store it </li>
<li>Pass in a const pointer or reference if you want to get the values </li>
<li>Pass in a pointer or reference if you want to do something to it </li>
<li>Pass out an object if you create it in the function </li>
<li>Pass out pointer or reference of the passed in only </li>
<li>Never new something and return the pointer</li>
</ol>
<h2 id="WK6"><a href="#WK6" class="headerlink" title="WK6"></a>WK6</h2><h3 id="1-内联函数Inline-Function"><a href="#1-内联函数Inline-Function" class="headerlink" title="1. 内联函数Inline Function"></a>1. 内联函数Inline Function</h3><ul>
<li>内联函数，要放在最前面</li>
<li>内联函数在编译时是将该函数的目标代码插入每个调用该函数的地方</li>
<li><strong>声明原型和定义函数时都要加inline声明</strong>，但其实并不会分开写</li>
<li>定义声明body要在调用之前，整个inline函数在头文件里或者只在一个文件里。</li>
<li><strong>在类里面写，不能把inline放在cpp里，他是一个声明，要放在.h头文件里面</strong></li>
<li>去掉了函数调用和返回的开销，但是增加了可执行程序的大小，<strong>用空间换时间</strong></li>
<li>比C语言的宏要好，宏是字符替换，inline仍是函数</li>
<li>编译器会觉得你的函数太复杂了会把inline变成普通函数，觉得你的普通函数太简单了会变成inline，<strong>这都是编译器决定的</strong></li>
</ul>
<h4 id="1-1-什么时候用Inline？"><a href="#1-1-什么时候用Inline？" class="headerlink" title="1.1 什么时候用Inline？"></a>1.1 什么时候用Inline？</h4><ul>
<li>small function</li>
<li>Frequently called functions</li>
</ul>
<h4 id="1-2-什么时候不用Inline？"><a href="#1-2-什么时候不用Inline？" class="headerlink" title="1.2 什么时候不用Inline？"></a>1.2 什么时候不用Inline？</h4><ul>
<li>Vary large function</li>
<li>Recursive function</li>
</ul>
<h4 id="1-3-A-lazy-way"><a href="#1-3-A-lazy-way" class="headerlink" title="1.3 A lazy way"></a>1.3 A lazy way</h4><ul>
<li>所有的都是inline</li>
<li>所有都不是inline</li>
</ul>
<h3 id="2-Const"><a href="#2-Const" class="headerlink" title="2. Const"></a>2. Const</h3><h4 id="2-1-定义："><a href="#2-1-定义：" class="headerlink" title="2.1 定义："></a>2.1 定义：</h4><ul>
<li>常数是一个变量<ul>
<li>一种不变的变量</li>
<li>有变量空间，编译器在运行时可以改，但是代码里不能改</li>
</ul>
</li>
<li>C++中默认为内部连接</li>
<li>可以使用const进行聚合，但会分配存储空间。 在这些情况下，const表示“不能更改的存储空间”。 但是，不能在编译时使用该值，因为编译器在编译时不需要知道存储的内容。</li>
</ul>
<h4 id="2-2-指针的const"><a href="#2-2-指针的const" class="headerlink" title="2.2 指针的const"></a>2.2 指针的const</h4><p>如何理解？到过来读，“ * ”读作“is a pointer to”。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> string *p = &amp;p1;<span class="comment">//p is a pointer to const string</span></span><br><span class="line">string <span class="type">const</span>* p = &amp;p1;<span class="comment">//与1等价</span></span><br><span class="line"><span class="comment">//p指向的字符串不能变，但p可以变</span></span><br><span class="line"></span><br><span class="line">string *<span class="type">const</span> p = &amp;p1;<span class="comment">//const p is a pointer to string</span></span><br><span class="line"><span class="comment">//p是一个常指针，但是string可以变</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-对象中的const"><a href="#2-3-对象中的const" class="headerlink" title="2.3 对象中的const"></a>2.3 对象中的const</h4><h5 id="2-3-1-成员函数的const"><a href="#2-3-1-成员函数的const" class="headerlink" title="2.3.1 成员函数的const"></a>2.3.1 成员函数的const</h5><ul>
<li><strong>const对象不可以引用非const成员阐述</strong>，可能调用const成员函数</li>
<li>非const对象可以调用一切成员函数</li>
<li>const的成员函数写法在<strong>后面加上</strong>const</li>
<li>const成员需要<strong>默认构造</strong>,或者说要<strong>保证有初始值</strong>！！！</li>
<li>const成员函数不可以改变非multable数据的值</li>
<li>非const对象可以调用const也可以调用非const成员函数</li>
<li>const是可以用来区分重载的！</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常用指针传入对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">area</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">      <span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">      <span class="built_in">area</span>()&#123;&#125;;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;g&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;f&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">          cout&lt;&lt;<span class="string">&quot;f const&quot;</span>&lt;&lt;endl;   </span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">const</span> area a;</span><br><span class="line">    a.<span class="built_in">f</span>();<span class="comment">//Error</span></span><br><span class="line">    a.<span class="built_in">g</span>();<span class="comment">//ok</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">const</span> area a;</span><br><span class="line">    area b;</span><br><span class="line">    a.<span class="built_in">f</span>();<span class="comment">//ok &quot;f const&quot;</span></span><br><span class="line">    b.<span class="built_in">f</span>();<span class="comment">//ok &quot;f&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-2-成员变量的const"><a href="#2-3-2-成员变量的const" class="headerlink" title="2.3.2 成员变量的const"></a>2.3.2 成员变量的const</h5><p>第一次要获得初始值，但是在运行时刻不能改变。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">public</span> :</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> k):<span class="built_in">i</span>(k)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-tips"><a href="#2-4-tips" class="headerlink" title="2.4 tips"></a>2.4 tips</h4><ul>
<li><strong>const的值必须初始化</strong></li>
<li>除非使用extern声明</li>
<li>使用了extern 声明</li>
</ul>
<h4 id="2-5-运行时的常数"><a href="#2-5-运行时的常数" class="headerlink" title="2.5 运行时的常数"></a>2.5 运行时的常数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> class_size = <span class="number">12</span>;</span><br><span class="line"><span class="type">int</span> finalGrade[class_size]; <span class="comment">// ok</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> size = x;</span><br><span class="line"><span class="type">double</span> classAverage[size]; <span class="comment">// error!会报错但是不影响运行？</span></span><br></pre></td></tr></table></figure>

<h4 id="2-6-const的聚合"><a href="#2-6-const的聚合" class="headerlink" title="2.6 const的聚合"></a>2.6 const的聚合</h4><p>可以聚合使用const，但是会视作开了一块内存，并且“内存不能被改变”，但是编译时不能使用这块内存中的值，因为编译器在编译时不知道这里的值。&#x2F;&#x2F;有的编译器支持</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> b[i[<span class="number">2</span>]];<span class="comment">//illegal</span></span><br><span class="line"><span class="type">int</span> c[<span class="number">3</span>];<span class="comment">//legal</span></span><br></pre></td></tr></table></figure>

<h4 id="2-7-Const-Object"><a href="#2-7-Const-Object" class="headerlink" title="2.7 Const Object"></a>2.7 Const Object</h4><p>不能改变const对象的属性值</p>
<p>因此使用const函数：不会改变对象的属性值的函数可以在声明和定义后加上const，以供const对象使用</p>
<p><strong>并且Const对象只能使用const函数</strong></p>
<h3 id="3-static"><a href="#3-static" class="headerlink" title="3. static"></a>3. static</h3><p>静态本地变量和静态全局变量不是同一个static</p>
<p>想让某一变量可以在下一次函数调用使用，则使用static关键字</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">f</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">9</span>;</span><br><span class="line">    cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">f</span>()&lt;&lt;endl;</span><br><span class="line">&#125;<span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">9</span></span><br><span class="line"><span class="comment">2*/</span></span><br></pre></td></tr></table></figure>

<p>控制变量的储存方式和可见性</p>
<ul>
<li><p>在修饰变量的时候，static修饰的静态本地变量只执行一次，延长了局部变量的生命周期，直到程序运行完后才释放</p>
</li>
<li><p><strong>构造函数的调用是在执行时才调用的，仅仅执行一次</strong></p>
</li>
<li><p>static修饰全局变量时，全局变量只能在本文件中使用，不能再其他文件中访问，多文件的初始化顺序是不能确定的</p>
</li>
<li><p>static修饰一个函数，则函数只能在本文件中使用，不能被其他文件调用</p>
</li>
<li><p>类的静态成员函数：</p>
<ul>
<li>静态成员函数是类的一个特殊的成员函数</li>
<li>静态成员函数属于整个类所有，<strong>没有this指针</strong></li>
<li>静态成员函数<strong>只能直接访问静态成员变量和静态成员函数</strong></li>
<li>可以通过<strong>类名</strong>直接访问类的公有静态成员函数<ul>
<li>&lt;class name&gt;::&lt;static member&gt;</li>
<li>&lt;object name&gt;.&lt;static member&gt;</li>
</ul>
</li>
<li>可以通过<strong>对象名</strong>访问类的公有静态成员函数</li>
<li>定义静态成员函数，<strong>直接使用static关键字修饰</strong>即可</li>
</ul>
</li>
<li><p>类的静态成员变量：</p>
<ul>
<li>访问受限于类内部</li>
<li><strong>静态成员变量要类外分配内存空间</strong></li>
<li>静态成员变量属于整个<strong>类所有</strong></li>
<li>静态成员变量的生命期不依赖于任何对象，为<strong>程序的生命周期</strong></li>
<li>可以通过<strong>类名</strong>直接访问公有静态成员变量<ul>
<li>&lt;class name&gt;::&lt;static member&gt;</li>
<li>&lt;object name&gt;.&lt;static member&gt;</li>
</ul>
</li>
<li>所有对象<strong>共享</strong>类的静态成员变量</li>
<li>可以通过<strong>对象名</strong>访问公有静态成员变量</li>
<li>静态成员变量在程序内部位于全局数据区 (Type className::VarName &#x3D; value)</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_value;   <span class="comment">//定义类的静态成员变量</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="comment">//定义类的静态成员函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> m_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> test::m_value = <span class="number">12</span>;   <span class="comment">//类的静态成员变量需要在类外分配内存空间</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test t;</span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; t.<span class="built_in">getValue</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>静态成员变量需要在cpp文件里定义全局变量，不能加static</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//my.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StatMem</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="type">int</span> m_b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//my.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;StatMem.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> StatMem::m_b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a&lt;b)?b:a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;my.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> y=<span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> z=<span class="built_in">max</span>(x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/cpp-static-usage.html">https://www.runoob.com/w3cnote/cpp-static-usage.html</a></p>
</li>
</ul>
<h2 id="WK7"><a href="#WK7" class="headerlink" title="WK7"></a>WK7</h2><h3 id="1-1-namespace"><a href="#1-1-namespace" class="headerlink" title="1.1 namespace"></a>1.1 namespace</h3><ul>
<li>namespace的产生</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//old1.h</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//old2.h</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>为了防止混淆，放入命名空间，一个f属于old1的namespace，一个f属于old2的namespace。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Math&#123;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">abs</span><span class="params">(<span class="type">double</span> )</span></span>;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">sqrt</span><span class="params">(<span class="type">double</span> )</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>定义namespace要放在头文件，<strong>在namespace里面，变量是定义</strong>，不是声明，<strong>函数是声明</strong>，不是定义。</p>
</li>
<li><p>直接使用函数的名字可以多个一起用，如：</p>
</li>
<li><pre><code class="cpp">//MyLib.cpp文件
#include&lt;iostream&gt;
#include&quot;MyLib.h&quot;//包含名字空间生命所在的文件
using std::cout;//这是使用生命，不是使用指令
using std::endl;
int MyLib::i=10;//这是变量i的定义，并且初始化，当然也可以不用初始化直接写int MyLib::i;
void MyLib::fun()&#123;
   cout&lt;&lt;i&lt;&lt;endl;
&#125;
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 当使用多个namspace时，要确保缺省后的函数不会重复，否则需要使用名字空间</span><br><span class="line"></span><br><span class="line">- ```cpp</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> name1;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> name2;</span><br><span class="line">  </span><br><span class="line">  name1::<span class="built_in">test</span>(); <span class="comment">// 不同命名空间中的相同的函数名，通过前面的命名空间来区分。</span></span><br><span class="line">  name2::<span class="built_in">test</span>();</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>可以使用conbine将多个namespace合起来</p>
</li>
<li><p>&#96;&#96;&#96;cpp<br>namespace mine {<br>using namespace first;<br>using namespace second;<br>using first::y(); &#x2F;&#x2F; resolve clashes to first::x()<br>void mystuff();  …}</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### <span class="number">2.</span> 继承</span><br><span class="line"></span><br><span class="line">#### <span class="number">2.1</span> 重用</span><br><span class="line"></span><br><span class="line">&lt;img src = <span class="string">&quot;OOP笔记\image-20220408101603737.png&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">- 继承是一种重要的设计方法，在类与类之间**共享设计**，而非数据</span><br><span class="line">- 继承后的类往往比被继承的类有更多的属性</span><br><span class="line">- &lt;img src = <span class="string">&quot;OOP笔记\image-20220408101816418.png&quot;</span>&gt;</span><br><span class="line">- **继承可以表达为 A is B**，student is a person</span><br><span class="line"></span><br><span class="line">&lt;img src = <span class="string">&quot;OOP笔记\image-20220408104701455.png&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">- 继承可以消除代码的复制，易于维护，有拓展性，拿已有类表示新类，新类除了已有类的特征还有自己的特征</span><br><span class="line"></span><br><span class="line">#### <span class="number">2.2</span> Example </span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line">public:    </span><br><span class="line">  <span class="constructor">Employee( <span class="params">const</span> <span class="params">std</span>::<span class="params">string</span>&amp; <span class="params">name</span>,<span class="params">const</span> <span class="params">std</span>::<span class="params">string</span>&amp; <span class="params">ssn</span> )</span>;    </span><br><span class="line">  const std::<span class="built_in">string</span>&amp; get<span class="constructor">_name()</span> const;</span><br><span class="line">    void print(std::ostream&amp; out) const;</span><br><span class="line">    void print(std::ostream&amp; out, const std::<span class="built_in">string</span>&amp; msg) const; </span><br><span class="line">protected:</span><br><span class="line">  std::<span class="built_in">string</span> m_name;</span><br><span class="line">  std::<span class="built_in">string</span> m_ssn; &#125;;</span><br><span class="line"></span><br><span class="line">Employee::<span class="constructor">Employee( <span class="params">const</span> <span class="params">string</span>&amp; <span class="params">name</span>,<span class="params">const</span> <span class="params">string</span>&amp; <span class="params">ssn</span> )</span>   </span><br><span class="line">    : m<span class="constructor">_name(<span class="params">name</span>)</span>, m<span class="constructor">_ssn( <span class="params">ssn</span>)</span>  </span><br><span class="line">&#123;     </span><br><span class="line">    <span class="comment">// initializer list sets up the values! </span></span><br><span class="line">&#125;</span><br><span class="line">inline const std::<span class="built_in">string</span>&amp; Employee::get<span class="constructor">_name()</span> const &#123;    </span><br><span class="line">    return m_name;</span><br><span class="line">&#125; </span><br><span class="line">inline void Employee::print( std::ostream&amp; out )const &#123;    </span><br><span class="line">    out &lt;&lt; m_name &lt;&lt; endl;     </span><br><span class="line">    out &lt;&lt; m_ssn &lt;&lt; endl;  </span><br><span class="line">&#125; </span><br><span class="line">inline void Employee::print(std::ostream&amp; out, const std::<span class="built_in">string</span>&amp; msg) const </span><br><span class="line">&#123;    </span><br><span class="line">    out &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">    print(out); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///now add Manager！</span></span><br><span class="line"><span class="keyword">class</span> Manager : public Employee &#123;  </span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">Manager(<span class="params">const</span> <span class="params">std</span>::<span class="params">string</span>&amp; <span class="params">name</span>,<span class="params">const</span> <span class="params">std</span>::<span class="params">string</span>&amp; <span class="params">ssn</span>,<span class="params">const</span> <span class="params">std</span>::<span class="params">string</span>&amp; <span class="params">title</span>)</span>;</span><br><span class="line">    const std::<span class="built_in">string</span> title<span class="constructor">_name()</span> const;</span><br><span class="line">    const std::<span class="built_in">string</span>&amp; get<span class="constructor">_title()</span> const;</span><br><span class="line">    void print(std::ostream&amp; out) const; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="built_in">string</span> m_title; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-3-构造函数的继承"><a href="#2-3-构造函数的继承" class="headerlink" title="2.3 构造函数的继承"></a>2.3 构造函数的继承</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> :</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;a=<span class="number">10</span>;cout&lt;&lt;<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="number">2</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>()&#123;i=<span class="number">9</span>;cout&lt;&lt;<span class="number">3</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b=<span class="built_in">B</span>(); </span><br><span class="line">    b.<span class="built_in">f</span>();    </span><br><span class="line">    cout&lt;&lt;b.a;   </span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1329</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>先进行父类的构造，再进行子类的构造</strong>，<strong>同名的属性会覆盖</strong></li>
<li>在子类中如果有对象，则<strong>先进行基类的构造</strong>，再进行对象的构造</li>
<li>子类的对象由两部分组成：父类和子类的特有</li>
</ul>
<h4 id="2-4-public，private，protected继承"><a href="#2-4-public，private，protected继承" class="headerlink" title="2.4 public，private，protected继承"></a>2.4 public，private，protected继承</h4><table>
<thead>
<tr>
<th align="left">继承方式</th>
<th align="left">基类public</th>
<th align="left">基类protected</th>
<th align="left">基类private</th>
</tr>
</thead>
<tbody><tr>
<td align="left">public继承</td>
<td align="left">public</td>
<td align="left">protected</td>
<td align="left">不可访问</td>
</tr>
<tr>
<td align="left">protected继承</td>
<td align="left">protected</td>
<td align="left">protected</td>
<td align="left">不可访问</td>
</tr>
<tr>
<td align="left">private继承</td>
<td align="left">private</td>
<td align="left">private</td>
<td align="left">不可访问</td>
</tr>
</tbody></table>
<h2 id="WK8"><a href="#WK8" class="headerlink" title="WK8"></a>WK8</h2><h3 id="1-多态"><a href="#1-多态" class="headerlink" title="1. 多态"></a>1. 多态</h3><ul>
<li><strong>如果B继承自A，那么在使用A的地方都可以使用B</strong>，因为B继承自A</li>
<li>替换无效请小心</li>
<li>在继承时可能会有多态的情况，即一个父类变成了各式的子类，查看这个例子</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="type">int</span> width, height;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Shape</span>( <span class="type">int</span> a=<span class="number">0</span>, <span class="type">int</span> b=<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         width = a;</span><br><span class="line">         height = b;</span><br><span class="line">      &#125;</span><br><span class="line">      [[-<span class="keyword">virtual</span>-]]<span class="function"><span class="type">int</span> <span class="title">area</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Parent class area :&quot;</span> &lt;&lt;endl;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Rectangle</span>( <span class="type">int</span> a=<span class="number">0</span>, <span class="type">int</span> b=<span class="number">0</span>):<span class="built_in">Shape</span>(a, b) &#123; &#125;</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">area</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Rectangle class area :&quot;</span> &lt;&lt;endl;</span><br><span class="line">         <span class="keyword">return</span> (width * height); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span>: <span class="keyword">public</span> Shape&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Triangle</span>( <span class="type">int</span> a=<span class="number">0</span>, <span class="type">int</span> b=<span class="number">0</span>):<span class="built_in">Shape</span>(a, b) &#123; &#125;</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">area</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Triangle class area :&quot;</span> &lt;&lt;endl;</span><br><span class="line">         <span class="keyword">return</span> (width * height / <span class="number">2</span>); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Shape *shape;</span><br><span class="line">   <span class="function">Rectangle <span class="title">rec</span><span class="params">(<span class="number">10</span>,<span class="number">7</span>)</span></span>;</span><br><span class="line">   <span class="function">Triangle  <span class="title">tri</span><span class="params">(<span class="number">10</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">   <span class="comment">// 存储矩形的地址</span></span><br><span class="line">   shape = &amp;rec;</span><br><span class="line">   <span class="comment">// 调用矩形的求面积函数 area</span></span><br><span class="line">   shape-&gt;<span class="built_in">area</span>();</span><br><span class="line">   <span class="comment">// 存储三角形的地址</span></span><br><span class="line">   shape = &amp;tri;</span><br><span class="line">   <span class="comment">// 调用三角形的求面积函数 area</span></span><br><span class="line">   shape-&gt;<span class="built_in">area</span>();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中输出为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Parent <span class="keyword">class</span> <span class="title class_">area</span> :</span><br><span class="line">Parent <span class="keyword">class</span> <span class="title class_">area</span> :</span><br></pre></td></tr></table></figure>

<p>因为调用函数area()时被编译器设置为基类的版本，即<strong>静态绑定</strong>，函数调用在程序执行前就准备好了，就是说area( )函数在程序编译期间就设置好了。但是我们想要的是不同的子类的area函数不同，那么我们要在基类里使用<strong>virtual关键字</strong></p>
<h4 id="1-1-Up-casting"><a href="#1-1-Up-casting" class="headerlink" title="1.1 Up-casting"></a>1.1 Up-casting</h4><p>一个继承类有一个基类，继承类由基类的一切属性，也是基类的一员！</p>
<p>It is to say: Students are human beings. You are students.  So you are human being</p>
<h4 id="1-2-virtual-关键字"><a href="#1-2-virtual-关键字" class="headerlink" title="1.2 virtual 关键字"></a>1.2 virtual 关键字</h4><p>父类有一个virtual关键字的函数则，说明子类也会有这个同名函数要进行覆盖.</p>
<p>此时，编译器看的是指针的内容，而不是它的类型。因此，由于 tri 和 rec 类的对象的地址存储在 *shape 中，所以会调用各自的 area() 函数。</p>
<p>正如您所看到的，每个子类都有一个函数 area() 的独立实现。这就是<strong>多态</strong>的一般使用方式。有了多态，您可以有多个不同的类，都带有同一个名称但具有不同实现的函数，函数的参数甚至可以是相同的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>()&#123;i=<span class="number">10</span>;cout&lt;&lt;<span class="string">&quot;A()&quot;</span>&lt;&lt;i&lt;&lt;endl;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;A::f&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span>()&#123;i=<span class="number">20</span>;cout&lt;&lt;<span class="string">&quot;B()&quot;</span>&lt;&lt;i&lt;&lt;endl;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;B::f&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>虚函数：被virtual关键字修饰的成员函数，就是虚函数（实现多态）<ul>
<li>限制：<ul>
<li>非类的成员函数不能定义为虚函数，类的成员函数中<strong>静态成员函数和构造函数</strong>也<strong>不能</strong>定义为虚函数，但<strong>可以</strong>将<strong>析构函数</strong>定义为虚函数。一般我们把析构函数写成虚函数。</li>
<li>只需要在声明函数的类体中使用关键字“virtual”将函数声明为虚函数，而定义函数时不需要使用关键字“virtual”。</li>
<li>当将基类中的某一成员函数声明为虚函数后，派生类中的同名函数（函数名相同、参数列表完全一致、返回值类型相关）自动成为虚函数。</li>
<li>如果声明了某个成员函数为虚函数，则在该类中不能出现和这个成员函数同名并且返回值、参数个数、类型都相同的非虚函数。在以该类为基类的派生类中，也不能出现这种同名函数。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1-3-A-drawing-program"><a href="#1-3-A-drawing-program" class="headerlink" title="1.3 A drawing program"></a>1.3 A drawing program</h4><ul>
<li><p>Rectangle、circle、Ellipse</p>
</li>
<li><p>操作：</p>
<ul>
<li>渲染</li>
<li>移动</li>
<li>调整</li>
</ul>
</li>
<li><p>数据：</p>
<ul>
<li>中心</li>
</ul>
</li>
<li><p>子父类的选择：</p>
<p>shape→Ellipse→circle</p>
<p>圆是特殊的椭圆</p>
<img src="/Learning/OOP%E7%AC%94%E8%AE%B0/image-20220415104804288.png">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">XYPos</span>&#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Shape</span>();</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>();</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">render</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">const</span> XYPos&amp;)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">resize</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  XYPos center;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ellipse</span>:<span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Ellipse</span>(<span class="type">float</span> maj,<span class="type">float</span> minr);</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">render</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">float</span> major_axis,minor_axis;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Ellipse &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Circle</span>(<span class="type">float</span> radius) :        </span><br><span class="line">  <span class="built_in">Ellipse</span>(radius, radius)&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">render</span><span class="params">()</span></span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="1-4-邦定binding"><a href="#1-4-邦定binding" class="headerlink" title="1.4 邦定binding"></a>1.4 邦定binding</h4><p>绑定(Binding)是指将<strong>变量</strong>和<strong>函数名</strong>转换为地址的过程。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/192178632">https://zhuanlan.zhihu.com/p/192178632</a></p>
<ol>
<li>静态类型：对象在声明时采用的类型，在编译期既已确定；</li>
<li>动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；</li>
<li>静态绑定：绑定的是静态类型，所对应的函数或属性依赖于<strong>对象的静态类型</strong>，发生在<strong>编译</strong>期；</li>
<li>动态绑定：绑定的是动态类型，所对应的函数或属性依赖于<strong>对象的动态类型</strong>，发生在<strong>运行</strong>期；</li>
</ol>
<ul>
<li><p>静态绑定：</p>
<p>call the function as the code</p>
</li>
<li><p>动态绑定</p>
<p>call the function of the object</p>
</li>
</ul>
<p>从上面的定义也可以看出，<strong>非虚函数一般都是静态绑定</strong>，而<strong>虚函数都是动态绑定</strong>（如此才可实现多态性）。</p>
<p><strong>在构造函数中调用虚函数，不是动态联编。</strong></p>
<h4 id="1-5-Virtual-destructors-虚的析构函数"><a href="#1-5-Virtual-destructors-虚的析构函数" class="headerlink" title="1.5 Virtual destructors 虚的析构函数"></a>1.5 Virtual destructors 虚的析构函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Shape *p = <span class="keyword">new</span> <span class="built_in">Ellipse</span>(<span class="number">100.0F</span>,<span class="number">200.0F</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="comment">//调用析构，编译器只能看见静态类型，即Shape，如果shape的析构不是virtual的，那直接析构shape，但是其实这里的p是Ellipse的，因此使用virtual，让编译器调用动态绑定Ellipse的析构</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>除非一个类以后无法被继承，否则这个类的析构要是virtual的</strong></li>
</ul>
<h4 id="1-6-Overriding"><a href="#1-6-Overriding" class="headerlink" title="1.6 Overriding"></a>1.6 Overriding</h4><ul>
<li><strong>override保留字表示当前函数重写了基类的虚函数</strong>。</li>
<li><strong>名称相同，参数表相同</strong>，<strong>父类是virtual，子类无所谓，最好加上，因为子类可能还要被继承</strong></li>
<li>返回类型也要求相同，但是这个相同可以是继承关系</li>
<li>只有<strong>虚函数</strong>能够重载（参数列表、函数名称、const）</li>
</ul>
<h4 id="1-7-Virtual-in-Ctor"><a href="#1-7-Virtual-in-Ctor" class="headerlink" title="1.7 Virtual in Ctor"></a>1.7 Virtual in Ctor</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:  <span class="built_in">A</span>() &#123; <span class="built_in">f</span>(); &#125;  </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; “A::<span class="built_in">f</span>()”; &#125;  </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123; </span><br><span class="line"><span class="keyword">public</span>:  <span class="built_in">B</span>() &#123; <span class="built_in">f</span>(); &#125;  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; “B::<span class="built_in">f</span>()”; &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B x=<span class="built_in">B</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//A::f()B::f()</span></span><br></pre></td></tr></table></figure>

<p>说明函数声明在构造之前。</p>
<h4 id="1-8-Abstract-base-classes-抽象类"><a href="#1-8-Abstract-base-classes-抽象类" class="headerlink" title="1.8 Abstract base classes 抽象类"></a>1.8 Abstract base classes 抽象类</h4><p><strong>一个有纯虚函数的类是抽象类</strong></p>
<ul>
<li><p><strong>抽象类不能制造出对象</strong>（不能被实例化）</p>
</li>
<li><p>但是可以有指针，只是没有实例化</p>
</li>
<li><p><strong>纯虚函数是把一个函数&#x3D;0</strong></p>
</li>
<li><p>只定义了接口，没有function body</p>
<img src="/Learning/OOP%E7%AC%94%E8%AE%B0/image-20220422104422233.png">
</li>
<li><p>为什么用抽象类</p>
<ul>
<li>建模</li>
<li>强制正确行为</li>
<li>定义了接口没有定义实现</li>
</ul>
</li>
<li><p>什么时候用</p>
<ul>
<li>没有足够的信息</li>
<li>设计接口继承等</li>
</ul>
</li>
</ul>
<h4 id="1-9-接口类Protocol-x2F-Interface-classes"><a href="#1-9-接口类Protocol-x2F-Interface-classes" class="headerlink" title="1.9 接口类Protocol &#x2F; Interface classes"></a>1.9 接口类Protocol &#x2F; Interface classes</h4><p>接口类：</p>
<p>只提供接口不提供实现的类，接口类和抽象类对C++而言没有区别。</p>
<ol>
<li><strong>子类实现接口类</strong>中的所有接口</li>
<li>接口方法前有virtual修饰且等于0，<strong>全是纯虚函数</strong></li>
<li>只能被继承不能生成对象</li>
</ol>
<p>与抽象类的区别</p>
<ol>
<li>接口里<strong>只能包含抽象方法，静态方法和默认方法（加default）</strong>，<strong>不能为普通方法提供方法实现</strong>，抽象类则完全可以包含<strong>普通方法，接口中的普通方法默认为抽象方法。</strong></li>
<li>接口不能包含构造器，抽象类可以包含<strong>构造器</strong>，抽象类里的构造器并不是用于创建对象，而是<strong>让其子类调用这些构造器</strong>来<strong>完成</strong>属于<strong>抽象类的初始化操作</strong>。</li>
<li>不能包含初始化块接口里不能包含初始化块，但抽象类里完全可以包含<strong>初始化块</strong>。</li>
<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseInterface</span>&#123;</span><br><span class="line">    <span class="comment">//是动物都要吃东西，睡觉以及爱好</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Eat</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Sleep</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Hobby</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">BaseInterface</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> : <span class="keyword">public</span> BaseInterface</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>();</span><br><span class="line"><span class="comment">//继承动物接口后一定要实现接口类中的接口</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Eat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Sleep</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Hobby</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//但是人类作为动物有自己的行为和爱好</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QString personName;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetName</span><span class="params">(QString pName)</span></span>;</span><br><span class="line">    <span class="function">QString <span class="title">GetName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-10-多类继承"><a href="#1-10-多类继承" class="headerlink" title="1.10 多类继承"></a>1.10 多类继承</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123; </span><br><span class="line"><span class="keyword">protected</span>:  </span><br><span class="line">  String name;</span><br><span class="line">  EmpID id; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MTS</span> : <span class="keyword">public</span> Employee &#123;</span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line">  Degrees degree_info; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Temporary</span> &#123; </span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line">  Company employer; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consultant</span>:  <span class="keyword">public</span> MTS,  <span class="keyword">public</span> Temporary &#123;</span><br><span class="line">... &#125;;</span><br></pre></td></tr></table></figure>

<p>此时Consultant有MTS和Temporary的属性</p>
<img src="/Learning/OOP%E7%AC%94%E8%AE%B0/image-20220422110005378.png">

<h4 id="【注意】虚表"><a href="#【注意】虚表" class="headerlink" title="【注意】虚表"></a>【注意】虚表</h4><p>每个包含虚函数的类都有一个虚表，虚表是属于类的，而不是属于某个具体的对象，一个类只需要一个虚表即可。同一个类的所有对象都使用同一个虚表。为了指定对象的虚表，对象内部包含指向一个虚表的指针，来指向自己所使用的虚表。为了让每个包含虚表的类的对象都拥有一个虚表指针，编译器在类中添加了一个指针，<code>*__vptr</code>，用来指向虚表。 这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚表。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/353260837#:~:text=%E8%99%9A%E8%A1%A8%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%8C%87,%E5%87%BD%E6%95%B0%E6%89%80%E5%9C%A8%E7%9A%84%E4%BD%8D%E7%BD%AE%E3%80%82">https://zhuanlan.zhihu.com/p/353260837#:~:text=%E8%99%9A%E8%A1%A8%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%8C%87,%E5%87%BD%E6%95%B0%E6%89%80%E5%9C%A8%E7%9A%84%E4%BD%8D%E7%BD%AE%E3%80%82</a></p>
<h4 id="【注意】类的sizeof"><a href="#【注意】类的sizeof" class="headerlink" title="【注意】类的sizeof"></a>【注意】类的sizeof</h4><ol>
<li>空类的大小：1</li>
<li>一般非空类的大小：成员变量sizeof的总和</li>
<li>有虚函数类：在成员变量的总和的基础上加上指<strong>向虚表的指针</strong>（4）</li>
<li>有继承的类：基类加子类大小</li>
</ol>
<ul>
<li><p>【习题】</p>
</li>
<li><p>Given:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span> &#123;</span><br><span class="line">    A() &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">f</span>()</span> &#123;&#125;;</span><br><span class="line">    <span class="built_in">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>which statement is NOT true:</p>
<p>A.i is private</p>
<p>B.f() is an inline function</p>
<p>C.i is a member of class A</p>
<p>D.sizeof(A) &#x3D;&#x3D; sizeof(int)</p>
</li>
<li><p>答：BD均错。D中的sizeof(A)&#x3D;4+4&#x3D;8</p>
</li>
</ul>
<h2 id="WK9"><a href="#WK9" class="headerlink" title="WK9"></a>WK9</h2><h3 id="1-Copy-Ctor-拷贝构造"><a href="#1-Copy-Ctor-拷贝构造" class="headerlink" title="1. Copy Ctor 拷贝构造"></a>1. Copy Ctor 拷贝构造</h3><p>复制构造函数是构造函数的一种，也称拷贝构造函数，它只有一个参数，<strong>参数类型是本类的引用</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">Stash <span class="title">students</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是函数原型声明，students( )函数返回一个Stash</p>
<h4 id="1-1-Copying"><a href="#1-1-Copying" class="headerlink" title="1.1 Copying"></a>1.1 Copying</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;A()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">const</span> A&amp;r):<span class="built_in">a</span>(r.a)&#123;cout&lt;&lt;<span class="string">&quot;Here&quot;</span>&lt;&lt;endl;&#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;<span class="keyword">this</span>-&gt;a=a;&#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> a;&#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;~A()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(A aa)</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;f:&quot;</span>&lt;&lt;aa.<span class="built_in">getValue</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  A x=<span class="built_in">A</span>();</span><br><span class="line">    x.<span class="built_in">setValue</span>(<span class="number">3</span>);</span><br><span class="line">  A y=<span class="built_in">A</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A()</span></span><br><span class="line"><span class="comment">Here</span></span><br><span class="line"><span class="comment">~A()</span></span><br><span class="line"><span class="comment">~A()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//在构造y时没有调用A的默认构造函数</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>拷贝构造：</p>
</li>
<li><p>如果没有拷贝构造函数，编译器会自动插入拷贝构造函数</p>
<p>参数是本类的一个对象的引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T::<span class="built_in">T</span>(<span class="type">const</span> T&amp;);<span class="comment">//要有const</span></span><br><span class="line">T::<span class="built_in">T</span>(T&amp;);<span class="comment">//不安全</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>没有拷贝构造：编译器会给你一个拷贝构造，自己写的拷贝构造要把所有的属性拷贝过来。必须要做拷贝构造的情况：成员里有<strong>指针</strong>，或者有些<strong>属性不想被拷贝过来</strong>。</p>
</li>
<li><p>何时被调用？</p>
<ul>
<li>函数使用这个对象时，不是使用指针</li>
<li>用另一个对象初始化时</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> ii=<span class="number">0</span>):<span class="built_in">i</span>(ii) &#123; cout &lt;&lt; <span class="string">&quot;Actor&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; a) &#123;</span><br><span class="line">        i = a.i;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Copy&quot;</span>&lt;&lt;endl;;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="number">3</span> &lt;&lt; i; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(A aa)</span></span>&#123;cout&lt;&lt;aa.i&lt;&lt;<span class="string">&quot; f&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(A* aa)</span></span>&#123;cout&lt;&lt;&amp;aa-&gt;i&lt;&lt;<span class="string">&quot; g&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    A b=a;</span><br><span class="line">    <span class="function">A <span class="title">c</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    c=a;</span><br><span class="line">    <span class="built_in">f</span>(a);</span><br><span class="line">    <span class="built_in">g</span>(&amp;a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Actor//默认构造函数</span></span><br><span class="line"><span class="comment">Copy//拷贝构造在在赋值使用,b默认构造没有调用</span></span><br><span class="line"><span class="comment">Actor//c默认构造，没有使用拷贝构造</span></span><br><span class="line"><span class="comment">Copy//函数调用的拷贝构造</span></span><br><span class="line"><span class="comment">1 f//f</span></span><br><span class="line"><span class="comment">0x78fe14 g//g是使用指针传入的没有调用拷贝构造</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>有指针的到时候要自己写拷贝构造</p>
</li>
<li><img src="/Learning/OOP%E7%AC%94%E8%AE%B0/image-20220422112354516.png"></li>
</ul>
<h2 id="WK10"><a href="#WK10" class="headerlink" title="WK10"></a>WK10</h2><h3 id="1-复制构造什么时候调用"><a href="#1-复制构造什么时候调用" class="headerlink" title="1. 复制构造什么时候调用"></a>1. 复制构造什么时候调用</h3><ol>
<li><p>调用函数时，函数的参数是<strong>对象本身</strong>，不是指针不是引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">A <span class="title">f</span><span class="params">(A aa)</span></span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>拷贝赋值，<strong>赋值对象没有定义时</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">A b=a;</span><br></pre></td></tr></table></figure>
</li>
<li><p>拷贝构造</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">A <span class="title">b</span><span class="params">(a)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数返回时，返回值可能调用拷贝构造，若返回了值被赋值到新的对象上，则需要拷贝构造。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">A <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">aa</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"> <span class="keyword">return</span> aa;<span class="comment">//copy</span></span><br><span class="line">&#125;;</span><br><span class="line">A b=<span class="built_in">f</span>();<span class="comment">//copy</span></span><br><span class="line"><span class="comment">//有的编译器会把这两个拷贝构造优化</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="1-1-拷贝构造和赋值"><a href="#1-1-拷贝构造和赋值" class="headerlink" title="1.1 拷贝构造和赋值"></a>1.1 拷贝构造和赋值</h4><ul>
<li>对象的构造只能构造一次</li>
<li><strong>当一个对象被构造，他能作为一个变量来赋值</strong>，C++的特性</li>
</ul>
<h3 id="2-运算符重载"><a href="#2-运算符重载" class="headerlink" title="2. 运算符重载"></a>2. 运算符重载</h3><p>加减乘除的运算可以进行重载，可以自己写一个类重写运算符。</p>
<img src="/Learning/OOP%E7%AC%94%E8%AE%B0/image-20220429103143650.png">

<h4 id="2-1-限制"><a href="#2-1-限制" class="headerlink" title="2.1 限制"></a>2.1 限制</h4><ol>
<li>只有已经存在的运算符才能重载</li>
<li><strong>不能重载的有</strong><code> .</code> ,<code> .*</code>,<code>::</code>,<code>?:</code>,static_cast,dynamic_cast,const_cast,reinterpret_cast</li>
<li>只能在类和一个枚举type中重载，不能对cpp原来自己的类的运算符重载。</li>
<li>运算符的操作数的数量、优先级、结合律等要一致</li>
</ol>
<h4 id="2-2-如何写？"><a href="#2-2-如何写？" class="headerlink" title="2.2 如何写？"></a>2.2 如何写？</h4><p>operator关键字</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Mystring Mystring::<span class="keyword">operator</span> +(<span class="type">const</span> Mystring&amp; that)<span class="comment">//类函数</span></span><br><span class="line"><span class="comment">//对象本身就是一个操作数。</span></span><br><span class="line"><span class="type">const</span> Mystring opearator+(<span class="type">const</span> Mystring&amp; r,<span class="type">const</span> Mystring &amp;l)<span class="comment">//全局函数</span></span><br><span class="line"><span class="comment">//一般定义为Mystring的友元函数以便访问内部</span></span><br></pre></td></tr></table></figure>

<ul>
<li>一元操作符要是成员函数</li>
<li><code>=</code>,<code>()</code>,<code>[]</code>,<code>-&gt;</code>,<code>-&gt;*</code>必须是成员的</li>
<li>assignment operators should be members</li>
<li>All other binary operators as non-members</li>
</ul>
<p>类内定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> ii=<span class="number">0</span>):<span class="built_in">i</span>(ii) &#123; cout &lt;&lt; <span class="string">&quot;Actor&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; a) &#123;</span><br><span class="line">        i = a.i;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Copy&quot;</span>&lt;&lt;endl;;     </span><br><span class="line">    &#125;</span><br><span class="line">    A <span class="keyword">operator</span>+(<span class="type">const</span> A&amp; that)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;op +&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">A</span>(i+that.i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="number">3</span> &lt;&lt; i; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">geti</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">A <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">A c=a+b;<span class="comment">//Copy了但是被优化了</span></span><br><span class="line">c.<span class="built_in">print</span>();</span><br><span class="line">A d=b+<span class="number">3</span>;</span><br><span class="line">d.<span class="built_in">print</span>();</span><br><span class="line">A e=<span class="number">3</span>+d;<span class="comment">//illegal !!!因为3不是A对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Actor</span></span><br><span class="line"><span class="comment">Actor</span></span><br><span class="line"><span class="comment">op +</span></span><br><span class="line"><span class="comment">Actor</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">Actor</span></span><br><span class="line"><span class="comment">op +</span></span><br><span class="line"><span class="comment">Actor</span></span><br><span class="line"><span class="comment">5*/</span></span><br></pre></td></tr></table></figure>

<p>全局定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> ii=<span class="number">0</span>):<span class="built_in">i</span>(ii) &#123; cout &lt;&lt; <span class="string">&quot;Actor: &quot;</span>&lt;&lt;ii&lt;&lt;endl; &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; a) &#123;</span><br><span class="line">        i = a.i;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Copy&quot;</span>&lt;&lt;endl;;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// A operator+(const A&amp; that)&#123;</span></span><br><span class="line">    <span class="comment">//     cout&lt;&lt;&quot;op +&quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">//     A c(i+that.i);</span></span><br><span class="line">    <span class="comment">//     return c;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt;i&lt;&lt;endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_nonc</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;nonconst &quot;</span>&lt;&lt;i&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">geti</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> A <span class="keyword">operator</span>+(<span class="type">const</span> A &amp;x,<span class="type">const</span> A &amp;y)&#123;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;-outside&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> ret=x.i+y.i;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">A</span>(ret);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">A <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">A c=a+b;</span><br><span class="line">c.<span class="built_in">print</span>();</span><br><span class="line">A d=b+<span class="number">3</span>;</span><br><span class="line">d.<span class="built_in">print</span>();</span><br><span class="line">A e=<span class="number">3</span>+d;<span class="comment">//此时不会报错，因为用3构造了一个A</span></span><br><span class="line">e.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Actor: 1</span></span><br><span class="line"><span class="comment">Actor: 2</span></span><br><span class="line"><span class="comment">-outside</span></span><br><span class="line"><span class="comment">Actor: 3</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">Actor: 3</span></span><br><span class="line"><span class="comment">-outside</span></span><br><span class="line"><span class="comment">Actor: 5</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">Actor: 3</span></span><br><span class="line"><span class="comment">-outside</span></span><br><span class="line"><span class="comment">Actor: 8</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在全局的更好！<ul>
<li>z&#x3D;x+y</li>
<li>z&#x3D;x+3</li>
<li>z&#x3D;3+x；</li>
<li><strong>z&#x3D;3+5        &#x2F;&#x2F;z&#x3D;8是一个构造！！！</strong></li>
</ul>
</li>
</ul>
<h4 id="2-3-成员or全局？"><a href="#2-3-成员or全局？" class="headerlink" title="2.3 成员or全局？"></a>2.3 成员or全局？</h4><ul>
<li>Unary操作符要是成员的，&#x3D; () [] -&gt; -&gt;*要成员的</li>
<li>一般在类内会使用<strong>友元函数</strong>定义</li>
<li>参数类型与返回类型，参数类型视操作数是否改变而定，返回类型视对象<strong>是否做左值</strong>,是否要做操作。</li>
</ul>
<h4 id="2-4-操作符和–操作符"><a href="#2-4-操作符和–操作符" class="headerlink" title="2.4 ++操作符和–操作符"></a>2.4 ++操作符和–操作符</h4><ul>
<li><p>a++和++a</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Integer&amp; Integer::<span class="keyword">operator</span>++()&#123;</span><br><span class="line">  *<span class="keyword">this</span> += <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;<span class="comment">//++a;</span></span><br><span class="line"><span class="type">const</span> Integer Integer::<span class="keyword">operator</span>++(<span class="type">int</span> )&#123;<span class="comment">//做了一个int的标识</span></span><br><span class="line">    <span class="function">Integer <span class="title">old</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    ++(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;<span class="comment">//a++;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-5-关系运算符"><a href="#2-5-关系运算符" class="headerlink" title="2.5 关系运算符"></a>2.5 关系运算符</h4><p>返回bool值</p>
<h4 id="2-6-操作运算符"><a href="#2-6-操作运算符" class="headerlink" title="2.6 [ ]操作运算符"></a>2.6 [ ]操作运算符</h4><ul>
<li><p>返回是一个<strong>reference</strong></p>
</li>
<li><p>&#96;&#96;&#96;cpp<br>class A{<br>public:<br>int i;<br>public:<br>A(int ii&#x3D;0):i(ii) { cout &lt;&lt; “Actor”&lt;&lt;endl; }<br>A(const A&amp; a) {<br>    i &#x3D; a.i;<br>    cout &lt;&lt; “Copy”&lt;&lt;endl;;<br>}<br><br>void print() const { cout &lt;&lt;i&lt;&lt;endl; }<br>int geti(){return i;}<br>int&amp; operator[](int idx){<br>    return i+idx<br>}<br>};</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">## WK11</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### <span class="number">1.</span> Stream Extractor（&gt;&gt;） and Inserter（&lt;&lt;）</span><br><span class="line"></span><br><span class="line">即&lt;&lt;和&gt;&gt;的重载</span><br><span class="line"></span><br><span class="line">#### <span class="number">1.1</span> Extractor</span><br><span class="line"></span><br><span class="line">**这个函数一定是全局函数**，因为一定是有跟着cin和cout的，**不一定是iostream的friend**，但是一定要是你写的类的友元函数，返回一个**istream的reference**</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">istream&amp; operator&gt;&gt;(istream&amp; is,T&amp; obj)&#123;</span><br><span class="line">  <span class="comment">//your code</span></span><br><span class="line">  return is</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="1-2-Inserter"><a href="#1-2-Inserter" class="headerlink" title="1.2 Inserter"></a>1.2 Inserter</h4><p>返回类型是ostream的引用，注意这里的对象T应该是要const，因为我们只输出的话不会更改T，因此，我们要这么写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,<span class="type">const</span> T&amp; obj)&#123;</span><br><span class="line">  <span class="comment">//your code</span></span><br><span class="line">  <span class="keyword">return</span> os</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-endl是什么"><a href="#1-3-endl是什么" class="headerlink" title="1.3 endl是什么"></a>1.3 endl是什么</h4><p>是一个<strong>manipulator</strong>，实质是一个函数，但是不用括号如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream&amp; <span class="title">manip</span><span class="params">(ostream&amp; out)</span> </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">return</span> out; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function">ostream&amp; <span class="title">tab</span> <span class="params">( ostream&amp; out )</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">  <span class="keyword">return</span> out &lt;&lt; <span class="string">&#x27;\t&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; tab &lt;&lt; <span class="string">&quot;World!&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h3 id="2-Copying-vs-Initialization"><a href="#2-Copying-vs-Initialization" class="headerlink" title="2. Copying vs Initialization"></a>2. Copying vs Initialization</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyType b;</span><br><span class="line">MyType a=b;</span><br><span class="line">a=b;</span><br></pre></td></tr></table></figure>

<h3 id="3-赋值运算符的重载"><a href="#3-赋值运算符的重载" class="headerlink" title="3. 赋值运算符的重载"></a>3. 赋值运算符的重载</h3><p>赋值运算符必须是一个Reference，因为要做左值，赋值是赋值给自己，因此我们要判断赋值值和赋值对象的值要判断是否一致，<strong>不能自己给自己赋值</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T&amp; T::<span class="keyword">operator</span>=(<span class="type">const</span> T&amp; rhs)&#123;</span><br><span class="line">  <span class="comment">//check for self assignment</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>!=&amp;rhs)&#123;</span><br><span class="line">    <span class="comment">//preform assignment</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//注意这里是*this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意：<strong>如果有数组之类的new出来的空间在new之前要delete</strong></li>
<li>this和&amp;rhs的指针比较，<em>this和rhs的数值比较哪个好？*<em>地址比较更好。</em></em></li>
<li>对于具有动态分配内存的类，声明赋值操作符(和复制构造函数)</li>
<li>为了防止赋值，显式地将operator&#x3D;声明为private</li>
</ul>
<h3 id="4-Value-classes"><a href="#4-Value-classes" class="headerlink" title="4. Value classes"></a>4. Value classes</h3><p>表达一些值的类，这些值要在函数间传入传出</p>
<ul>
<li>定义类型转换</li>
<li>需要overload operator等</li>
</ul>
<h4 id="4-1-类型转换"><a href="#4-1-类型转换" class="headerlink" title="4.1 类型转换"></a>4.1 类型转换</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PathName</span>&#123;</span><br><span class="line">  string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">PathName</span>(<span class="type">const</span> string&amp;);</span><br><span class="line">  ~<span class="built_in">PathName</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">string <span class="title">abc</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">PathName <span class="title">xyz</span><span class="params">(abc)</span></span>;<span class="comment">//OK!!</span></span><br><span class="line">xyz=abc;<span class="comment">//自动类型转换abc转化为了PathName赋给了xyz</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显式调用关键字explicit</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PathName</span>&#123;</span><br><span class="line">  string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">PathName</span><span class="params">(<span class="type">const</span> string&amp;)</span></span>;</span><br><span class="line">  ~<span class="built_in">PathName</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">string <span class="title">abc</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">PathName <span class="title">xyz</span><span class="params">(abc)</span></span>;<span class="comment">//OK!!</span></span><br><span class="line">xyz=abc;<span class="comment">//Error!!错误提示没有=赋值运算符从string到pathname</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>建议不要重载&#x3D;号来实现不同的类型转换，因为赋值一般是一样的类型的，而且需要转化的类有很多不可能写专门的类。</p>
</li>
<li><p><strong>explicit关键字说明这里只用于显式调用构造</strong>。</p>
</li>
<li><pre><code class="cpp">class A&#123;
public:
    int i;
public:
    A(int ii=0):i(ii) &#123; cout &lt;&lt; &quot;Actor: &quot;&lt;&lt;ii&lt;&lt;endl; &#125;
    A(const A&amp; a) &#123;
        i = a.i;
        cout &lt;&lt; &quot;Copy&quot;&lt;&lt;endl;;     
    &#125;
    const A operator++()&#123;
        this-&gt;i +=1;
        return *this;
    &#125;
    const A operator++(int)&#123;
        A old(*this);
        ++(*this);
        return old;
    &#125;
    void print() const &#123; cout &lt;&lt;i&lt;&lt;endl; &#125;
    void print_nonc()&#123;cout&lt;&lt;&quot;nonconst &quot;&lt;&lt;i&lt;&lt;endl;&#125;
    int geti()&#123;return i;&#125;
&#125;;
const A operator+(const A &amp;x,const A &amp;y)&#123;
  cout&lt;&lt;&quot;-outside&quot;&lt;&lt;endl;
    int ret=x.i+y.i;
  return A(ret);
&#125;
int main()&#123;
A a(1);
A b(2);
A m1=a+3;//若构造函数前没有explicit则正确，否则不可隐性构造导致错误。
k.print();
a.print();
&#125;
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 类型转换函数的一般形式：</span><br><span class="line"></span><br><span class="line">  ```cpp</span><br><span class="line"><span class="title">  X::</span>operator T()</span><br></pre></td></tr></table></figure>

- 操作符名称是任何类型描述符
- 无显式参数
- **没有返回类型**
- 编译器将它用作从X的类型转换T
</code></pre>
</li>
<li><p>用户定义的T→C</p>
<ul>
<li>C(T)，C从T构造而来</li>
<li>T::operator C( )，重载了C( )操作符</li>
<li>但是两个方法不能同时使用，在构造时没问题，但是在等号赋值时，编译器不知道是构造C，从T到C的方法两种不知道用那种。</li>
<li>要解决可以在构造函数上加上Explicit</li>
</ul>
</li>
<li><p>Overload遇上了转换：成本最低原则，匹配最好的类型</p>
</li>
</ul>
<h3 id="5-对象初始化"><a href="#5-对象初始化" class="headerlink" title="5. 对象初始化"></a>5. 对象初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小括号初始化</span></span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>; </span><br><span class="line"><span class="comment">//等号初始化</span></span><br><span class="line">string str = <span class="string">&quot;hello&quot;</span>; </span><br><span class="line"><span class="comment">//大括号初始化</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Studnet</span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="type">char</span> *name; </span><br><span class="line">  <span class="type">int</span> age; </span><br><span class="line">&#125;; </span><br><span class="line">Studnet s = &#123;<span class="string">&quot;dablelv&quot;</span>, <span class="number">18</span>&#125;;<span class="comment">//Plain of Data类型对象</span></span><br><span class="line">Studnet sArr[] = &#123;&#123;<span class="string">&quot;dablelv&quot;</span>, <span class="number">18</span>&#125;, &#123;<span class="string">&quot;tommy&quot;</span>, <span class="number">19</span>&#125;&#125;; <span class="comment">//POD数组</span></span><br></pre></td></tr></table></figure>

<h4 id="5-1-列表初始化"><a href="#5-1-列表初始化" class="headerlink" title="5.1 列表初始化"></a>5.1 列表初始化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Test</span>(<span class="type">int</span> i.<span class="type">int</span> j);</span><br><span class="line">&#125;;</span><br><span class="line">Test t&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;<span class="comment">//等价于Test t(0,0)</span></span><br><span class="line">Test *pT = <span class="keyword">new</span> Test&#123;<span class="number">1</span>,<span class="number">2</span>&#125;<span class="comment">//C++11 only</span></span><br><span class="line"><span class="type">int</span> *a = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>&#125;<span class="comment">//c++11 only</span></span><br></pre></td></tr></table></figure>

<h4 id="5-2-容器初始化"><a href="#5-2-容器初始化" class="headerlink" title="5.2 容器初始化"></a>5.2 容器初始化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; vs=&#123; <span class="string">&quot;first&quot;</span>, <span class="string">&quot;second&quot;</span>, <span class="string">&quot;third&quot;</span>&#125;;  </span><br><span class="line">map&lt;string,string&gt; singers =&#123; &#123;<span class="string">&quot;Lady Gaga&quot;</span>, <span class="string">&quot;+1 (212) 555-7890&quot;</span>&#125;,&#123;<span class="string">&quot;Beyonce Knowles&quot;</span>, <span class="string">&quot;+1 (212) 555-0987&quot;</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6-函数的参数和返回值"><a href="#6-函数的参数和返回值" class="headerlink" title="6. 函数的参数和返回值"></a>6. 函数的参数和返回值</h3><h4 id="6-1-Way-in"><a href="#6-1-Way-in" class="headerlink" title="6.1 Way in"></a>6.1 Way in</h4><ul>
<li><p>void f(Student i); </p>
<ul>
<li>a new object is to be created in f &#x2F;&#x2F;在f中要拷贝构造</li>
</ul>
</li>
<li><p>void f(Student *p); </p>
<ul>
<li>better with const if no intend to modify the object</li>
</ul>
</li>
<li><p>void f(Student&amp; i); </p>
<ul>
<li>better with const if no intend to modify the object</li>
</ul>
</li>
</ul>
<h4 id="6-2-Way-out"><a href="#6-2-Way-out" class="headerlink" title="6.2 Way out"></a>6.2 Way out</h4><ul>
<li>Student f(); <ul>
<li>a new object is to be created at returning </li>
<li>新的obj会返回出来</li>
</ul>
</li>
<li>Student* f();<ul>
<li>what should it points to?</li>
</ul>
</li>
<li>Student&amp; f();<ul>
<li>what should it refers to?</li>
</ul>
</li>
</ul>
<h4 id="6-3-Tips"><a href="#6-3-Tips" class="headerlink" title="6.3 Tips"></a>6.3 Tips</h4><ul>
<li>希望存储对象，传入对象而非指针和引用<ul>
<li>因为要复制一份存下来，不能复制地址</li>
</ul>
</li>
<li>只想要传入值，只需要const pointer 或者 reference</li>
<li>如果创建了对象，传出对象</li>
<li>Pass out pointer or reference of the passed in only </li>
<li>Never new something and return the pointer</li>
</ul>
<h3 id="7-左值和右值"><a href="#7-左值和右值" class="headerlink" title="7. 左值和右值"></a>7. 左值和右值</h3><ul>
<li><p>可以简单地认为能出现在赋值号左边的都是左值：</p>
<ul>
<li>变量本身、引用</li>
<li>*、[]运算的结果</li>
</ul>
</li>
<li><p>只能出现在赋值号右边的都是右值</p>
<ul>
<li>字面量</li>
<li>表达式</li>
</ul>
</li>
<li><p><strong>引用只能接受左值</strong></p>
<ul>
<li>引用是左值的别名</li>
</ul>
</li>
<li><p>调用函数时的传参相当于参数变量在调用时的初始化</p>
</li>
</ul>
<h4 id="7-1-右值的引用"><a href="#7-1-右值的引用" class="headerlink" title="7.1 右值的引用"></a>7.1 右值的引用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">20</span>;<span class="comment">//左值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp; rx=x*<span class="number">2</span><span class="comment">//x*2是一个右值，一个&amp;是左值引用，两个&amp;是右值引用即rx绑定了一个右值</span></span><br><span class="line"><span class="type">int</span> y=rx+<span class="number">2</span>;<span class="comment">//y=42</span></span><br><span class="line">rx=<span class="number">100</span>;一旦初始化一个右值引用变量，那么这个变量就成为了一个左值</span><br><span class="line"><span class="type">int</span> &amp;&amp; rrx1=x;<span class="comment">//非法：右值引用无法被左值初始化</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp;&amp; rrx2=x;<span class="comment">//非法：右值引用无法被左值初始化</span></span><br></pre></td></tr></table></figure>

<p>右值引用变量的初始化只能是右值</p>
<p>但是<img src="/Learning/OOP%E7%AC%94%E8%AE%B0/image-20220622201829652.png"> alt&#x3D;”image-20220622201829652” style&#x3D;”zoom:50%;” &#x2F;&gt;</p>
<h3 id="8-移动构造"><a href="#8-移动构造" class="headerlink" title="8. 移动构造"></a>8. 移动构造</h3><p>所谓移动语义，指的就是以移动而非深拷贝的方式初始化含有指针成员的类对象。简单的理解，移动语义指的就是将其他对象（通常是临时对象）拥有的内存资源“移为已用”。</p>
<p>以前面程序中的 demo 类为例，该类的成员都包含一个整形的指针成员，其默认指向的是容纳一个整形变量的堆空间。当使用 get_demo() 函数返回的临时对象初始化 a 时，我们只需要将临时对象的 num 指针直接浅拷贝给 a.num，然后修改该临时对象中 num 指针的指向（通常另其指向 NULL），这样就完成了 a.num 的初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">demo</span>():<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>))&#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//拷贝构造函数</span></span><br><span class="line">   <span class="built_in">demo</span>(<span class="type">const</span> demo &amp;d):<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*d.num))&#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;copy construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line">   ~<span class="built_in">demo</span>()&#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;class destruct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="type">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">demo <span class="title">get_demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">demo</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    demo a = <span class="built_in">get_demo</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="WK12"><a href="#WK12" class="headerlink" title="WK12"></a>WK12</h2><h3 id="1-模板Template"><a href="#1-模板Template" class="headerlink" title="1. 模板Template"></a>1. 模板Template</h3><h4 id="1-1-什么是模板"><a href="#1-1-什么是模板" class="headerlink" title="1.1 什么是模板"></a>1.1 什么是模板</h4><p>假设我们需要一个list容器，想要有放多种类型的容器，这些代码是非常相似的，唯一的不同是类型不同。</p>
<ol>
<li><p>可以使用公共父类</p>
<p>可能不太满足我们的要求</p>
</li>
<li><p>clone code</p>
<p>难以管理</p>
</li>
<li><p>Untyped lists 无类型的list</p>
<p>type unsafe</p>
</li>
</ol>
<p>元代码：</p>
<ul>
<li>泛型编程</li>
<li>使用类型作为参数在类或函数定义</li>
</ul>
<p>函数模板</p>
<p>类模板</p>
<h4 id="1-2-函数模板"><a href="#1-2-函数模板" class="headerlink" title="1.2 函数模板"></a>1.2 函数模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;      <span class="comment">//必须单独一行 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp;x,T&amp;y)</span></span>&#123;</span><br><span class="line">  T temp=x;</span><br><span class="line">  x=y;</span><br><span class="line">  y=temp;</span><br><span class="line">&#125;</span><br><span class="line">string a,b;</span><br><span class="line"><span class="built_in">swap</span>&lt;string&gt;(a,b);</span><br><span class="line"><span class="comment">//在函数名称后加上尖括号和类型</span></span><br></pre></td></tr></table></figure>

<ul>
<li>调用时优先调用非模板函数</li>
<li>当函数中没有使用T时，一定要加上<type>来区别</type></li>
</ul>
<h4 id="1-3-类模板"><a href="#1-3-类模板" class="headerlink" title="1.3 类模板"></a>1.3 类模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Vector</span>(<span class="type">int</span> size):<span class="built_in">size</span>(s)&#123;&#125;;</span><br><span class="line">  ~<span class="built_in">Vector</span>();</span><br><span class="line">  <span class="built_in">Vector</span>(<span class="type">const</span> Vector&amp;);</span><br><span class="line">  T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> key);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T* m_elements;</span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T&amp; Vector&lt;T&gt;::<span class="keyword">operator</span>[](<span class="type">int</span> i)&#123;</span><br><span class="line">  <span class="keyword">return</span> content[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>类模板：类的声明、类的成员的定义</li>
<li>注意成员的定义：要template，<T>等</T></li>
</ul>
<h4 id="1-4-Tips"><a href="#1-4-Tips" class="headerlink" title="1.4 Tips"></a>1.4 Tips</h4><ul>
<li><strong>模板不被编译，模板是生成代码的</strong></li>
<li>模板也支持多个类型的定义<ul>
<li>如：template &lt;class key，class value&gt;</li>
<li>注意：&lt;Vector Vector&lt;double *&gt; &gt;这里加个空格</li>
</ul>
</li>
<li><strong>模板也支持中间有固定类型与缺省参数</strong><ul>
<li>如：template&lt;class a，int num&#x3D;100&gt;</li>
</ul>
</li>
<li>类模板记得静态变量需要一个全局变量</li>
<li>但是类模板的全局变量不能是类模板本身的一个对象</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> Vector&lt;T&gt;::count=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Templates的继承</p>
<ul>
<li><p>普通类可以派生类模板</p>
<ul>
<li>&#96;&#96;&#96;cpp<br>template <class a>  class Derived : public Base { }<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 能继承类模板</span><br><span class="line"></span><br><span class="line">  - ```cpp</span><br><span class="line">    template &lt;<span class="keyword">class</span> <span class="symbol">A</span>&gt; <span class="symbol">class</span> <span class="symbol">Derived</span> : <span class="symbol">public</span> <span class="symbol">List</span>&lt;<span class="symbol">A</span>&gt; &#123; &#125;</span><br></pre></td></tr></table></figure></class></li>
</ul>
</li>
<li><p>非模板类可以继承模板类</p>
<ul>
<li>&#96;&#96;&#96;cpp<br>class SupervisorGroup : public List&lt;Employee*&gt; { }<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 类模板中同样可以定义友元函数</span><br><span class="line"></span><br><span class="line">  ```cpp</span><br><span class="line">  <span class="keyword">template</span>&lt;T&gt;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> T&amp; ii):<span class="built_in">i</span>(ii)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;cout&lt;&lt;kk&lt;&lt;endl;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    T i;</span><br><span class="line">    <span class="type">static</span> T kk;<span class="comment">//最好不要这么写</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;cout&lt;&lt;i&lt;&lt;endl;&#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">  <span class="type">int</span> A&lt;T&gt;::kk=<span class="number">0</span>;<span class="comment">///Error</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">A&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="WK13"><a href="#WK13" class="headerlink" title="WK13"></a>WK13</h2><h3 id="1-Exceptions-异常处理"><a href="#1-Exceptions-异常处理" class="headerlink" title="1. Exceptions 异常处理"></a>1. Exceptions 异常处理</h3><p>程序运行的时候处理发生的情况，不是error的而是一种solution，无法避开。</p>
<p>能够与之发生，异常不一定发生，但是一定 会 发生</p>
<p>读文件、打开文件、判断文件大小、申请内存空间、关闭文件。</p>
<p>每一个步骤都可能存在异常，一旦异常，后续无法继续进行。</p>
<h4 id="1-1-异常处理的语法"><a href="#1-1-异常处理的语法" class="headerlink" title="1.1 异常处理的语法"></a>1.1 异常处理的语法</h4><ul>
<li><code>try( ) catch&#123; &#125;</code>;<ul>
<li>表示try中的为保护代码，try中出现了错误，错误发生后的代码不会被执行，而是直接跳转到对应的catch中，处理完后继续向下运行</li>
</ul>
</li>
<li>throw语句：抛出异常<ul>
<li><code>throw  exp</code>抛出一个表达式，throw的参数可以是任何的表达式，表达式中的类型决定了抛出结果的类型</li>
<li><code>throw</code>把原本捕捉的异常抛出，只在catch子句中有效</li>
<li>throw下方的语句都不会被执行，离开当前语句</li>
</ul>
</li>
</ul>
<h4 id="1-2-异常处理的过程"><a href="#1-2-异常处理的过程" class="headerlink" title="1.2 异常处理的过程"></a>1.2 异常处理的过程</h4><ul>
<li><p>程序按照正常的顺序执行，执行到try，开始执行try内的保护段</p>
</li>
<li><p>如果在保护段执行期间没有发生异常，那么跳过所有的catch</p>
</li>
<li><p>如果保护段的执行期间有调用的任何函数中有异常，则可以通过throw创建一个异常对象并抛出，程序转到对应的catch处理段</p>
</li>
<li><p>首先要按顺序寻找匹配的catch处理器，如果没有找到，则 terminate( ) 会被自动调用，该函数会调用abort终止程序</p>
<ul>
<li>如果在函数中进行异常处理并且触发了terminate，那么终止的是当前函数</li>
<li>异常类型需要严格的匹配</li>
</ul>
</li>
<li><p>如果找到了匹配的catch处理程序，并且通过值进行捕获，则其形参通过拷贝异常对象进行初始化，在形参被初始化之后，展开栈的过程开始，开始对对应的try块中，从开始到异常丢弃地点之间创建的所有局部对象的析构</p>
</li>
</ul>
<h4 id="1-3-Try-block"><a href="#1-3-Try-block" class="headerlink" title="1.3  Try block"></a>1.3  Try block</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  doing</span><br><span class="line">    <span class="keyword">throw</span> SomeType v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(SomeType v)&#123;&#125;</span><br><span class="line"><span class="built_in">catch</span>()&#123;SomeType u&#125;</span><br><span class="line"><span class="built_in">catch</span>(...)&#123;&#125;<span class="comment">//捕捉任何异常</span></span><br></pre></td></tr></table></figure>

<ul>
<li>异常类可以继承的，抛出了A类异常，B为A的父类，接受B类的catch是可以接受A类的。如果既有捕捉A的又有捕捉B的，优先第一个<strong>捕捉的catch</strong>，其他catch不会再看了</li>
</ul>
<h4 id="1-4-new的exception"><a href="#1-4-new的exception" class="headerlink" title="1.4 new的exception"></a>1.4 new的exception</h4><ul>
<li>new does NOT returned 0 on failure </li>
<li>new raises a bad_alloc() exception</li>
</ul>
<h4 id="【C-中自带的异常的继承体系，定义在头文件-lt-exception-gt-中】"><a href="#【C-中自带的异常的继承体系，定义在头文件-lt-exception-gt-中】" class="headerlink" title="【C++中自带的异常的继承体系，定义在头文件 &lt;exception&gt; 中】"></a>【C++中自带的异常的继承体系，定义在头文件 &lt;exception&gt; 中】</h4><ul>
<li><p>what方法给出了产生异常的原因，是异常类之间都有的公共方法，已经被所有的子异常类重载</p>
</li>
<li><p>自定义的异常类：需要继承exception类</p>
</li>
<li><p>载</p>
</li>
</ul>
<img src="/Learning/OOP%E7%AC%94%E8%AE%B0/image-20220527094900344.png">

<h4 id="1-5-函数后面加throw"><a href="#1-5-函数后面加throw" class="headerlink" title="1.5 函数后面加throw()"></a>1.5 函数后面加throw()</h4><ul>
<li>可以在函数名后面加 noexcept 关键字，说明该函数在运行的过程中不抛出任何异常，如果<br>还是产生了异常，就会调用 <code>std::terminate</code> 终止程序</li>
<li>可以在函数声明中<strong>列出所有可能抛出的异常类型</strong>，比如 <code>double f(int, int) throw(int)</code>;</li>
<li>如果是<code>throw()</code>表示不抛出异常，就算函数里有throw也不会执行</li>
<li>如果是<code>throw(...)</code>表示抛出所有形式的异常</li>
<li>没有<code>throw()</code>则任意异常抛出</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/to_baidu/article/details/53763683">https://blog.csdn.net/to_baidu/article/details/53763683</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">T</span>()&#123;cout&lt;&lt;<span class="string">&quot;T()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">  ~<span class="built_in">T</span>()&#123;cout&lt;&lt;<span class="string">&quot;~T()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;T t;<span class="keyword">throw</span> <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span>(...)&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Catched!&quot;</span>&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行的结果是</span></span><br><span class="line"><span class="built_in">T</span>()</span><br><span class="line">~<span class="built_in">T</span>()</span><br><span class="line">Catched</span><br></pre></td></tr></table></figure>



<h2 id="WK14"><a href="#WK14" class="headerlink" title="WK14"></a>WK14</h2><h3 id="1-An-Example"><a href="#1-An-Example" class="headerlink" title="1. An Example"></a>1. An Example</h3><p>Templates、Inheritance、Reference Counting、Small Pointers</p>
<h4 id="1-1-Goal"><a href="#1-1-Goal" class="headerlink" title="1.1 Goal"></a>1.1 Goal</h4><p>C++没有实现自动内存管理的</p>
<ul>
<li><p>引用计数：</p>
<ul>
<li><p>对象在堆里有一个指针，当最后一个指针不指它，引用计数为0时析构</p>
</li>
<li><p>&#96;&#96;&#96;cpp<br>a &#x3D; new A();&#x2F;&#x2F;Aa的计数&#x3D;1<br>b &#x3D; a;&#x2F;&#x2F;Aa的计数&#x3D;2<br>b &#x3D; new A();&#x2F;&#x2F;Aa计数&#x3D;1，Ab&#x3D;1<br>a &#x3D; b;&#x2F;&#x2F;Aa的计数&#x3D;0，析构</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 引用计数的变化：在赋值时变化，左边的指针<span class="number">-1</span>，右边的指针+<span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">- Class UCObject</span><br><span class="line"></span><br><span class="line">  - 这个类是计数的</span><br><span class="line">  - UCPointer指向一个UCObject，是一个模板</span><br><span class="line"></span><br><span class="line">#### <span class="number">1.2</span> String类</span><br><span class="line"></span><br><span class="line">这是我们想要实现的自定义字符串类</span><br><span class="line"></span><br><span class="line">&lt;img src = <span class="string">&quot;OOP笔记\image-20220527100711038.png&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">Shared Memory：我们要自动回收这个abc内部的数据的自动回收</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">String abc(<span class="string">&quot;abcdef&quot;</span>);<span class="comment">//会被转成const char*</span></span><br><span class="line">String def = abc;<span class="comment">//Copy Ctor</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<img src="/Learning/OOP%E7%AC%94%E8%AE%B0/image-20220527100852792.png">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abc = <span class="string">&quot;Hello world&quot;</span>;<span class="comment">//copy on write</span></span><br></pre></td></tr></table></figure>

<img src="/Learning/OOP%E7%AC%94%E8%AE%B0/image-20220527101028521.png">

<h5 id="Reference-counting"><a href="#Reference-counting" class="headerlink" title="Reference counting"></a>Reference counting</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当</span></span><br><span class="line">p=q;</span><br><span class="line"><span class="comment">//我们要做</span></span><br><span class="line">p-&gt;decreament;<span class="comment">//计数器减一</span></span><br><span class="line">p=q;<span class="comment">//赋值</span></span><br><span class="line">q-&gt;increament;<span class="comment">//计数器加一</span></span><br></pre></td></tr></table></figure>

<img src="/Learning/OOP%E7%AC%94%E8%AE%B0/image-20220527101156603.png">

<h5 id="Reusing-Reference-Counting"><a href="#Reusing-Reference-Counting" class="headerlink" title="Reusing Reference Counting"></a>Reusing Reference Counting</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UCOject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">UCObject</span>():<span class="built_in">m_refCount</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">UCOject</span>()&#123;</span><br><span class="line">    <span class="built_in">assert</span>(m_refCount==<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">UCObject</span>(<span class="type">const</span> UCObject &amp;):<span class="built_in">m_refCount</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">incr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    m_refCount++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">decr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    m_refCount--;</span><br><span class="line">    <span class="keyword">if</span>(m_refCount==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">reference</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_refCount;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_refCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="UCPointer"><a href="#UCPointer" class="headerlink" title="UCPointer"></a>UCPointer</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UCPointer</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">UCPointer</span>(T *r=<span class="number">0</span>):<span class="built_in">m_pObj</span>(r)&#123;<span class="built_in">increment</span>();&#125;<span class="comment">//这是新的构造</span></span><br><span class="line">  ~<span class="built_in">UCPoiner</span>()&#123;<span class="built_in">decrement</span>();&#125;</span><br><span class="line">    <span class="built_in">UCPointer</span>(<span class="type">const</span> UCPointer&lt;T&gt; &amp;p)&#123;</span><br><span class="line">        m_pObj = p.m_pObj;</span><br><span class="line">        <span class="built_in">increment</span>();</span><br><span class="line">    &#125;<span class="comment">//拷贝构造也只需要左边加1</span></span><br><span class="line">    UCPointer &amp;<span class="keyword">operator</span>=(<span class="type">const</span> UCPointer&lt;T&gt; &amp;p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_pObj!=p.m_pObj)&#123;</span><br><span class="line">            <span class="built_in">decrement</span>();</span><br><span class="line">            m_pObj = p.m_pObj;</span><br><span class="line">            <span class="built_in">increment</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;()<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_pObj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个运算符重载了，调用时出来的结果是m_pObj-&gt;</span></span><br><span class="line">    T &amp;<span class="keyword">operator</span>*()<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *m_pObj;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T *m_pObj;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_pObj)m_pObj-&gt;<span class="built_in">incr</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">decrement</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_pObj)m_pObj-&gt;<span class="built_in">decr</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="String-Rep"><a href="#String-Rep" class="headerlink" title="String Rep"></a>String Rep</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UCObject.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringRep</span>:<span class="keyword">public</span> UCObject&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">StringRep</span>(<span class="type">const</span> <span class="type">char</span> *s)&#123;</span><br><span class="line">    <span class="keyword">if</span>(s)&#123;</span><br><span class="line">      <span class="type">int</span> len = <span class="built_in">strlen</span>(s)+<span class="number">1</span>;</span><br><span class="line">      m_pChars = <span class="keyword">new</span> <span class="type">char</span>[len];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      m_pChars = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">      *m_pChars = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">StringRep</span>()&#123;</span><br><span class="line">    <span class="keyword">delete</span> [] m_pChars;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">StringRep</span>(<span class="type">const</span> StringRep &amp;sr)&#123;</span><br><span class="line">    <span class="type">int</span> len = sr.<span class="built_in">length</span>();</span><br><span class="line">    m_pChars = <span class="keyword">new</span> <span class="type">char</span>[len+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_pChars,sr.m_pChars);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(m_pChars);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">equal</span><span class="params">(<span class="type">const</span> StringRep &amp;sp)</span><span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">strcmp</span>(m_pChars,sp.m_pChars)==<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* m_pChars;</span><br><span class="line">    StringRep &amp;<span class="keyword">operator</span>=()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;StringRep&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UCPointer&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *s):<span class="built_in">m_rep</span>(<span class="number">0</span>)&#123;</span><br><span class="line">  m_rep = <span class="keyword">new</span> <span class="built_in">StringRep</span>(s);</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">String</span>()&#123;&#125;</span><br><span class="line">  <span class="built_in">String</span>(<span class="type">const</span> String &amp;s):<span class="built_in">m_rep</span>(s.m_rep)&#123;&#125;;</span><br><span class="line">  String &amp;<span class="keyword">operator</span>=(<span class="type">const</span> String &amp;s)&#123;</span><br><span class="line">    m_rep = s.m_rep;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> <span class="keyword">operator</span>==(<span class="type">const</span> String&amp; s) <span class="type">const</span> &#123;</span><br><span class="line">      <span class="comment">// overloaded -&gt; forwards to StringRep   </span></span><br><span class="line">      <span class="keyword">return</span> m_rep-&gt;<span class="built_in">equal</span>(*s.m_rep); <span class="comment">// smart ptr * </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> m_rep-&gt;<span class="built_in">length</span>(); </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  UCPointer&lt;StringRep&gt; m_rep;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="WK15"><a href="#WK15" class="headerlink" title="WK15"></a>WK15</h2><h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><p>输入输出流，原始的C的IO使用printf和scanf，stream在C++中使用，但是C的IO仍可使用。</p>
<p>Stream的优点：type safety、Extensible、More object-oriented。</p>
<p>Stream的缺点：比较啰嗦、比较慢</p>
<h3 id="1-1-C-VS-C"><a href="#1-1-C-VS-C" class="headerlink" title="1.1 C++ VS C"></a>1.1 C++ VS C</h3><p>可以只使用C也可以使用C++，但是不能混用</p>
<h3 id="1-2-Stream"><a href="#1-2-Stream" class="headerlink" title="1.2 Stream"></a>1.2 Stream</h3><p>什么是流：</p>
<ol>
<li>Common logical interface to a device</li>
<li>Sequential</li>
<li>Can：produce values、consume values</li>
</ol>
<img src="/Learning/OOP%E7%AC%94%E8%AE%B0/image-20220610102726386.png">

<p>流的分类：</p>
<ol>
<li>Text streams<ol>
<li>Deal in ASCII text</li>
<li>Perform some character translation</li>
<li>Include</li>
</ol>
</li>
<li>Binary streams<ol>
<li>Binary data</li>
<li>No translations</li>
</ol>
</li>
</ol>
<h3 id="1-3-Predefine-streams"><a href="#1-3-Predefine-streams" class="headerlink" title="1.3 Predefine streams"></a>1.3 Predefine streams</h3><ul>
<li>cin：standard input</li>
<li>cout：standard output</li>
<li>cerr：unbuffered error（debugging）output<ul>
<li>需要定向到一个地方，在程序的输入输出之外有一个其他地方输出可以看内部的东西</li>
</ul>
</li>
<li>clog：buffered error（debugging）output</li>
</ul>
<h3 id="1-4-Other-input-operators"><a href="#1-4-Other-input-operators" class="headerlink" title="1.4 Other input operators"></a>1.4 Other input operators</h3><ul>
<li><p>int get( )</p>
<p>Returns the next character in the stream </p>
<p>Returns EOF if no characters left </p>
<p>Example: copy input to output</p>
</li>
<li><p>istream &amp; get (char&amp; ch)这里有隐藏的参数this</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin&gt;&gt;<span class="built_in">get</span>(&amp;c);</span><br></pre></td></tr></table></figure>

<img src="/Learning/OOP%E7%AC%94%E8%AE%B0/image-20220610105053660.png">

<p>get( )不读回车<img src="/Learning/OOP%E7%AC%94%E8%AE%B0/image-20220610105144156.png"></p>
</li>
</ul>
<h3 id><a href="#" class="headerlink" title></a></h3><h3 id="1-5-Formatting"><a href="#1-5-Formatting" class="headerlink" title="1.5 Formatting"></a>1.5 Formatting</h3><p>头文件：iomanipint n; </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;enter number in hexadecimal&quot;</span>  &lt;&lt; flush; </span><br><span class="line">cin &gt;&gt; hex &gt;&gt; n;</span><br></pre></td></tr></table></figure>

<img src="/Learning/OOP%E7%AC%94%E8%AE%B0/image-20220610110447910.png">

<img src="/Learning/OOP%E7%AC%94%E8%AE%B0/image-20220610111058749.png">

<img src="/Learning/OOP%E7%AC%94%E8%AE%B0/image-20220610111134200.png">



<img src="/Learning/OOP%E7%AC%94%E8%AE%B0/image-20220610111516092.png">


        <hr>
        <!-- Pager -->
        <ul class="pager">
          
          <li class="previous">
            <a href="/Learning/ADS笔记/" data-toggle="tooltip" data-placement="top" title="ADS笔记">&larr; Previous Post</a>
          </li>
          
          
          <li class="next">
            <a href="/Learning/数据库系统笔记/" data-toggle="tooltip" data-placement="top" title="数据库系统笔记">Next Post &rarr;</a>
          </li>
          
        </ul>

        
        <!-- tip start -->
        <!-- tip -->
<!-- tip start -->
<div class="tip">
  <p>
    
      如果您喜欢此博客或发现它对您有用，则欢迎对此发表评论。 也欢迎您共享此博客，以便更多人可以参与。 如果博客中使用的图像侵犯了您的版权，请与作者联系以将其删除。 谢谢 ！
    
  </p>
</div>
<!-- tip end -->

        <!-- tip end -->
        

        
        <!-- Sharing Srtart -->
        <!-- Social Social Share Post -->
<!-- Docs:https://github.com/overtrue/share.js -->

<div class="social-share" data-initialized="true" data-disabled="tencent ,douban ,qzone ,linkedin ,facebook ,google ,diandian" data-wechat-qrcode-helper="" align="center">
  <ul class="list-inline text-center social-share-ul">
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon icon-twitter">
        <i class="fa fa-twitter fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a class="social-share-icon icon-wechat">
        <i class="fa fa-weixin fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon icon-weibo">
        <i class="fa fa-weibo fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon icon-qq">
        <i class="fa fa-qq fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon" href="mailto:?subject=OOP笔记&body=Hi,I found this website and thought you might like it http://Hualingz.cn/Learning/OOP笔记/">
        <i class="fa fa-envelope fa-1x" aria-hidden="true"></i>
      </a>
    </li>
  </ul>
</div>

<!-- css & js -->
<!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css"> -->
<script defer="defer" async="true" src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>

        <!-- Sharing End -->
        
        <hr>

        <!-- comments start -->
        <!-- 1. gitalk comment -->

  <!-- gitalk start -->
  <!-- Docs:https://github.com/gitalk/gitalk/blob/master/readme-cn.md -->

  <div id="gitalk-container"></div>

  
    <!-- <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.js"></script> -->
    <script src="/js/comment/gitalk.js"></script>
  

  <script>
    var gitalk = new Gitalk({
      clientID: '',
      clientSecret: '',
      repo: '',
      owner: '',
      admin: '',
      id: 'Sun Jun 26 2022 00:30:17 GMT+0800', // Ensure uniqueness and length less than 50
      distractionFreeMode: false, // Facebook-like distraction free mode
      perPage: 10,
      pagerDirection: 'last',
      createIssueManually: false,
      language: 'en',
      proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token'
    });
    gitalk.render('gitalk-container');

    var gtFolded = () => {
      setTimeout(function () {
        let markdownBody = document.getElementsByClassName("markdown-body");
        let list = Array.from(markdownBody);
        list.forEach(item => {
          if (item.clientHeight > 250) {
            item.classList.add('gt-comment-body-folded');
            item.style.maxHeight = '250px';
            item.title = 'Click to Expand';
            item.onclick = function () {
              item.classList.remove('gt-comment-body-folded');
              item.style.maxHeight = '';
              item.title = '';
              item.onclick = null;
            };
          }
        })
      }, 800);
    }
  </script>

  <!-- gitalk end -->


<!-- 2. gitment comment -->


<!-- 3. disqus comment -->


        <!-- comments end -->
        <hr>

      </div>

      <!-- Catalog: Tabe of Content -->
      <!-- Table of Contents -->

    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">目录</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#OOP"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">OOP</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#WK1"><span class="toc-nav-number">1.1.</span> <span class="toc-nav-text">WK1</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-Buzzwords"><span class="toc-nav-number">1.1.1.</span> <span class="toc-nav-text">1. Buzzwords</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-Assessment"><span class="toc-nav-number">1.1.2.</span> <span class="toc-nav-text">2. Assessment</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-Introduction-to-C"><span class="toc-nav-number">1.1.3.</span> <span class="toc-nav-text">3. Introduction to C++</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-C-%E5%9C%A8C%E4%B8%8A%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-nav-number">1.1.4.</span> <span class="toc-nav-text">4. C++在C上的改进</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-C"><span class="toc-nav-number">1.1.5.</span> <span class="toc-nav-text">5. C++</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-My-first-C-Program"><span class="toc-nav-number">1.1.6.</span> <span class="toc-nav-text">6. My first C++ Program</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#7-String"><span class="toc-nav-number">1.1.7.</span> <span class="toc-nav-text">7.  String</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#WK2"><span class="toc-nav-number">1.2.</span> <span class="toc-nav-text">WK2</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-nav-number">1.2.1.</span> <span class="toc-nav-text">1. 对象的指针</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-1-%E5%9F%BA%E7%A1%80%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-nav-number">1.2.1.1.</span> <span class="toc-nav-text">1.1 基础的操作</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-2-%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1"><span class="toc-nav-number">1.2.1.2.</span> <span class="toc-nav-text">1.2 访问对象</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%B5%8B%E5%80%BC"><span class="toc-nav-number">1.2.1.3.</span> <span class="toc-nav-text">1.3 对象的赋值</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-4-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7"><span class="toc-nav-number">1.2.1.4.</span> <span class="toc-nav-text">1.4 动态内存申请</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-nav-number">1.2.2.</span> <span class="toc-nav-text">2. 对象的引用</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB"><span class="toc-nav-number">1.2.3.</span> <span class="toc-nav-text">3. 对象与类</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-1-Point"><span class="toc-nav-number">1.2.3.1.</span> <span class="toc-nav-text">3.1 Point</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-%E5%AF%B9%E8%B1%A1"><span class="toc-nav-number">1.2.4.</span> <span class="toc-nav-text">4. 对象</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-1-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-nav-number">1.2.4.1.</span> <span class="toc-nav-text">4.1 对象的定义</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-2-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%BB%93%E6%9E%84"><span class="toc-nav-number">1.2.4.2.</span> <span class="toc-nav-text">4.2 对象与结构</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-3-this%E6%8C%87%E9%92%88"><span class="toc-nav-number">1.2.4.3.</span> <span class="toc-nav-text">4.3 this指针</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#WK3"><span class="toc-nav-number">1.3.</span> <span class="toc-nav-text">WK3</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-%E4%BE%8B%E5%AD%90Ticket-Machine"><span class="toc-nav-number">1.3.1.</span> <span class="toc-nav-text">1. 例子Ticket Machine</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-1-Object-%E5%92%8CClass%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-nav-number">1.3.1.1.</span> <span class="toc-nav-text">1.1 Object 和Class的区别</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-2-OOP-Characteristics"><span class="toc-nav-number">1.3.1.2.</span> <span class="toc-nav-text">1.2 OOP Characteristics</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-3-C%E2%80%99tor-and-D%E2%80%99tor"><span class="toc-nav-number">1.3.1.3.</span> <span class="toc-nav-text">1.3 C’tor and D’tor</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-Class-%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-nav-number">1.3.2.</span> <span class="toc-nav-text">2. Class 类的定义</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-1%E6%96%87%E4%BB%B6"><span class="toc-nav-number">1.3.2.1.</span> <span class="toc-nav-text">2.1文件</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#WK4"><span class="toc-nav-number">1.4.</span> <span class="toc-nav-text">WK4</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-C-Program%E7%9A%84structure"><span class="toc-nav-number">1.4.1.</span> <span class="toc-nav-text">1. C++Program的structure</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-Standard-header-file-structure"><span class="toc-nav-number">1.4.2.</span> <span class="toc-nav-text">2. Standard header file structure</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-1-tips"><span class="toc-nav-number">1.4.2.1.</span> <span class="toc-nav-text">2.1 tips</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-Abstract"><span class="toc-nav-number">1.4.3.</span> <span class="toc-nav-text">3. Abstract</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-%E5%AD%97%E6%AE%B5fields%EF%BC%8C%E5%8F%82%E6%95%B0parameters%EF%BC%8C%E6%9C%AC%E5%9C%B0%E5%8F%98%E9%87%8Flocal-variable"><span class="toc-nav-number">1.4.4.</span> <span class="toc-nav-text">4. 字段fields，参数parameters，本地变量local variable</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-Initialization%E5%92%8Cassignment"><span class="toc-nav-number">1.4.5.</span> <span class="toc-nav-text">5. Initialization和assignment</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#5-1-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-nav-number">1.4.5.1.</span> <span class="toc-nav-text">5.1 函数重载</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#5-2-%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E7%BC%BA%E7%9C%81"><span class="toc-nav-number">1.4.5.2.</span> <span class="toc-nav-text">5.2 默认参数缺省</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-Container"><span class="toc-nav-number">1.4.6.</span> <span class="toc-nav-text">6.  Container</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#WK5"><span class="toc-nav-number">1.5.</span> <span class="toc-nav-text">WK5</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-vector"><span class="toc-nav-number">1.5.1.</span> <span class="toc-nav-text">1. vector</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-1-%E5%AE%9A%E4%B9%89"><span class="toc-nav-number">1.5.1.1.</span> <span class="toc-nav-text">1.1 定义</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-2-%E7%89%B9%E6%80%A7"><span class="toc-nav-number">1.5.1.2.</span> <span class="toc-nav-text">1.2 特性</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-3-%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-nav-number">1.5.1.3.</span> <span class="toc-nav-text">1.3 基本的函数</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-list%E9%93%BE%E8%A1%A8"><span class="toc-nav-number">1.5.2.</span> <span class="toc-nav-text">2. list链表</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-1-%E5%AE%9A%E4%B9%89"><span class="toc-nav-number">1.5.2.1.</span> <span class="toc-nav-text">2.1 定义</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-map"><span class="toc-nav-number">1.5.3.</span> <span class="toc-nav-text">3. map</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-1-%E5%AE%9A%E4%B9%89"><span class="toc-nav-number">1.5.3.1.</span> <span class="toc-nav-text">3.1 定义</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-2-%E6%93%8D%E4%BD%9C"><span class="toc-nav-number">1.5.3.2.</span> <span class="toc-nav-text">3.2 操作</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Tips%EF%BC%9A"><span class="toc-nav-number">1.5.3.3.</span> <span class="toc-nav-text">Tips：</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E3%80%90%E8%BF%AD%E4%BB%A3%E5%99%A8%E3%80%91"><span class="toc-nav-number">1.5.3.4.</span> <span class="toc-nav-text">【迭代器】</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-Function"><span class="toc-nav-number">1.5.4.</span> <span class="toc-nav-text">4. Function</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-1%E7%94%9F%E5%AD%98%E6%9C%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-nav-number">1.5.4.1.</span> <span class="toc-nav-text">4.1生存期和作用域</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-2-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0"><span class="toc-nav-number">1.5.4.2.</span> <span class="toc-nav-text">4.2 生成函数</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-3-%E9%87%8D%E8%BD%BDoverload"><span class="toc-nav-number">1.5.4.3.</span> <span class="toc-nav-text">4.3 重载overload</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-4-%E9%BB%98%E8%AE%A4%E5%87%BD%E6%95%B0default-argument"><span class="toc-nav-number">1.5.4.4.</span> <span class="toc-nav-text">4.4 默认函数default argument</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-Friends"><span class="toc-nav-number">1.5.5.</span> <span class="toc-nav-text">5. Friends</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-class%E5%92%8Cstruct%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-nav-number">1.5.6.</span> <span class="toc-nav-text">6. class和struct的区别</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#7-Function%E7%9A%84Way-in"><span class="toc-nav-number">1.5.6.1.</span> <span class="toc-nav-text">7. Function的Way in</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#8-Function%E7%9A%84Way-out"><span class="toc-nav-number">1.5.6.2.</span> <span class="toc-nav-text">8. Function的Way out</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E3%80%90tips%E3%80%91"><span class="toc-nav-number">1.5.6.3.</span> <span class="toc-nav-text">【tips】</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#WK6"><span class="toc-nav-number">1.6.</span> <span class="toc-nav-text">WK6</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0Inline-Function"><span class="toc-nav-number">1.6.1.</span> <span class="toc-nav-text">1. 内联函数Inline Function</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8Inline%EF%BC%9F"><span class="toc-nav-number">1.6.1.1.</span> <span class="toc-nav-text">1.1 什么时候用Inline？</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-2-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%8D%E7%94%A8Inline%EF%BC%9F"><span class="toc-nav-number">1.6.1.2.</span> <span class="toc-nav-text">1.2 什么时候不用Inline？</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-3-A-lazy-way"><span class="toc-nav-number">1.6.1.3.</span> <span class="toc-nav-text">1.3 A lazy way</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-Const"><span class="toc-nav-number">1.6.2.</span> <span class="toc-nav-text">2. Const</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-1-%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-nav-number">1.6.2.1.</span> <span class="toc-nav-text">2.1 定义：</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-2-%E6%8C%87%E9%92%88%E7%9A%84const"><span class="toc-nav-number">1.6.2.2.</span> <span class="toc-nav-text">2.2 指针的const</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-3-%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84const"><span class="toc-nav-number">1.6.2.3.</span> <span class="toc-nav-text">2.3 对象中的const</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#2-3-1-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84const"><span class="toc-nav-number">1.6.2.3.1.</span> <span class="toc-nav-text">2.3.1 成员函数的const</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#2-3-2-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84const"><span class="toc-nav-number">1.6.2.3.2.</span> <span class="toc-nav-text">2.3.2 成员变量的const</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-4-tips"><span class="toc-nav-number">1.6.2.4.</span> <span class="toc-nav-text">2.4 tips</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-5-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E5%B8%B8%E6%95%B0"><span class="toc-nav-number">1.6.2.5.</span> <span class="toc-nav-text">2.5 运行时的常数</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-6-const%E7%9A%84%E8%81%9A%E5%90%88"><span class="toc-nav-number">1.6.2.6.</span> <span class="toc-nav-text">2.6 const的聚合</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-7-Const-Object"><span class="toc-nav-number">1.6.2.7.</span> <span class="toc-nav-text">2.7 Const Object</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-static"><span class="toc-nav-number">1.6.3.</span> <span class="toc-nav-text">3. static</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#WK7"><span class="toc-nav-number">1.7.</span> <span class="toc-nav-text">WK7</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-1-namespace"><span class="toc-nav-number">1.7.1.</span> <span class="toc-nav-text">1.1 namespace</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-3-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-nav-number">1.7.1.1.</span> <span class="toc-nav-text">2.3 构造函数的继承</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-4-public%EF%BC%8Cprivate%EF%BC%8Cprotected%E7%BB%A7%E6%89%BF"><span class="toc-nav-number">1.7.1.2.</span> <span class="toc-nav-text">2.4 public，private，protected继承</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#WK8"><span class="toc-nav-number">1.8.</span> <span class="toc-nav-text">WK8</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-%E5%A4%9A%E6%80%81"><span class="toc-nav-number">1.8.1.</span> <span class="toc-nav-text">1. 多态</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-1-Up-casting"><span class="toc-nav-number">1.8.1.1.</span> <span class="toc-nav-text">1.1 Up-casting</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-2-virtual-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-nav-number">1.8.1.2.</span> <span class="toc-nav-text">1.2 virtual 关键字</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-3-A-drawing-program"><span class="toc-nav-number">1.8.1.3.</span> <span class="toc-nav-text">1.3 A drawing program</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-4-%E9%82%A6%E5%AE%9Abinding"><span class="toc-nav-number">1.8.1.4.</span> <span class="toc-nav-text">1.4 邦定binding</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-5-Virtual-destructors-%E8%99%9A%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-nav-number">1.8.1.5.</span> <span class="toc-nav-text">1.5 Virtual destructors 虚的析构函数</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-6-Overriding"><span class="toc-nav-number">1.8.1.6.</span> <span class="toc-nav-text">1.6 Overriding</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-7-Virtual-in-Ctor"><span class="toc-nav-number">1.8.1.7.</span> <span class="toc-nav-text">1.7 Virtual in Ctor</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-8-Abstract-base-classes-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-nav-number">1.8.1.8.</span> <span class="toc-nav-text">1.8 Abstract base classes 抽象类</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-9-%E6%8E%A5%E5%8F%A3%E7%B1%BBProtocol-x2F-Interface-classes"><span class="toc-nav-number">1.8.1.9.</span> <span class="toc-nav-text">1.9 接口类Protocol &#x2F; Interface classes</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-10-%E5%A4%9A%E7%B1%BB%E7%BB%A7%E6%89%BF"><span class="toc-nav-number">1.8.1.10.</span> <span class="toc-nav-text">1.10 多类继承</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E3%80%90%E6%B3%A8%E6%84%8F%E3%80%91%E8%99%9A%E8%A1%A8"><span class="toc-nav-number">1.8.1.11.</span> <span class="toc-nav-text">【注意】虚表</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E3%80%90%E6%B3%A8%E6%84%8F%E3%80%91%E7%B1%BB%E7%9A%84sizeof"><span class="toc-nav-number">1.8.1.12.</span> <span class="toc-nav-text">【注意】类的sizeof</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#WK9"><span class="toc-nav-number">1.9.</span> <span class="toc-nav-text">WK9</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-Copy-Ctor-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0"><span class="toc-nav-number">1.9.1.</span> <span class="toc-nav-text">1. Copy Ctor 拷贝构造</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-1-Copying"><span class="toc-nav-number">1.9.1.1.</span> <span class="toc-nav-text">1.1 Copying</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#WK10"><span class="toc-nav-number">1.10.</span> <span class="toc-nav-text">WK10</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%B0%83%E7%94%A8"><span class="toc-nav-number">1.10.1.</span> <span class="toc-nav-text">1. 复制构造什么时候调用</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-1-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E8%B5%8B%E5%80%BC"><span class="toc-nav-number">1.10.1.1.</span> <span class="toc-nav-text">1.1 拷贝构造和赋值</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-nav-number">1.10.2.</span> <span class="toc-nav-text">2. 运算符重载</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-1-%E9%99%90%E5%88%B6"><span class="toc-nav-number">1.10.2.1.</span> <span class="toc-nav-text">2.1 限制</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-2-%E5%A6%82%E4%BD%95%E5%86%99%EF%BC%9F"><span class="toc-nav-number">1.10.2.2.</span> <span class="toc-nav-text">2.2 如何写？</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-3-%E6%88%90%E5%91%98or%E5%85%A8%E5%B1%80%EF%BC%9F"><span class="toc-nav-number">1.10.2.3.</span> <span class="toc-nav-text">2.3 成员or全局？</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-4-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%92%8C%E2%80%93%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-nav-number">1.10.2.4.</span> <span class="toc-nav-text">2.4 ++操作符和–操作符</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-5-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-nav-number">1.10.2.5.</span> <span class="toc-nav-text">2.5 关系运算符</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-6-%E6%93%8D%E4%BD%9C%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-nav-number">1.10.2.6.</span> <span class="toc-nav-text">2.6 [ ]操作运算符</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-2-Inserter"><span class="toc-nav-number">1.10.2.7.</span> <span class="toc-nav-text">1.2 Inserter</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-3-endl%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-nav-number">1.10.2.8.</span> <span class="toc-nav-text">1.3 endl是什么</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-Copying-vs-Initialization"><span class="toc-nav-number">1.10.3.</span> <span class="toc-nav-text">2. Copying vs Initialization</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-nav-number">1.10.4.</span> <span class="toc-nav-text">3. 赋值运算符的重载</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-Value-classes"><span class="toc-nav-number">1.10.5.</span> <span class="toc-nav-text">4. Value classes</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-1-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-nav-number">1.10.5.1.</span> <span class="toc-nav-text">4.1 类型转换</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-nav-number">1.10.6.</span> <span class="toc-nav-text">5. 对象初始化</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#5-1-%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-nav-number">1.10.6.1.</span> <span class="toc-nav-text">5.1 列表初始化</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#5-2-%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-nav-number">1.10.6.2.</span> <span class="toc-nav-text">5.2 容器初始化</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-nav-number">1.10.7.</span> <span class="toc-nav-text">6. 函数的参数和返回值</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#6-1-Way-in"><span class="toc-nav-number">1.10.7.1.</span> <span class="toc-nav-text">6.1 Way in</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#6-2-Way-out"><span class="toc-nav-number">1.10.7.2.</span> <span class="toc-nav-text">6.2 Way out</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#6-3-Tips"><span class="toc-nav-number">1.10.7.3.</span> <span class="toc-nav-text">6.3 Tips</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#7-%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC"><span class="toc-nav-number">1.10.8.</span> <span class="toc-nav-text">7. 左值和右值</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#7-1-%E5%8F%B3%E5%80%BC%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-nav-number">1.10.8.1.</span> <span class="toc-nav-text">7.1 右值的引用</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#8-%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0"><span class="toc-nav-number">1.10.9.</span> <span class="toc-nav-text">8. 移动构造</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#WK12"><span class="toc-nav-number">1.11.</span> <span class="toc-nav-text">WK12</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-%E6%A8%A1%E6%9D%BFTemplate"><span class="toc-nav-number">1.11.1.</span> <span class="toc-nav-text">1. 模板Template</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E6%9D%BF"><span class="toc-nav-number">1.11.1.1.</span> <span class="toc-nav-text">1.1 什么是模板</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-2-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-nav-number">1.11.1.2.</span> <span class="toc-nav-text">1.2 函数模板</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-3-%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-nav-number">1.11.1.3.</span> <span class="toc-nav-text">1.3 类模板</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-4-Tips"><span class="toc-nav-number">1.11.1.4.</span> <span class="toc-nav-text">1.4 Tips</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#WK13"><span class="toc-nav-number">1.12.</span> <span class="toc-nav-text">WK13</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-Exceptions-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-nav-number">1.12.1.</span> <span class="toc-nav-text">1. Exceptions 异常处理</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-1-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-nav-number">1.12.1.1.</span> <span class="toc-nav-text">1.1 异常处理的语法</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-2-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-nav-number">1.12.1.2.</span> <span class="toc-nav-text">1.2 异常处理的过程</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-3-Try-block"><span class="toc-nav-number">1.12.1.3.</span> <span class="toc-nav-text">1.3  Try block</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-4-new%E7%9A%84exception"><span class="toc-nav-number">1.12.1.4.</span> <span class="toc-nav-text">1.4 new的exception</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E3%80%90C-%E4%B8%AD%E8%87%AA%E5%B8%A6%E7%9A%84%E5%BC%82%E5%B8%B8%E7%9A%84%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%EF%BC%8C%E5%AE%9A%E4%B9%89%E5%9C%A8%E5%A4%B4%E6%96%87%E4%BB%B6-lt-exception-gt-%E4%B8%AD%E3%80%91"><span class="toc-nav-number">1.12.1.5.</span> <span class="toc-nav-text">【C++中自带的异常的继承体系，定义在头文件 &lt;exception&gt; 中】</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-5-%E5%87%BD%E6%95%B0%E5%90%8E%E9%9D%A2%E5%8A%A0throw"><span class="toc-nav-number">1.12.1.6.</span> <span class="toc-nav-text">1.5 函数后面加throw()</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#WK14"><span class="toc-nav-number">1.13.</span> <span class="toc-nav-text">WK14</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-An-Example"><span class="toc-nav-number">1.13.1.</span> <span class="toc-nav-text">1. An Example</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-1-Goal"><span class="toc-nav-number">1.13.1.1.</span> <span class="toc-nav-text">1.1 Goal</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#Reference-counting"><span class="toc-nav-number">1.13.1.1.1.</span> <span class="toc-nav-text">Reference counting</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#Reusing-Reference-Counting"><span class="toc-nav-number">1.13.1.1.2.</span> <span class="toc-nav-text">Reusing Reference Counting</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#UCPointer"><span class="toc-nav-number">1.13.1.1.3.</span> <span class="toc-nav-text">UCPointer</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#String-Rep"><span class="toc-nav-number">1.13.1.1.4.</span> <span class="toc-nav-text">String Rep</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#String"><span class="toc-nav-number">1.13.1.1.5.</span> <span class="toc-nav-text">String</span></a></li></ol></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#WK15"><span class="toc-nav-number">1.14.</span> <span class="toc-nav-text">WK15</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Stream"><span class="toc-nav-number">1.14.1.</span> <span class="toc-nav-text">Stream</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-1-C-VS-C"><span class="toc-nav-number">1.14.2.</span> <span class="toc-nav-text">1.1 C++ VS C</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-2-Stream"><span class="toc-nav-number">1.14.3.</span> <span class="toc-nav-text">1.2 Stream</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-3-Predefine-streams"><span class="toc-nav-number">1.14.4.</span> <span class="toc-nav-text">1.3 Predefine streams</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-4-Other-input-operators"><span class="toc-nav-number">1.14.5.</span> <span class="toc-nav-text">1.4 Other input operators</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">1.14.6.</span> <span class="toc-nav-text"></span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-5-Formatting"><span class="toc-nav-number">1.14.7.</span> <span class="toc-nav-text">1.5 Formatting</span></a></li></ol></li></ol></li></ol>
        
        </div>
      </aside>
    



      <!-- Sidebar Container -->
      <div class="
                col-lg-8 col-lg-offset-1
                col-md-10 col-md-offset-1
                sidebar-container">

        <!-- Featured Tags -->
        
        <section>
          <!-- no hr -->
          <h5>
            <a href="/tags/">特色标签</a>
          </h5>
          <div class="tags">
            
            <a class="tag" href="/tags/#浙江大学" title="浙江大学">浙江大学</a>
            
            <a class="tag" href="/tags/#OOP" title="OOP">OOP</a>
            
          </div>
        </section>
        

        <!-- Friends Blog -->
        
        <hr>
        <h5>链友</h5>
        <ul class="list-inline">

          
        </ul>
        
      </div>
    </div>
  </div>
</article>



<!-- anchorjs start -->
<!-- async load function -->
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script type="text/javascript">
  // async load function
  function async (u, c) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) {
      o.addEventListener('load', function(e) {
        c(null, e);
      }, false);
    }
    s.parentNode.insertBefore(o, s);
  };
</script>
<script type="text/javascript">
  //anchor-js, Doc:http://bryanbraun.github.io/anchorjs/
  async ("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js", function() {
    anchors.options = {
      visible: 'hover',
      placement: 'left',
      // icon: 'ℬ'
      icon: '❡'
    };
    anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
  });
</script>
<style>
  /* place left on bigger screen */
  @media all and (min-width: 800px) {
    .anchorjs-link {
      position: absolute;
      left: -0.75em;
      font-size: 1.1em;
      margin-top: -0.1em;
    }
  }
</style>

<!-- anchorjs end -->



		<!-- Footer (contains ThemeColor、viewer) -->
		<!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center">
          

          
            <li>
              <a target="_blank" href="https://github.com/Hualeez">
                <span class="fa-stack fa-lg">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
          

          

          

          

          

          

          

        </ul>
        <p class="copyright text-muted">
          Copyright &copy;
          Hualingz
          2022
          <br>
          Theme by
          <a target="_blank" rel="noopener" href="http://beantech.org">BeanTech</a>
          <span style="display: inline-block; margin: 0 5px;">
            <i class="fa fa-heart"></i>
          </span>
          re-Ported by
          <a target="_blank" rel="noopener" href="https://v-vincen.life/">Live My Life</a>
          |
          <iframe style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0" width="91px" height="20px" src="https://ghbtns.com/github-btn.html?user=V-Vincen&repo=V-Vincen.github.io&type=star&count=true"></iframe>
        </p>
      </div>
    </div>
  </div>
</footer>

<a id="rocket" href="#top" class=""></a>


  <!-- jQuery -->
  <script type="text/javascript" src="/js/jquery.min.js"></script>
  <!-- Bootstrap Core JavaScript -->
  <script type="text/javascript" src="/js/bootstrap.min.js"></script>
  <!-- Custom Theme JavaScript -->
  <script type="text/javascript" src="/js/hux-blog.min.js"></script>
  <!-- catalog -->
  <script async="true" type="text/javascript" src="/js/catalog.js"></script>
  <!-- totop(rocket) -->
  <script async="true" type="text/javascript" src="/js/totop.js"></script>

  
    <!-- Busuanzi JavaScript -->
    <script async="async" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <!-- Scroll start -->
    <script async="async" type="text/javascript" src="/js/scroll.js"></script>
    <!-- Scroll end -->
  

  
    <!-- LangSelect start -->
    <script type="text/javascript" src="/js/langselect.js"></script>
    <!-- LangSelect end -->
  

  
    <!-- Mouseclick -->
    <script type="text/javascript" src="/js/mouseclick.js" content='The first step is as good as half over...,Laugh and grow fat...,Man proposes God disposes...,When all else is lost the future still remains...,Wasting time is robbing oneself...,Sharp tools make good work...,Cease to struggle and you cease to live...,A friend in need is a friend indeed...,Faith can move mountains...' color='#9933CC,#339933,#66CCCC,#FF99CC,#CCCCFF,#6666CC,#663399,#66CC99,#FF0033'></script>
  

  
    <!-- ribbon -->
    <script type="text/javascript" src="/js/ribbonDynamic.js"></script>
  

  






  <!-- viewer start -->
  <!-- viewer start (Picture preview) -->
  
    <script async="async" type="text/javascript" src="/js/viewer/viewer.min.js"></script>
    <script async="async" type="text/javascript" src="/js/viewer/pic-viewer.js"></script>
  

  <!-- viewer end -->


<script>
  // async load function
  function async (u, c) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) {
      o.addEventListener('load', function (e) {
        c(null, e);
      }, false);
    }
    s.parentNode.insertBefore(o, s);
  }

  // fastClick.js
  async ("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function () {
    var $nav = document.querySelector("nav");
    if ($nav)
      FastClick.attach($nav);
    }
  )
</script>

<!-- Because of the native support for backtick-style fenced code blocks right within the Markdown is landed in Github Pages, From V1.6, There is no need for Highlight.js, so Huxblog drops it officially. -
https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0 - https://help.github.com/articles/creating-and-highlighting-code-blocks/ -->
<!-- <script> async ("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function () { hljs.initHighlightingOnLoad(); }) </script> <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet"> -->

<!-- jquery.tagcloud.js -->
<!-- <script> // only load tagcloud.js in tag.html if ($('#tag_cloud').length !== 0) { async ("http://Hualingz.cn/js/jquery.tagcloud.js", function () { $.fn.tagcloud.defaults = { // size: { start: 1, end: 1, unit: 'em' }, color: {
start: '#bbbbee', end: '#0085a1' } }; $('#tag_cloud a').tagcloud(); }) } </script> -->


		<!-- Search -->
		
		<div class="popup search-popup local-search-popup">
  <span class="popup-btn-close">
    ESC
  </span>
  <div class="container">
    <div class="row">
      <!-- <div class="col-md-9 col-md-offset-1"> -->
      <div class="col-lg-9 col-lg-offset-1 col-md-10 col-md-offset-1 local-search-content">

        <div class="local-search-header clearfix">

          <div class="local-search-input-wrapper">
            <span class="search-icon">
              <i class="fa fa-search fa-lg" style="margin: 25px 10px 25px 20px;"></i>
            </span>
            <input autocomplete="off" placeholder="搜索..." type="text" id="local-search-input">
          </div>
        </div>
        <div id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>


  
    <script src="/js/ziploader.js"></script>
  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.json";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    // monitor main search box;
    var onPopupClose = function (e) {
      $('.popup').fadeOut(300);
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $('.popup').fadeIn(300);
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }
    // get search zip version
    $.get('/searchVersion.json?t=' + (+new Date()), function (res) {
      if (localStorage.getItem('searchVersion') !== res) {
        localStorage.setItem('searchVersion', res);
        initSearchJson();
      }
    });

    function initSearchJson() {
      initLoad(['/search.flv'], {
        loadOptions: {
          success: function (obj) {
            localStorage.setItem('searchJson', obj['search.json'])
          },
          error: function (e) {
            return console.log(e)
          }
        },
        returnOptions: {
          'json': TYPE_TEXT
        },
        mimeOptions: {
          'json': 'application/json'
        }
      })
    }
    // search function;
    var searchFunc = function (search_id, content_id) {
      'use strict';
      isfetched = true;
      var datas = JSON.parse(localStorage.getItem('searchJson'));
      // console.log(search_id)
      var input = document.getElementById(search_id);
      var resultContent = document.getElementById(content_id);
      var inputEventFunction = function () {
        var searchText = input.value.trim().toLowerCase();
        var keywords = searchText.split(/[\s\-]+/);
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        var resultItems = [];
        if (searchText.length > 0) {
          // perform local searching
          datas.forEach(function (data) {
            var isMatch = false;
            var hitCount = 0;
            var searchTextCount = 0;
            var title = data.title
              ? data.title.trim()
              : '';
            var titleInLowerCase = title.toLowerCase();
            var content = data.content
              ? data.content.trim().replace(/<[^>]+>/g, "")
              : '';
            var contentInLowerCase = content.toLowerCase();
            var articleUrl = decodeURIComponent(data.url);

            var date = data.date;
            var dateTime = date.replace(/T/, " ").replace(/.000Z/, "");
            var imgUrl = data.header_img;
            


            var indexOfTitle = [];
            var indexOfContent = [];
            // only match articles with not empty titles
            keywords.forEach(function (keyword) {
              function getIndexByWord(word, text, caseSensitive) {
                var wordLen = word.length;
                if (wordLen === 0) {
                  return [];
                }
                var startPosition = 0,
                  position = [],
                  index = [];
                if (!caseSensitive) {
                  text = text.toLowerCase();
                  word = word.toLowerCase();
                }
                while ((position = text.indexOf(word, startPosition)) > -1) {
                  index.push({position: position, word: word});
                  startPosition = position + wordLen;
                }
                return index;
              }
              indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
              indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
            });
            if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
              isMatch = true;
              hitCount = indexOfTitle.length + indexOfContent.length;
            }
            // show search results
            if (isMatch) {
              // sort index by position of keyword
              [indexOfTitle, indexOfContent].forEach(function (index) {
                index.sort(function (itemLeft, itemRight) {
                  if (itemRight.position !== itemLeft.position) {
                    return itemRight.position - itemLeft.position;
                  } else {
                    return itemLeft.word.length - itemRight.word.length;
                  }
                });
              });
              // merge hits into slices
              function mergeIntoSlice(text, start, end, index) {
                var item = index[index.length - 1];
                var position = item.position;
                var word = item.word;
                var hits = [];
                var searchTextCountInSlice = 0;
                while (position + word.length <= end && index.length != 0) {
                  if (word === searchText) {
                    searchTextCountInSlice++;
                  }
                  hits.push({position: position, length: word.length});
                  var wordEnd = position + word.length;
                  // move to next position of hit
                  index.pop();
                  while (index.length != 0) {
                    item = index[index.length - 1];
                    position = item.position;
                    word = item.word;
                    if (wordEnd > position) {
                      index.pop();
                    } else {
                      break;
                    }
                  }
                }
                searchTextCount += searchTextCountInSlice;
                return {hits: hits, start: start, end: end, searchTextCount: searchTextCountInSlice};
              }
              var slicesOfTitle = [];
              if (indexOfTitle.length != 0) {
                slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
              }
              var slicesOfContent = [];
              while (indexOfContent.length != 0) {
                var item = indexOfContent[indexOfContent.length - 1];
                var position = item.position;
                var word = item.word;
                // cut out 100 characters
                var start = position - 20;
                var end = position + 80;
                if (start < 0) {
                  start = 0;
                }
                if (end < position + word.length) {
                  end = position + word.length;
                }
                if (end > content.length) {
                  end = content.length;
                }
                slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
              }
              // sort slices in content by search text's count and hits' count
              slicesOfContent.sort(function (sliceLeft, sliceRight) {
                if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                  return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                  return sliceRight.hits.length - sliceLeft.hits.length;
                } else {
                  return sliceLeft.start - sliceRight.start;
                }
              });
              // select top N slices in content
              var upperBound = parseInt('1');
              if (upperBound >= 0) {
                slicesOfContent = slicesOfContent.slice(0, upperBound);
              }
              // highlight title and content
              function highlightKeyword(text, slice) {
                var result = '';
                var prevEnd = slice.start;
                slice.hits.forEach(function (hit) {
                  result += text.substring(prevEnd, hit.position);
                  var end = hit.position + hit.length;
                  result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                  prevEnd = end;
                });
                result += text.substring(prevEnd, slice.end);
                return result;
              }
              var resultItem = '';

              // if (slicesOfTitle.length != 0) {   resultItem += "<li><a target='_blank' href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>"; } else {   resultItem += "<li><a target='_blank' href='" +
              // articleUrl + "' class='search-result-title'>" + title + "</a>"; } slicesOfContent.forEach(function (slice) {   resultItem += "<a target='_blank' href='" + articleUrl + "'><p class=\"search-result\">" + highlightKeyword(content, slice) +
              // "...</p></a>"; }); resultItem += "</li>";

              if (slicesOfTitle.length != 0) {
                resultItem += "<a target='_blank' href='" + articleUrl + "' class='search-result'><div class='search-result-left'><div class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</div><time class='search-result-date'>" + dateTime + "</time>";
              } else {
                resultItem += "<a target='_blank' href='" + articleUrl + "' class='search-result'><div class='search-result-left'><div class='search-result-title'>" + title + "</div><time class='search-result-date'>" + dateTime + "</time>";
              }
              slicesOfContent.forEach(function (slice) {
                resultItem += "<p class=\"search-result-content\">" + highlightKeyword(content, slice) + "...</p>";
              });
              resultItem += "</div><div class='search-result-right'><img class='media-image' src='" + imgUrl + "' width='64px' height='48px'></img></div></a>";

              resultItems.push({item: resultItem, searchTextCount: searchTextCount, hitCount: hitCount, id: resultItems.length});
            }
          })
        };

        if (keywords.length === 1 && keywords[0] === "") {
          resultContent.innerHTML = '<div id="no-result"></div>'
        } else if (resultItems.length === 0) {
          resultContent.innerHTML = '<div id="no-result"></div>'
        } else {
          resultItems.sort(function (resultLeft, resultRight) {
            if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
              return resultRight.searchTextCount - resultLeft.searchTextCount;
            } else if (resultLeft.hitCount !== resultRight.hitCount) {
              return resultRight.hitCount - resultLeft.hitCount;
            } else {
              return resultRight.id - resultLeft.id;
            }
          });
          var searchResultList = '<div class=\"search-result-list\">';
          resultItems.forEach(function (result) {
            searchResultList += result.item;
          })
          searchResultList += "</div>";
          resultContent.innerHTML = searchResultList;
        }
      }
      if ('auto' === 'auto') {
        input.addEventListener('input', inputEventFunction);
      } else {
        $('.search-icon').click(inputEventFunction);
        input.addEventListener('keypress', function (event) {
          if (event.keyCode === 13) {
            inputEventFunction();
          }
        });
      }
      // remove loading animation
      $('body').css('overflow', '');
      proceedsearch();
    }
    // handle and trigger popup window;
    $('.popup-trigger').click(function (e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc('local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });
    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function (e) {
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 && $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });

    document.addEventListener('mouseup', (e) => {
      var _con = document.querySelector(".local-search-content");
      if (_con) {
        if (!_con.contains(e.target)) {
          onPopupClose();
        }
      }
    });
  </script>


		
	<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
