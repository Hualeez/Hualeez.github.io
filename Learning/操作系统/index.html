<!DOCTYPE html>
<html lang="en">

<!-- Head tag (contains Google-Analytics、Baidu-Tongji)-->
<head>
  <!-- Google Analytics -->
  
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-xxxxxx-xx"></script>
    <script type="text/javascript">
      window.dataLayer = window.dataLayer || [];

      function gtag() {
        dataLayer.push(arguments);
      }
      gtag('js', new Date());

      gtag('config', 'UA-xxxxxx-xx');
    </script>
  

  <!-- Baidu Tongji -->
  
    <script type="text/javascript">
      // Originial
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  <!-- Baidu Push -->
  
    <script>
      (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
      })();
    </script>
  

  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>

  <meta name="google-site-verification" content="lxDfCplOZbIzjhG34NuQBgu2gdyRlAtMB4utP5AgEBc"/>
  <meta name="baidu-site-verification" content="PpzM9WxOJU"/>

  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="description" content="这里是Hualingz，一个乐观主义者"/>
  <meta name="keyword" content="Hualingz,hualeez,hualingz,cyc"/>
  <link rel="shortcut icon" href="/img/avatar/fin_32.png"/>

  <!-- Place this tag in your head or just before your close body tag. -->
  <script async="async" defer="defer" src="https://buttons.github.io/buttons.js"></script>

  
    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css"/>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/beantech.min.css"/>

    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css"/>
    <link rel="stylesheet" href="/css/widget.css"/>
    <link rel="stylesheet" href="/css/rocket.css"/>
    <link rel="stylesheet" href="/css/signature.css"/>
    <link rel="stylesheet" href="/css/catalog.css"/>
    <link rel="stylesheet" href="/css/livemylife.css"/>

    
      <!-- wave start -->
      <link rel="stylesheet" href="/css/wave.css"/>
      <!-- wave end -->
    

    
      <!-- top start (article top hot config) -->
      <link rel="stylesheet" href="/css/top.css"/>
      <!-- top end -->
    

    
      <!-- ThemeColor start -->
      <link rel="stylesheet" href="/css/scroll.css"/>
      <!-- ThemeColor end -->
    

    
      <!-- viewer start (Picture preview) -->
      <link rel="stylesheet" href="/css/viewer.min.css"/>
      <!-- viewer end -->
    

    
      <!-- Search start -->
      <link rel="stylesheet" href="/css/search.css"/>
      <!-- Search end -->
    

    
      <!-- ThemeColor start -->
      <link rel="stylesheet" href="/css/themecolor.css"/>
      <!-- ThemeColor end -->
    

    

    
      <!-- gitalk start -->
      <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"> -->
      <link rel="stylesheet" href="/css/gitalk.css"/>
      <!-- gitalk end -->
    
  

  <!-- Custom Fonts -->
  <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
  <!-- Hux change font-awesome CDN to qiniu -->
  <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" type="text/css">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

  <!-- Hux Delete, sad but pending in China <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'> <link
  href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/ css'> -->

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]> <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script> <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script> <![endif]-->

  <!-- ga & ba script hoook -->
  <link rel="canonical" href="http://Hualingz.cn/Learning/操作系统/">
  <title>
    
      操作系统 - Hualingz_Channel
    
  </title>
<meta name="generator" content="Hexo 5.4.2"></head>


<!-- hack iOS CSS :active style -->

	<body ontouchstart="" class="body--light body--dark">


		<!-- ThemeColor -->
		
		<!-- ThemeColor -->
<style type="text/css">
  .body--light {
    --light-mode: none;
    --dark-mode: block;
  }
  .body--dark {
    --light-mode: block;
    --dark-mode: none;
  }
  i.mdui-icon.material-icons.light-mode {
    display: var(--light-mode);
  }
  i.mdui-icon.material-icons.dark-mode {
    display: var(--dark-mode);
  }
</style>
<div class="toggle" onclick="document.body.classList.toggle('body--dark')">
  <i class="mdui-icon material-icons light-mode"></i>
  <i class="mdui-icon material-icons dark-mode"></i>
</div>
<script>
  //getCookieValue
  function getCookieValue(a) {
    var b = document.cookie.match('(^|[^;]+)\\s*' + a + '\\s*=\\s*([^;]+)');
    return b
      ? b.pop()
      : '';
  }
  let themeMode = 'dark';
  if (getCookieValue('sb-color-mode') && (getCookieValue('sb-color-mode') !== themeMode)) {
    let dbody = document.body.classList;
    themeMode === 'dark' ? dbody.remove('body--dark') : dbody.add('body--dark');
  }

  //setCookieValue
  var toggleBtn = document.querySelector(".toggle");
  toggleBtn.addEventListener("click", function () {
    var e = document.body.classList.contains("body--dark");
    var cookieString = e
      ? "dark"
      : "light";
    var exp = new Date();
    exp.setTime(exp.getTime() + 3 * 24 * 60 * 60 * 1000); //3天过期
    document.cookie = "sb-color-mode=" + cookieString + ";expires=" + exp.toGMTString() + ";path=/";
  });
</script>

		

		<!-- Gitter -->
		
		<!-- Gitter -->
<!-- Docs:https://gitter.im/?utm_source=left-menu-logo -->
<script>
  ((window.gitter = {}).chat = {}).options = {
    room: 'your-community/your-room'
  };
</script>
<script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script>

		

		<!-- Navigation (contains search)-->
		<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header page-scroll">
      <button type="button" class="navbar-toggle">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">Hualingz_Channel</a>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <!-- Known Issue, found by Hux: <nav>'s height woule be hold on by its content. so, when navbar scale out, the <nav> will cover tags. also mask any touch event of tags, unfortunately. -->
    <div id="huxblog_navbar">
      <div class="navbar-collapse">
        <ul class="nav navbar-nav navbar-right">
          <li>
            <a href="/">首页</a>
          </li>

          
          
          
          
          <li>
            <a href="/about/">
              
              关于
              
              
            </a>
          </li>
          
          
          
          
          
          <li>
            <a href="/categories/">
              
              分类
              
              
            </a>
          </li>
          
          
          
          <li>
            <a href="/tags/">
              
              标签
              
              
            </a>
          </li>
          
          

          
          <li>
            <a class="popup-trigger">
              <span class="search-icon"></span>搜索</a>
          </li>
          

          <!-- LangSelect -->
          
          
          
          
          
        </ul>
      </div>
    </div>
    <!-- /.navbar-collapse -->
  </div>
  <!-- /.container -->
</nav>
<!-- progress -->
<div id="progress">
  <div class="line" style="width: 0%;"></div>
</div>

<script>
  // Drop Bootstarp low-performance Navbar Use customize navbar with high-quality material design animation in high-perf jank-free CSS3 implementation
  var $body = document.body;
  var $toggle = document.querySelector('.navbar-toggle');
  var $navbar = document.querySelector('#huxblog_navbar');
  var $collapse = document.querySelector('.navbar-collapse');

  $toggle.addEventListener('click', handleMagic)

  function handleMagic(e) {
    if ($navbar.className.indexOf('in') > 0) {
      // CLOSE
      $navbar.className = " ";
      // wait until animation end.
      setTimeout(function() {
        // prevent frequently toggle
        if ($navbar.className.indexOf('in') < 0) {
          $collapse.style.height = "0px"
        }
      }, 400)
    } else {
      // OPEN
      $collapse.style.height = "auto"
      $navbar.className += " in";
    }
  }
</script>


		<!-- Post Header (contains intro-header、signature、wordcount、busuanzi、waveoverlay) -->
		<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->

  <style type="text/css">
    .body--light {
      /* intro-header */
      --intro-header-background-image-url-home: url('/img/header_img/newhome_bg.jpg');
      --intro-header-background-image-url-post: url('');
      --intro-header-background-image-url-page: url('/img/header_img/archive_bg2.jpg');
    }
    .body--dark {
      --intro-header-background-image-url-home: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url('/img/header_img/newhome_bg.jpg');
      --intro-header-background-image-url-post: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url('');
      --intro-header-background-image-url-page: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url('/img/header_img/archive_bg2.jpg');
    }

    header.intro-header {
       /*post*/
        background-image: var(--intro-header-background-image-url-post);
        /* background-image: url(''); */
      
    }

    
      #signature {/*signature*/
        background-image: url('/img/signature/vincent-white.png');
      }
    
  </style>





<header class="intro-header">
  <!-- Signature -->
  <div id="signature">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
          
          <div class="post-heading">
            <div class="tags">
              
              <a class="tag" href="/tags/#浙江大学" title="浙江大学">浙江大学</a>
              
              <a class="tag" href="/tags/#OS操作系统" title="OS操作系统">OS操作系统</a>
              
            </div>
            <h1>操作系统</h1>
            <h2 class="subheading">Hualingz</h2>
            <span class="meta">
              Posted by Hualingz on
              2023-02-16
            </span>


            
            <!-- WordCount start -->
            <div class="blank_box"></div>
            <span class="meta">
              Estimated Reading Time <span class="post-count">96</span> Minutes
            </span>
            <div class="blank_box"></div>
            <span class="meta">
              Words <span class="post-count">24.4k</span> In Total
            </span>
            <div class="blank_box"></div>
            <!-- WordCount end -->
            
            
            <!-- 不蒜子统计 start -->
            <span class="meta" id="busuanzi_container_page_pv">
              Viewed <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span> Times
            </span>
            <!-- 不蒜子统计 end -->
            


          </div>
          
        </div>
      </div>
    </div>
  </div>

  
  <!-- waveoverlay start -->
  <div class="preview-overlay">
    <svg class="preview-waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
      <defs>
        <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path>
      </defs>
      <g class="preview-parallax">
        <use xlink:href="#gentle-wave" x="48" y="0" fill=var(--gentle-wave1)></use>
        <use xlink:href="#gentle-wave" x="48" y="3" fill=var(--gentle-wave2)></use>
        <use xlink:href="#gentle-wave" x="48" y="5" fill=var(--gentle-wave3)></use>
        <use xlink:href="#gentle-wave" x="48" y="7" fill=var(--gentle-wave)></use>
      </g>
    </svg>
  </div>
  <!-- waveoverlay end -->
  

</header>



		<!-- Main Content (Post contains
	Pager、
	tip、
	socialshare、
	gitalk、gitment、disqus-comment、
	Catalog、
	Sidebar、
	Featured-Tags、
	Friends Blog、
	anchorjs、
	) -->
		<!-- Modify by Yu-Hsuan Yen -->
<!-- Post Content -->
<article>
  <div class="container">
    <div class="row">
      <!-- Post Container -->
      <div class="col-lg-8 col-lg-offset-1 col-md-10 col-md-offset-1 post-container">

        <h1 id="操作系统">操作系统</h1>
<h2 id="lecture-1-1">Lecture 1-1</h2>
<h3 id="prerequirement">Prerequirement</h3>
<ul>
<li>Assembly，C，Data Structures</li>
<li>Programming skills：
<ul>
<li>C programming language</li>
<li>Linux Programming and Debugging</li>
</ul></li>
</ul>
<h3 id="grading">Grading</h3>
<ul>
<li>Final Exam 50</li>
<li>Project 50
<ul>
<li>Implement Linux0.11 on RISCV 64bit</li>
</ul></li>
</ul>
<h3 id="lab">Lab</h3>
<p>实现Interrupts</p>
<p>manual：http://zju-sec.github.io/os22fall-stu</p>
<h3 id="data-stored-in-memory">Data Stored in Memory</h3>
<ul>
<li>内存的基本单元是byte，一个byte有8个bits</li>
<li>每一个byte在内存中有一个地址
<ul>
<li>所有的地址在机器中有相同的位数</li>
</ul></li>
<li>processer是对地址上的数据进行操作</li>
<li>地址上的数据的意义由解读而不同，可以是一个数、一个ascii码...
<ul>
<li>操作系统没有数据类型，都是一个地址和一个数据</li>
<li>指针：指向地址</li>
<li>强转：强制解释数据</li>
</ul></li>
<li>操作系统中最常用的结构是数组。</li>
<li>为了避免data和instruction混淆，我们人为将memory分成了存code和data的地方，但是这仅仅是人为的，会发生注入攻击</li>
</ul>
<h2 id="lecture-1-2">Lecture 1-2</h2>
<h3 id="review">Review</h3>
<h4 id="cpu">CPU</h4>
<ul>
<li>读取和修改内存的硬件</li>
<li>里面有什么东西
<ul>
<li>ALU</li>
<li>Control Unit</li>
<li>PC：program counter，指向下一条指令的地址</li>
<li>Current Instruction</li>
<li>32个寄存器</li>
</ul></li>
<li>执行的步骤
<ul>
<li>Fetch：从PC指向的内存地址取出内容，放入current
instruction，PC+1</li>
<li>Decode：解码指令</li>
<li>Execute：执行指令</li>
</ul></li>
</ul>
<h4 id="dma">DMA</h4>
<ul>
<li>DMA在现代电脑中广泛应用</li>
<li>CPU准许memory和IO直接进行数据传输
<ul>
<li>比如拷贝数据从memory到memory
<ul>
<li>一般的做法是memory通过总线先到CPU再写道memory，效率很低</li>
<li>能不能不用CPU，直接进行拷贝</li>
<li>DMA
Controller能够直接对内存里的数据进行传输，<strong>不通过CPU</strong></li>
</ul></li>
<li>DMA不是完全自由的，也需要占用CPU
<ul>
<li>信号的传入</li>
<li>占用Memory Bus</li>
</ul></li>
</ul></li>
</ul>
<h4 id="memory-hierarchy">Memory Hierarchy</h4>
<ul>
<li>CPU(Register)：如4Ghz的执行一条指令仅需0.25ns</li>
<li>Cache：1ns左右</li>
<li>Memory：400ns左右</li>
<li>I/O，Disk：5ms左右</li>
<li>多层Cache(L1,L2,L3)</li>
</ul>
<h5 id="cache为什么work">Cache为什么work？</h5>
<ul>
<li>Temporal Locality
<ul>
<li>访问的东西再最近的时间还会再访问</li>
</ul></li>
<li>Spatial Locality
<ul>
<li>访问的地址最近还会再访问</li>
</ul></li>
</ul>
<h5 id="moores-law">Moore's Law</h5>
<p>什么摩尔定律失效了？发热问题难以解决</p>
<h4 id="smp-system">SMP System</h4>
<ul>
<li>Symmetric multi processors对称多处理器</li>
<li>多处理器</li>
</ul>
<h4 id="multi-core-chips">Multi-core Chips</h4>
<ul>
<li><strong>core之间的交流需要开销，50个2Ghz的cores远远不如1个100Ghz的core</strong></li>
<li>处理器中多核</li>
</ul>
<h3 id="os">OS</h3>
<ul>
<li>What is OS?
<ul>
<li>操作系统，可以说是硬件的管家</li>
<li><strong>Resource abstractor</strong>抽象资源</li>
<li><strong>Resource allocator</strong>管理资源</li>
<li>决定了哪些软件可以获得哪些资源</li>
</ul></li>
<li>如何启动操作系统？
<ul>
<li>先启动第一个程序bootstrap program
<ul>
<li>Stored in ROM</li>
<li>Bootloader：初始化电脑，定位启动操作系统的kernel即Head.S</li>
<li>kernel启动第一个进程，在linux中叫做init</li>
<li><strong>之后kernel就不做任何事，等Event事件发生，占用一点内存，因此设计要简单</strong></li>
<li>kernel不是一个running job</li>
</ul></li>
</ul></li>
<li>Multi-Programming：现在的OS能做很多个进程job
<ul>
<li>OS在memory中找一个任务进行执行，这个任务需要等待其他事务时，进行进程转换，做另一件事</li>
<li>这就是context-switch</li>
</ul></li>
<li>Time-Sharing：Multi-Programming with rapid context-switch
<ul>
<li>jobs不能跑太久，把任务分的很小</li>
<li>允许interactivity
<ul>
<li>反应时间要短</li>
<li>每一个job有一种illusion在系统上独立的</li>
</ul></li>
<li>进程：需要进行的任务</li>
</ul></li>
</ul>
<h4 id="running-os">Running OS</h4>
<ul>
<li>Lean：nothing more，资源管理角度，要简单</li>
<li>Mean：single
minded，没有程序为os修复，因此代码稳定性要好，不能有bug</li>
</ul>
<h4 id="操作系统如何管理硬件资源">操作系统如何管理硬件资源</h4>
<ul>
<li>给Instruction设立权限
<ul>
<li>Privileged：执行这个指令需要权限</li>
<li>Unprivileged：用户可以执行的指令</li>
</ul></li>
<li>CPU怎么知道这个privileged的指令是否可以执行？
<ul>
<li>在CPU中增加bit，作为mode
bit，在某个mode下可以执行权限指令，某个mode下不可执行
<ul>
<li>User Mode：Unprivileged</li>
<li>Kernel Mode：Unprivileged and Privileged</li>
</ul></li>
</ul></li>
<li>Control Unit
<ul>
<li>需要侦测当前的指令是否为Privileged</li>
<li>侦测当前的mode</li>
</ul></li>
<li>RSICV的modes
<ul>
<li>U：00，用户mode</li>
<li>S：01，系统mode</li>
<li>M：11，Machine mode</li>
<li>R：10，Reserve</li>
</ul></li>
</ul>
<h2 id="lecture-2-1">Lecture 2-1</h2>
<h3 id="os-events">OS Events</h3>
<ul>
<li>一个event是一个“unusual”change in control flow
<ul>
<li>A usual change is some “branch” instruction within a user program
for instance</li>
</ul></li>
<li>Kernel定义了许许多多的handler，用于处理不同的Event</li>
<li>OS一旦启动后，一直在等待Event发生，Event发生后进行control
flow的改变，使用handler</li>
</ul>
<h4 id="event分类">Event分类</h4>
<ul>
<li>interrupt
<ul>
<li>操作系统中的，比如是keyboard</li>
<li>不同步的，可在任何阶段发生</li>
</ul></li>
<li>exceptions/trap
<ul>
<li>在用户和软件中的错误，比如除以0</li>
<li>同步的，执行到某行代码才知道</li>
</ul></li>
</ul>
<h4 id="system-calls">System Calls</h4>
<ul>
<li><p>User mode下需要硬件或者资源，那么我们需要能够进入kernel</p></li>
<li><p>user space和kernel之间联系的桥梁，入口点</p>
<ul>
<li>Arm64提供了300个syscall</li>
</ul></li>
<li><p>System Call是一种特殊的OS Events</p>
<ul>
<li>是一类Exception</li>
</ul></li>
<li><p>Sys Call Example</p>
<ul>
<li>``` mov <span class="math inline">\(0x1,\)</span>eax syscall #arm64
<figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="string">![image-20220921102816729](操作系统\image-20220921102816729.png)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### Timers</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="string">OS需要使用CPU，CPU有时钟周期，因此操作系统要有时钟的概念，以此区分指令对于CPU的使用率</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="string">使用interrupt的方法</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="string">每隔一定时间就发送一个Timer的Event</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Timer的handler中有一个计数器</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="string">```</span></span><br><span class="line">    <span class="attribute">case TIMER</span><span class="punctuation">:</span></span><br><span class="line">    	Timer.handleEvent(event);</span><br><span class="line">    	break;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>如何确定时间</p>
<ul>
<li>操作系统启动只有一个启动时间</li>
<li>是相对时间：过了多少个timer interrupt
<ul>
<li>剩下为0，说明需要更换job</li>
</ul></li>
</ul></li>
</ul>
<h3 id="main-os-services">Main OS Services</h3>
<ul>
<li><p>Process Management</p>
<ul>
<li><strong>Process</strong> is a Program in Execution
<ul>
<li>Program：passive entity
<ul>
<li>没有跑起来是program</li>
</ul></li>
<li>Process：active entity
<ul>
<li>跑起来是process</li>
</ul></li>
</ul></li>
<li>OS要做：
<ul>
<li>Creating and deleting processes</li>
<li>Suspending and resuming processes</li>
<li>Providing mechanisms for process synchronization</li>
<li>Providing mechanisms for process communication</li>
<li>Providing mechanisms for deadlock handling</li>
</ul></li>
</ul></li>
<li><p>Memory Management</p>
<ul>
<li>操作系统的memory management决定了memory中的东西
<ul>
<li>Kernel一直在Memory中</li>
</ul></li>
<li>OS要做
<ul>
<li>记录追踪谁用了多少</li>
<li>决定内存中数据的去留</li>
<li>申请和释放内存</li>
</ul></li>
</ul></li>
<li><p>Storage Management</p></li>
<li><p>IO Management</p></li>
<li><p>Protection and Security</p></li>
</ul>
<h3 id="os-structures">OS Structures</h3>
<h4 id="user-and-operating-system-interface">User and Operating System
Interface</h4>
<ul>
<li><p>用户层面</p>
<ul>
<li>GUI</li>
<li>Batch</li>
<li>Command line</li>
<li>User interfaces</li>
</ul></li>
<li><p>操作系统服务</p>
<ul>
<li><p>Program Execution</p>
<ul>
<li>载入运行程序</li>
<li>允许程序以多个方式结束</li>
</ul></li>
<li><p>IO Operations</p></li>
<li><p>Communication</p></li>
<li><p>Error Detection</p></li>
<li><p>File Systems</p></li>
<li><p>Resource allocation</p></li>
<li><p>accounting</p></li>
<li><p>Protection and Security</p></li>
</ul></li>
</ul>
<h3 id="system-calls-1">System Calls</h3>
<ul>
<li><p>进入kernel的入口，program interface</p>
<ul>
<li>API：Application Programming Interface</li>
<li>大多数都是通过API而不是直接system call</li>
<li>system call包装一下形成API
<ul>
<li>如printf是一个API</li>
<li>write是一个system call</li>
<li>printf就是把write进行了wrapper</li>
</ul></li>
</ul></li>
<li><p>system call：x86_64</p></li>
<li><p>write的过程</p>
<ul>
<li>call函数</li>
<li>syscall，停止user的进程</li>
<li>进入Kernel mode</li>
<li>Event Handler</li>
<li>返回User mode</li>
</ul></li>
</ul>
<h2 id="lecture-2-2">Lecture 2-2</h2>
<h3 id="system-calls-2">System Calls</h3>
<ul>
<li>是Kernel给UserSpace的一些功能的入口</li>
<li>System Call你不会直接用，一般是warpper，即API</li>
<li>需要高效，使用数组</li>
</ul>
<h4 id="sys-call的例子">Sys Call的例子</h4>
<ul>
<li>拷贝一个文件：
<ul>
<li>Privileged</li>
<li>man命令，可以用于查询命令使用方法，可以指定查看</li>
<li>调用大量的SysCall</li>
</ul></li>
<li>strace可以给出我们调用了哪些SysCall</li>
</ul>
<h4 id="sys-call的参数传递">Sys Call的参数传递</h4>
<ul>
<li>通过寄存器传递，不能传递一大块内存，只能传递地址</li>
</ul>
<h4 id="system-service">System Service</h4>
<ul>
<li>系统服务，提供了更方便的software</li>
<li>Ubuntu比Linux多了GUI、Software、API等</li>
</ul>
<h3 id="linkers-and-loaders">Linkers and Loaders</h3>
<ul>
<li><p>从高级语言到底层语言</p>
<p>Ø 预处理阶段</p>
<p>预处理器（cpp）根据以字符#开头的命令修给原始的C程序，结果得到另一个C程序，通常以.i作为文件扩展名。主要是进行文本替换、宏展开、删除注释这类简单工作。</p>
<p>对应的命令：linux&gt; gcc -E hello.c hello.i</p>
<p>Ø 编译阶段</p>
<p>编译器将文本文件hello.i翻译成hello.s，包含相应的汇编语言程序</p>
<p>对应的命令：linux&gt; gcc -S hello.c hello.s</p>
<p>Ø 汇编阶段</p>
<p>将.s文件翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件.o中(把汇编语言翻译成机器语言的过程)。</p>
<p>把一个源程序翻译成目标程序的工作过程分为五个阶段：词法分析；语法分析；语义检查和中间代码生成；代码优化；目标代码生成。主要是进行词法分析和语法分析，又称为源程序分析，分析过程中发现有语法错误，给出提示信息。</p>
<p>对应的命令：linux&gt; gcc -c hello.c hello.o</p>
<p>Ø 链接阶段</p>
<p>此时hello程序调用了printf函数。
printf函数存在于一个名为printf.o的单独的预编译目标文件中。
链接器（ld）就负责处理把这个文件并入到hello.o程序中，结果得到hello文件，一个可执行文件。最后可执行文件加载到储存器后由系统负责执行,
函数库一般分为静态库和动态库两种。静态库是指编译链接时，把库文件的代码全部加入到可执行文件中，因此生成的文件比较大，但在运行时也就不再需要库文件了。其后缀名一般为.a。动态库与之相反，在编译链接时并没有把库文件的代码加入到可执行文件中，而是在程序执行时由运行时链接文件加载库，这样可以节省系统的开销。动态库一般后缀名为.so，gcc在编译时默认使用动态库。</p></li>
<li><p>main.c通过编译器生成object文件</p></li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c <span class="selector-tag">main</span><span class="selector-class">.c</span> -o <span class="selector-tag">main</span>.o</span><br></pre></td></tr></table></figure>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpp <span class="selector-tag">main</span><span class="selector-class">.c</span> -o <span class="selector-tag">main</span>.i</span><br></pre></td></tr></table></figure>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S <span class="selector-tag">main</span><span class="selector-class">.i</span> -o <span class="selector-tag">main</span>.o</span><br></pre></td></tr></table></figure>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">as <span class="selector-tag">main</span><span class="selector-class">.i</span> -o <span class="selector-tag">main</span><span class="selector-class">.o</span> (二进制文件)</span><br></pre></td></tr></table></figure>
<ul>
<li>main.o通过Linkers生成可执行文件</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -v <span class="selector-tag">main</span><span class="selector-class">.o</span> -o <span class="selector-tag">a</span>.out</span><br></pre></td></tr></table></figure>
<ul>
<li>可执行文件通过Loaders进入内存执行</li>
</ul>
<h4 id="linkers">Linkers</h4>
<ul>
<li><p>Executable and Linkable Format - ELF文件</p></li>
<li><p>a.out文件也是一种ELF文件</p>
<ul>
<li><p>Program Header Table</p>
<ul>
<li>.text：code段，可读可写，可执行</li>
<li>.rodata：只读数据，不可执行</li>
<li>.data：初始化的data，静态变量，const</li>
<li>.bss：未初始化的data</li>
</ul></li>
<li><p>ELF文件格式提供了两种不同的视角，在汇编器和链接器看来，ELF文件是由Section
Header
Table描述的一系列Section的集合，而执行一个ELF文件时，在加载器（Loader）看来它是由Program
Header Table描述的一系列Segment的集合</p></li>
<li><p>readelf</p>
<ul>
<li><p>用于查看elf文件的结构</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -S a.<span class="keyword">out</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>Static Link</p>
<ul>
<li>静态链接，所有的可执行代码，pack到一个binary中</li>
<li>可移植性强</li>
<li>大</li>
</ul></li>
<li><p>Dynamic Link</p>
<ul>
<li>动态链接</li>
<li>小，必须有动态链接库，可移植性差</li>
<li>何时被解析library call？
<ul>
<li>loader解析的</li>
</ul></li>
<li>SysCall比较多</li>
<li>运行时动态链接是在执行程序调用到模块内容时再将动态库中的相应模块载入到内存。</li>
</ul></li>
<li><p>Section Header Table</p></li>
</ul></li>
</ul>
<h4 id="loaders">Loaders</h4>
<ul>
<li>Dynamic Link的syscall比Static Link多了Dynamic Loader的syscall</li>
</ul>
<h2 id="lecture-3-1">Lecture 3-1</h2>
<h3 id="linkers-and-loaders-1">Linkers and Loaders</h3>
<h4 id="loaders-1">Loaders</h4>
<ul>
<li>Running A Binary
<ul>
<li>Kernel Space【高地址】</li>
<li>Stack：仅仅是一段内存，没有structure</li>
<li>Memory Mapping
Segment：Library映射，Dynamic的libray的映射，Static没有这一段</li>
<li>Heap：仅仅是一段内存，没有structure</li>
<li>BSS</li>
<li>Data</li>
<li>Text(ELF)【低地址】</li>
</ul></li>
<li>谁setup了ELF，把ELF进行Load到内存里？Kernel的syscall，Sys_execve
(load_elf_binary)</li>
<li>谁setup了stack和heap？Kernel</li>
<li>谁setup了Library？Loader发起的</li>
<li>内核读取ELF，load到内存中，ld-xxx</li>
</ul>
<h4 id="clarify">Clarify</h4>
<ul>
<li>Stack：有指针指向栈顶SP(sp寄存器)和栈底FP(通用寄存器)</li>
<li>Heap：只有一个指针不在缓存里，要用时进入通用寄存器进行寻址</li>
</ul>
<h3 id="static和dynamic-link的区别">Static和Dynamic Link的区别</h3>
<ul>
<li>Static
<ul>
<li>静态链接，所有的可执行代码，pack到一个binary中，可移植性强，大</li>
<li>Entry Point Address：
<ul>
<li>_start：c run time的一部分</li>
<li>start_thread会将pc设置成entry point address作为user space的开始</li>
<li>./bin-fork()-execve-sys_execve-do_execve-search_binary_handler-load_elf_binary-_start-main()</li>
</ul></li>
<li>在load_elf_binary函数中，会进行判断，如果是Static的，entry
points会到_start</li>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220928110531037.png" alt="image-20220928110531037">
<figcaption aria-hidden="true">image-20220928110531037</figcaption>
</figure></li>
</ul></li>
<li>Dynamic
<ul>
<li>./bin-fork()-execve-sys_execve-do_execve-search_binary_handler-load_elf_binary-ld.so-_start-__libc_start_main()-init-main()</li>
<li>在load_elf_binary函数中，会进行判断，如果是Dynamic的，entry
points会到Loader</li>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220928110540425.png" alt="image-20220928110540425">
<figcaption aria-hidden="true">image-20220928110540425</figcaption>
</figure></li>
</ul></li>
</ul>
<h3 id="os的设计">OS的设计</h3>
<ul>
<li>User：方便、简洁、可靠、安全、快</li>
<li>System Goal：好实现、灵活、可靠、有效率、error-free</li>
<li>法则：
<ul>
<li>Policy：设计上的What will be done？</li>
<li>Mechanism：实现上的How to do it？</li>
</ul></li>
<li>Door Example
<ul>
<li>Policy：只有特定人员能进入门</li>
<li>Mechanism：门禁系统</li>
</ul></li>
<li>Scheduling
<ul>
<li>Scheduling Policy and how to pick next(mechanism)</li>
</ul></li>
<li>早期的OS用汇编，现在用C、C++，最底层的还是用汇编实现的。
<ul>
<li>用高级语言容易port到hardware</li>
<li>效率问题</li>
</ul></li>
</ul>
<h3 id="os的结构">OS的结构</h3>
<ul>
<li>Simple Structure：MS-DOS</li>
<li>Monolithic：Unix、Linux
<ul>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220928112442562.png" alt="image-20220928112442562">
<figcaption aria-hidden="true">image-20220928112442562</figcaption>
</figure></li>
<li>缺点：code全在kernel中，code多bug也多</li>
</ul></li>
<li>Layered：an abstraction</li>
<li>Microkernel：Mach
<ul>
<li>让内核变小，将很多的代码从kernel移动到user space</li>
<li>小，好开发好移植</li>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220928112648535.png" alt="image-20220928112648535">
<figcaption aria-hidden="true">image-20220928112648535</figcaption>
</figure></li>
<li>缺点：慢</li>
</ul></li>
</ul>
<h2 id="lecture-3-2">Lecture 3-2</h2>
<h3 id="processes-concept">Processes Concept</h3>
<ul>
<li>进程：是一个资源组织的单元
<ul>
<li>进程是执行中的program</li>
<li>program：passive entity</li>
<li>binary被load到内存中就变成了process</li>
<li>一个program被run多次，会生成多个进程</li>
</ul></li>
<li>“job”和“process”都可以用于说明进程</li>
<li>Process=
<ul>
<li>code</li>
<li>data section</li>
<li>program counter【PC】</li>
<li>通用寄存器</li>
<li>stack</li>
<li>heap</li>
</ul></li>
<li>用<code>ps au</code>查看pid
<ul>
<li>再用<code>cat \proc\pid\maps</code>查看内存映射</li>
</ul></li>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220929144517637.png" alt="image-20220929144517637">
<figcaption aria-hidden="true">image-20220929144517637</figcaption>
</figure></li>
</ul>
<h3 id="stack">Stack</h3>
<ul>
<li>runtime stack
<ul>
<li>存储临时变量，每一个调用都有一个stack，称为Stack
Frame，栈是从高地址到低地址
<ul>
<li>x29：FP</li>
<li>x30：LR</li>
</ul></li>
<li>The management of the stack is done entirely on your behalf by the
compiler</li>
</ul></li>
<li>function call如何返回
<ul>
<li>使用stack</li>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220929144800981.png" alt="image-20220929144800981">
<figcaption aria-hidden="true">image-20220929144800981</figcaption>
</figure></li>
<li>caller和callee保存</li>
</ul></li>
<li>Stack Frame存什么？
<ul>
<li>函数需要一些“state”确保他能run
<ul>
<li>参数</li>
<li>本地变量</li>
<li>return address</li>
<li>返回值</li>
</ul></li>
<li>方式：caller save和callee save</li>
</ul></li>
<li>Stack不能一直向下涨，否则会overflow</li>
</ul>
<h5 id="multi-tasking">multi-Tasking</h5>
<ul>
<li>对于<strong>单个程序</strong>的多process，data和text是一致的即elf的内容，但是stack、heap等大小不一定</li>
<li>stack和heap是不会share的</li>
<li>可执行多任务</li>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220929145623643.png" alt="image-20220929145623643">
<figcaption aria-hidden="true">image-20220929145623643</figcaption>
</figure></li>
</ul>
<h3 id="process-state">Process State</h3>
<ul>
<li>当一个Process执行，他会改变状态
<ul>
<li>New：创建新的进程</li>
<li>Running：指令正被执行</li>
<li>Waiting：等他其他事件发生</li>
<li>Ready：等待被布置在processor</li>
<li>Terminated：结束</li>
</ul></li>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220929150036640.png" alt="image-20220929150036640">
<figcaption aria-hidden="true">image-20220929150036640</figcaption>
</figure></li>
</ul>
<h3 id="pcbprocess-control-block">PCB（Process Control Block）</h3>
<ul>
<li>Process的元数据</li>
<li>每一个process都有一个PCB
<ul>
<li>Allocate当process被创建</li>
<li>Free当process被结束</li>
</ul></li>
<li>存放在数据结构task_struct中
<ul>
<li>Process state：状态waiting,running</li>
<li>Program counter：下一条要被执行的指令的位置</li>
<li>CPU register：所有process-centric的寄存器</li>
<li>CPU scheduling information：priorities，scheduling queue
pointers进程的队列信息等</li>
<li>Memory-management information：memory allocated to the
process内存申请的信息</li>
<li>Accounting information：CPU used，clock time elapsed since
start，time limits，CPU的使用、时间</li>
<li>IO status informatio：process的IO设备，打开文件的列表</li>
</ul></li>
</ul>
<h3 id="process-creation">【1】Process Creation</h3>
<ul>
<li><p>一般使用fork()的syscall</p></li>
<li><p>一个Process可能会创建新的process，那么就成为了parent，有了一个process
tree</p>
<ul>
<li>每一个process有一个pid</li>
<li>child会继承、分享一些parent的资源</li>
<li>parent能将input传递给child</li>
</ul></li>
<li><p>fork()</p>
<ul>
<li><p>child是一个parent的copy，但是</p>
<ul>
<li>pid不同</li>
<li>resource utilization is set to 0</li>
</ul></li>
<li><p>fork() return了child的pid和parent的pid</p>
<ul>
<li>return 两次，一次是parent进程return了子进程的pid，子进程返回了0</li>
<li>每个process可以获得本身的pid用<code>getpid()</code></li>
<li>可以获得parent的pid，用<code>getppid()</code></li>
</ul></li>
<li><p>它不需要参数并返回一个整数值。下面是fork（）返回的不同值。</p>
<ul>
<li><strong>负值</strong>：创建子进程失败。</li>
<li><strong>零</strong>：返回到新创建的子进程。</li>
<li><strong>正值</strong>：返回父进程或调用者。该值包含新创建的子进程的进程ID</li>
</ul></li>
<li><p>fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：</p>
<ul>
<li>在父进程中，fork返回新创建子进程的进程ID；</li>
<li>在子进程中，fork返回0；</li>
<li>负值，错误</li>
</ul></li>
<li><p>【Example】</p>
<ul>
<li><p>``` pid1=fork(); printf("Hello"); pid2=fork(); printf("Hello");
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 输出几个Hello？<span class="number">6</span>个</span><br><span class="line"></span><br><span class="line">- 【Example】</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    <span class="built_in">fork</span>()</span><br><span class="line">    <span class="built_in">if</span>(fork())&#123;</span><br><span class="line">    	<span class="built_in">fork</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fork</span>()</span><br></pre></td></tr></table></figure></p></li>
<li><p>12个进程</p></li>
</ul></li>
</ul></li>
<li><p>fork()了一个process后，东西适合parent一样的，需要用execve的syscall来load一个新的program</p>
<ul>
<li>因此fork和execve通常一起使用</li>
</ul></li>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220929153841780.png" alt="image-20220929153841780">
<figcaption aria-hidden="true">image-20220929153841780</figcaption>
</figure>
<ul>
<li>fork搭起骨架，exec赋予灵魂</li>
</ul></li>
</ul>
<h3 id="process-terminations">【2】Process Terminations</h3>
<ul>
<li>一个进程通过syscall的<code>exit()</code>关闭自己
<ul>
<li>所有的资源会被回收</li>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220929154954898.png" alt="image-20220929154954898">
<figcaption aria-hidden="true">image-20220929154954898</figcaption>
</figure></li>
<li>wait()把parent进行阻止，直到child执行了exit()
<ul>
<li>return pid of completed child and child的exit code</li>
</ul></li>
<li>waitpid()
<ul>
<li>阻止特定的子进程，给出pid将它wait掉</li>
</ul></li>
</ul></li>
</ul>
<h3 id="processes-and-signals">【3】Processes and Signals</h3>
<ul>
<li>进程可以接受信号，比如interrupt</li>
<li>信号可能有很多种发生的可能，不同的信号对应不同的操作</li>
<li>每一个信号都会造成一个进程的默认行为，可以用handler定义</li>
<li>大多数信号是不允许ignore、重载和handler的</li>
<li>systemcall的signal()允许进程指定信号干的事情
<ul>
<li>signal(SIGINT,SIG_IGN)无视</li>
<li>signal(SIGINT,SIG_DEL)default操作</li>
<li>signal(SIGINT,my_handler)自定义的handler</li>
</ul></li>
</ul>
<h2 id="lecture-4-1">Lecture 4-1</h2>
<h3 id="process-state-1">Process State</h3>
<ul>
<li><p>ready和waiting的状态的process最多</p></li>
<li><p>running的只取决于核的多少</p></li>
<li><p>Process Scheduler</p>
<ul>
<li>选择ready的进程作为下一个要执行的进程</li>
<li>Scheduling Queues
<ul>
<li>Ready queue：set of all processes residing in main memory, ready and
waiting to execute，一般只有一个Ready Queue</li>
<li>Wait queue：set of processes waiting for an event，一般有多个waiting
queue，每一个对象都会有waiting queue</li>
<li>如何组织queue？使用list_head，这是在中间的，不是在头上，指向下一个list_head和前一个list_head，<code>*prev,*next</code></li>
<li>有了list_head的地址，进行一个偏移，就获得了task_struct的地址</li>
</ul></li>
</ul></li>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221008143948731.png" alt="image-20221008143948731">
<figcaption aria-hidden="true">image-20221008143948731</figcaption>
</figure></li>
<li><p>Context Switch</p>
<ul>
<li>发生于CPU转换进程</li>
<li>kernel做的context switch，不能让user space做，因为context
switch决定了一个process用一个cpu用多久。</li>
<li>一个process在运行，来一个interrupt，需要执行一个新的进程，那么就要先save
PCB0，再load state PCB1，再做save PCB1和load PCB0</li>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221012100915401.png" alt="image-20221012100915401">
<figcaption aria-hidden="true">image-20221012100915401</figcaption>
</figure></li>
<li>什么是state？
<ul>
<li>可以理解为context</li>
<li>不能重用的一组寄存器，需要存到内存的PCB中</li>
<li>那些硬件寄存器的值</li>
</ul></li>
<li>When CPU switches to another process, the system must save the state
of the old process and load the saved state for the new process via a
context switch
<ul>
<li>Context of a process represented in the PCB</li>
<li>Context switch time is overhead，the system does no useful work
while switchin</li>
</ul></li>
<li>一些问题
<ul>
<li>PCB在哪个区域？
<ul>
<li>PCB就是task_struct</li>
<li>task_struct在内存里是动态分配的</li>
<li>task_struct就是heap中的一个对象</li>
</ul></li>
<li>这个切换函数如果是kernel的代码，为啥用的是ret返回（而不是特权级别的返回？
<ul>
<li>因为都是在kernel space做的，还没返回到user space</li>
</ul></li>
<li>reload p1 from pcb1和save p1 into
pcb1的两个pcb1是同一块内存吗，还是说reload以后原来那块pcb1就当作废弃了，之后save又选一块新的地方当作pcb1
<ul>
<li>PCB是process的元数据，只是一部分用来放context switch的寄存器了</li>
<li>PCB的生命周期是进程的生命周期</li>
</ul></li>
</ul></li>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221008152641728.png" alt="image-20221008152641728">
<figcaption aria-hidden="true">image-20221008152641728</figcaption>
</figure></li>
<li>Context switching between two kernel threads</li>
<li>When and Where is the context(regs) saved?
<ul>
<li>When：在context switch时，cpu_switch_to函数</li>
<li>Where：PCB，在thread_struct</li>
<li>All regs are running kernel code，termed kernel context</li>
</ul></li>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221012101518007.png" alt="image-20221012101518007">
<figcaption aria-hidden="true">image-20221012101518007</figcaption>
</figure></li>
<li>在user mode的context switching？
<ul>
<li>需要在kernel mode下switch，因此需要模式的转移
<ul>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221012101503914.png" alt="image-20221012101503914">
<figcaption aria-hidden="true">image-20221012101503914</figcaption>
</figure></li>
</ul></li>
<li>user context regs saved？
<ul>
<li>When：kernel_entry，kernel_exit</li>
<li>Where：per-thread kernel (stack <strong>pt_regs</strong>)</li>
</ul></li>
<li>kernel context regs saved?
<ul>
<li>When：cpu_switch_to</li>
<li>Where：thread_struct</li>
</ul></li>
</ul></li>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221008154121371.png" alt="image-20221008154121371">
<figcaption aria-hidden="true">image-20221008154121371</figcaption>
</figure></li>
<li>对于这个CPU_switch_to函数最后return到哪里去了？
<ul>
<li>在kernel
mode中，<strong>return到p1的cpu_switch_to的caller去</strong>，即p0进去了，p1出来了，p0在下一次context
switch时出来</li>
<li>When the value is set？</li>
</ul></li>
</ul></li>
</ul>
<h2 id="lecture-5-1">Lecture 5-1</h2>
<h3 id="fork-return-values">Fork( ) return values</h3>
<ul>
<li>fork怎么实现的返回两次？
<ul>
<li>Return new_pid to parent and zero to child</li>
<li>【1】返回给parent，就是一个syscall的调用，返回一个结果，这个结果就是子进程的pid。
<ul>
<li>new_pid何时被设置？
<ul>
<li>When：kernel_entry</li>
<li>Where：pt_regs</li>
<li>先从userspace到了kernelspace，将cpu的寄存器保存在pt_regs，返回时进行reload，一般来说我们的返回值放在a0，要把<strong>new_pid放入pt_reg</strong>的a0(x0)，在<code>ret_fast_syscall</code>函数中进行设置</li>
</ul></li>
</ul></li>
<li>【Question】一个userspace的进程到另一个userspace的进程，需要几次context
switch？user mode到kernel mode一次context save，进程交换一次context
switch，kernel mode到user mode进行一次context
save。位置分别在pt_reg和PCB</li>
<li>【2】返回给child的return是0
<ul>
<li>child从什么时候开始run？当fork了，就ready了，进行了context
switch就开始run了</li>
<li><code>copy_thread</code>，这个函数是parent执行的函数，在这里将child的返回值设为0，即child的pt_regs中的对应值是0，当parent跑完，pc是在ret_from_fork的，当child在run时再将pt_regs的x0被设置，再用kernel_exit进行reload返回。</li>
<li>child执行的第一行指令是在ret_from_fork的</li>
<li><code>ret_from_fork</code><span class="math inline">\(\rarr\)</span><code>ret_to_user</code><span class="math inline">\(\rarr\)</span><code>kernel_exit</code></li>
</ul></li>
</ul></li>
</ul>
<h3 id="zombie">Zombie</h3>
<ul>
<li>当一个子进程terminate了，如果parent没有对它回收，那么就进入zombie状态</li>
<li>The parent may still need to place a call to wait(), or a variant,
to retrieve the child’s exit code</li>
<li>什么资源不能通过子进程自己释放？task_struct不能被释放，即PCB，那么就会消耗内存</li>
<li>一般来说是操作系统中的parent来释放这个PCB并且获得返回值</li>
</ul>
<p><strong>Getting rid of zombies</strong></p>
<ul>
<li>僵尸会逗留到:
<ul>
<li>它的父进程已经为子进程调用了wait()</li>
<li>或者其父进程去世</li>
</ul></li>
<li>bad practice：leave zombies unnecessarily</li>
<li>一般怎么做？
<ul>
<li>The parent associates a handler to SIGCHLD</li>
<li>The handler calls wait()</li>
<li>This way all children deaths are “acknowledged”</li>
<li>See nozombie_example.c</li>
</ul></li>
</ul>
<h3 id="orphans">Orphans</h3>
<ul>
<li>An orphan process is one whose parent has died</li>
<li>In this case, the orphan is “adopted” by the process with
pid1被pid为1的进程收养
<ul>
<li>init on a Linux system</li>
<li>launchd on a Mac OS X system</li>
<li>Demo：orphan_example1.c</li>
</ul></li>
<li>The process with pid1 does handle child termination with a handler
for SIGCHLD that calls wait (just like in the previous slide!</li>
<li>Therefore, an orphan never becomes a zombie</li>
<li>“Trick” to fork a process that’s completely separate from the parent
(with no future responsibilities): create a grandchild and “kill” its
parent
<ul>
<li>Demo: orphan_example2.c</li>
<li>Child becomes zombie, parent needs to handle child exit
properly</li>
</ul></li>
</ul>
<h2 id="lecture-5-2">Lecture 5-2</h2>
<ul>
<li>在user mode的memory中有内存映射，stack、heap、data、text</li>
<li><strong>PCB在kernel
mode的memory</strong>，不能自己更改，task_struct有thread_info、stack、pt_regs等</li>
</ul>
<h3 id="ipcsinter-process-communication">IPCs：Inter-Process
Communication</h3>
<ul>
<li>进程是相互独立的，相互不影响。但是有时候我们需要进程之间的通信，这个机制如何？</li>
</ul>
<h4 id="share-memory">Share Memory</h4>
<p>不同的进程共享一部分内存，效率高，适合大段数据，较复杂</p>
<p>特点：</p>
<pre><code>1. low-overhead：初始的syscall少
1. 对于使用者而言更加方便
1. 在OS中较难实现</code></pre>
<p>进程需要建立 establish一个共享内存区域Share Memory Region</p>
<ul>
<li>一个进程创建一个共享内存区域</li>
<li>进程能将attach这个内存共享区域到他的地址空间</li>
</ul>
<p>进程之间相互沟通通过读写共享内存区域的方式</p>
<h5 id="exampleposix-shared-memory">Example：POSIX Shared Memory</h5>
<ol type="1">
<li><p>进程先创建一个共享内存区域</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">id</span> = shmget(IPC_PRIVATE,size,IPC_R,IPC_W)</span><br></pre></td></tr></table></figure></li>
<li><p>进程若想要访问这个共享内存区域，必须attach上去</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">share_memory = (<span class="type">char</span>*)<span class="built_in">shmat</span>(id,<span class="literal">NULL</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>现在进程能够写入共享内存区域</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">sprintf</span><span class="params">(shared_memory,<span class="string">&quot;hello&quot;</span>)</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>当一个进程完成了，就要detach</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">shmdt</span><span class="params">(id,IPC_RMID,NULL)</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>进程如何知道shared memory的ID？</p>
<ol type="1">
<li>没有一个很好的方法，可以是command-line，可以是stored in file</li>
<li>id在fork前产生，因此父进程和子进程都可以知道这一块共享内存区域的id</li>
<li>可以用message passing实现id的交流</li>
</ol>
<h4 id="message-passing">Message passing</h4>
<p>有队列，由OS维护，维护简单</p>
<p>特点：</p>
<ol type="1">
<li>在交换小规模数据时，更加实用</li>
<li>在OS中易于实现</li>
<li>使用send和receive实现交流</li>
<li>high-overhead：one syscall per communication operation</li>
</ol>
<ul>
<li>不会共享任何地址空间，内存之间的独立性仍存在</li>
<li>有两个操作
<ul>
<li>send：发送信息</li>
<li>recv：接收信息</li>
</ul></li>
<li>进程P和Q想要交流
<ul>
<li>建立establish一个link在P和Q之间</li>
<li>我们不需要显式的link，只需要两个函数
<ul>
<li>send(P,message)：发送一个信息给进程P</li>
<li>receive(Q,message)：从Q接受一个信息</li>
</ul></li>
</ul></li>
<li>Direct or indirect
<ul>
<li>进程太多，这个link就很多，可以使用一个mailbox，都向这个box发送和接受</li>
<li>direct
<ul>
<li>P和Q之间直接发送信息进行交流</li>
<li>优势
<ul>
<li>links自动建立</li>
<li>一个link能够确定一对交流的进程</li>
<li>两个进程之间存在一个link</li>
<li>link可以是单向的，通常是bi-directional的</li>
</ul></li>
</ul></li>
<li>indirect
<ul>
<li>使用mailbox，每一个mailbox都有一个id</li>
<li>进程之间需要沟通的话，只需要使用同一个mailbox即可</li>
<li>优势
<ul>
<li>连接只用建立一次</li>
<li>一个连接可能有很多的进程</li>
<li>每一对进程可能分享若干个link即mailbox</li>
<li>link may be unidirectional or bi-directional</li>
</ul></li>
</ul></li>
</ul></li>
<li>同步or异步
<ul>
<li>Blocking：synchronous，时效性
<ul>
<li>blocking send：没收到，sender不能走</li>
<li>blocking receive：sender没来，接受者不能走</li>
</ul></li>
<li>Non-Blocking：asynchronous</li>
</ul></li>
<li>Buffering
<ul>
<li>link会有一个信息队列</li>
<li>实现有三种方式
<ul>
<li>Zero Capacity：没有信息存在队列里，发送者必须等待接受者</li>
<li>Bounded Capacity：有限的长度的队列，发送者要等待，如果队列满了</li>
<li>Unbounded Capacity：无限的长度队列</li>
</ul></li>
</ul></li>
</ul>
<h4 id="pipe">Pipe</h4>
<ol type="1">
<li>扮演着一个管道，允许进程进行交流</li>
</ol>
<h5 id="ordinary-pipes">Ordinary Pipes</h5>
<p>不能被创建者之外的进程访问，例如父进程和子进程之间的交流</p>
<ol type="1">
<li>Ordinary Pipes allow communication in standard producerconsumer
style</li>
<li>Producer writes to one end (the write-end of the pipe)</li>
<li>Consumer reads from the other end (the read-end of the pipe)</li>
<li>Ordinary pipes are therefore unidirectional</li>
<li>Require parent-child relationship between communicating processes
<ol type="1">
<li>fd[0] is the read end; fd[1] is the write end</li>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221019101357019.png" alt="image-20221019101357019">
<figcaption aria-hidden="true">image-20221019101357019</figcaption>
</figure></li>
<li>使用shared memory的方法，定义了0都是写，1都是读。</li>
</ol></li>
<li>Windows calls these anonymous pipes</li>
</ol>
<h5 id="named-pipes">Named Pipes</h5>
<p>能被访问，即使没有进程之间父子关系，没有名字</p>
<p>ordinary的问题是只能在parent和child之前传播</p>
<ol type="1">
<li>比ordinary pipe更有力</li>
<li>communication是双向的</li>
<li>不一定需要parent和child的关系</li>
<li>多个进程可以用同一个named pipe</li>
<li>Provided on both UNIX and Windows systems、</li>
</ol>
<p>实现方式就是使用一个文件(myfifo)作为中介，进程实时读写这个文件。</p>
<h4 id="client-server-communication">Client-Server Communication</h4>
<p>Sockets、RPCs、Java RMI</p>
<p><strong>Socket</strong>=ip address + port number</p>
<h2 id="lecture-6-1">Lecture 6-1</h2>
<p><strong>Thread</strong></p>
<p>Process = code + data section + program counter + registers + stack +
heap，即将program进入memory进行内存映射</p>
<figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220929144517637.png" alt="image-20220929144517637">
<figcaption aria-hidden="true">image-20220929144517637</figcaption>
</figure>
<p>如何让一个process跑得更快？我们可以让一个process有多个execution
units（<strong>thread</strong>）</p>
<h3 id="thread">Thread</h3>
<ul>
<li>Thread是一个Process的<strong>基本执行单元</strong>basic unit of
execution</li>
<li>每一个Thread独有的
<ul>
<li>Thread ID</li>
<li>Program Counter：执行单元因此需要PC</li>
<li>Register Set：执行，需要寄存器</li>
<li>Stack：不同的thread有不同的Call Path</li>
</ul></li>
<li>Shared的东西，就是Process的其他东西
<ul>
<li>Code Section：Code不会变</li>
<li>Data Section：Data是全局的变量和static的变量</li>
<li>Heap动态申请内存：可以想象成多块空闲的内存串起来的，heap是统一维护的</li>
<li>open File and Signals：与运行时无关</li>
</ul></li>
<li>与执行直接相关的资源是Thread独有的</li>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221020150820323.png" alt="image-20221020150820323">
<figcaption aria-hidden="true">image-20221020150820323</figcaption>
</figure></li>
</ul>
<p>Concurrency：一个多线程的进程能做多件事在同一时间</p>
<h3 id="advantages-of-thread">Advantages of Thread</h3>
<p>Economy</p>
<ul>
<li>Creating a thread is cheap
<ul>
<li>比创建进程更加cheaper</li>
<li>Code，data，heap已经在内存了</li>
</ul></li>
<li>Context-Switch between threads也更加cheaper
<ul>
<li>thread的switch不用switch那些share的东西</li>
<li>Cache在switch后是hot的，不用cache flush</li>
</ul></li>
</ul>
<p>Resource Sharing</p>
<ul>
<li>线程之间共享内存
<ul>
<li>不要IPC了，直接通过共享内存交流</li>
</ul></li>
<li>在一个address space里进行并行，效率高</li>
</ul>
<p>Responsiveness</p>
<ul>
<li>反应比较快，很好的响应性</li>
<li>一个程序有并行的活动有更好的响应性
<ul>
<li>多个thread可以handle多个request</li>
<li>当一个thread被blocked了，其他的thread仍可以正常运行</li>
</ul></li>
</ul>
<p>Scalability</p>
<ul>
<li>效率很高</li>
</ul>
<h3 id="drawbacks">DrawBacks</h3>
<p>不同的thread之间，一旦一个thread出错了，整个process就挂了，就是<strong>isolation不强</strong></p>
<p>不能benefit from memory protection</p>
<p>thread个数受到process的内存大小的限制</p>
<h3 id="user-thread和kernel-thread">User Thread和Kernel Thread</h3>
<ul>
<li>Thread可以单独支持User Space
<ul>
<li>User Thread：执行User space的code，使用User space的stack</li>
</ul></li>
<li>Thread也可以支持Kernel Space执行
<ul>
<li>Kernel Thread：执行Kernel Space的code，使用Kernel space的stack</li>
</ul></li>
<li>Many to one
<ul>
<li>一个block了就会其他的出错</li>
</ul></li>
<li>One to one
<ul>
<li>一个block不影响其他的，实现简单</li>
<li>资源占用率高</li>
</ul></li>
<li>m to n
<ul>
<li>太复杂了</li>
</ul></li>
</ul>
<h2 id="lecture-6-2">Lecture 6-2</h2>
<h3 id="semantics-of-fork-and-exec">Semantics of fork() and exec()</h3>
<h4 id="thread的fork">thread的fork</h4>
<ul>
<li>一个thread如果call了fork，那么现在的linux是只复制这一个thread的，其实有两种选择
<ul>
<li>一个只有一个线程的新进程</li>
<li>一个新进程和原进程一模一样，有很多线程</li>
</ul></li>
<li>thread是通过共享数据联系的，因此当两个thread有关系，只fork了一个，是可以正常工作的，因为fork出来的是一个process，是有这些共享数据的。</li>
</ul>
<h4 id="signals">Signals</h4>
<p>大多数的Unix的版本：thread能够说出其接受和拒绝的信号</p>
<p>Linux：dealing with threads and signals is tricky but well understood
with many tutorials on the matter and man pages</p>
<h4 id="safe-thread-cancellation">Safe Thread Cancellation</h4>
<p>一个潜在的有用特性是线程可以直接终止另一个线程</p>
<p>两种可能的方法:</p>
<ul>
<li><p>Asynchronous异步取消：一个线程立即终止另一个线程</p></li>
<li><p>Deferred延迟取消：线程定期检查它是否应该终止</p></li>
<li><p>可以调用线程取消请求取消一个线程，但实际取消取决于线程状态state</p>
<figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221020144531569.png" alt="image-20221020144531569">
<figcaption aria-hidden="true">image-20221020144531569</figcaption>
</figure></li>
<li><p>如果线程是cancellation
disabled的，取消请求会挂起，直到线程的cancellation enabled</p></li>
<li><p>默认的Type是Deffered，thread运行到cancellation
point时，cancellation才会发生</p>
<ul>
<li><code>pthread_testcancel()</code></li>
<li>然后调用清理处理程序</li>
</ul></li>
<li><p>在Linux中，thread cancellation是通过信号解决的</p></li>
</ul>
<h3 id="windows-threads">Windows Threads</h3>
<ul>
<li><p>提供API，可以让你创建Thread</p></li>
<li><p>实现的是one to one的</p></li>
<li><p>The register set, stacks, and private storage area are known as
the</p>
<p>context of the thread</p></li>
</ul>
<h3 id="linux-threads">Linux Threads</h3>
<p>TCB：Thread的task_struct</p>
<p><strong>Linux不区分PCB和TCB</strong>，一个Process有很多Thread的task_struct，哪一个才是Process的task_struct，一般来说，<strong>第一个Thread的task_struct就是整个Process的task_struct</strong></p>
<p>即第一个LWP的值就是process的PID</p>
<figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221020145555396.png" alt="image-20221020145555396">
<figcaption aria-hidden="true">image-20221020145555396</figcaption>
</figure>
<p>在Linux一个thread也称为LWP</p>
<p>syscall：clone()是创建一个thread或者一个process</p>
<p>fork就是调用固定参数的clone()</p>
<p>Linux用的task_struct既是给process的，也是给thread的。</p>
<h3 id="threads-within-process">Threads within Process</h3>
<ul>
<li>一个栈的大小是4KB对齐的，<span class="math inline">\(2^{12}=4K\)</span></li>
<li>list_head
<ul>
<li>一般是在中间的，因此有了list
head要找到task_struct的地址我们需要一个offset</li>
</ul></li>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221020152113591.png" alt="image-20221020152113591">
<figcaption aria-hidden="true">image-20221020152113591</figcaption>
</figure></li>
</ul>
<h3 id="user-thread-to-kernel-thread-mapping">User Thread to Kernel
Thread Mapping</h3>
<ul>
<li>One Task in Linux
<ul>
<li>有多个thread，process的task_struct来自于第一个thread的task_struct</li>
<li>一个thread，task_struct-PCB</li>
<li>用的都是User Space</li>
<li>当call了一个syscall，使用Kernel Space执行code</li>
<li>task_struct只有一个放在<strong>kernel space</strong></li>
</ul></li>
</ul>
<h2 id="lecture-7-1">Lecture 7-1</h2>
<h3 id="cpu-scheduling">CPU Scheduling</h3>
<ul>
<li>定义：OS决定哪个process/thread使用CPU使用多久。</li>
<li>Policy是我们的scheduling strategy</li>
<li>调度者：Mechanism程序</li>
<li>被调度对象：Process
<ul>
<li>I/O bound
<ul>
<li>大多数时间在等待I/O</li>
<li>Many short CPU bursts</li>
<li>交互式</li>
</ul></li>
<li>CPU bound
<ul>
<li>大多数时间在使用CPU</li>
<li>Very short I/O bursts if any</li>
</ul></li>
</ul></li>
<li>CPU bound和I/O
bound谁先被调度：都可以，看OS的实现。<strong>一般来说IO优先，因为cpu时间短，且是用户交互的</strong></li>
<li>CPU-burst：
<ul>
<li>short bursts多</li>
<li>large bursts少</li>
</ul></li>
</ul>
<h4 id="scheduling方法">Scheduling方法</h4>
<p>非抢占式non-preemptive：可以一直使用CPU到结束</p>
<p>抢占式preemptive：CPU可以被抢占</p>
<h5 id="scheduling的决策时机">Scheduling的决策时机</h5>
<ol type="1">
<li>RUNNING到WAITING
<ul>
<li>等IO操作</li>
</ul></li>
<li>RUNNING到READY
<ul>
<li>interrupt发生</li>
<li>在non-preemptive中不会发生</li>
</ul></li>
<li>WAITING到READY
<ul>
<li>IO完成了</li>
</ul></li>
<li>RUNNING到TERMINATED</li>
<li>NEW到READY</li>
</ol>
<p>目前的OS都是Preemptive的，复杂但是有用</p>
<h5 id="scheduling的目标">Scheduling的目标</h5>
<ul>
<li>使用率最大化CPU Utilization</li>
<li>最大化吞吐量Throughput</li>
<li>最小化周转时间Turnaround Time</li>
<li>最小化等待时间waiting time</li>
<li>最小化响应时间Response time</li>
</ul>
<h5 id="scheduling-queue">Scheduling Queue</h5>
<ul>
<li>Ready和Waiting状态有队列。</li>
<li>Device Queue</li>
</ul>
<p>Dispatcher</p>
<p>Dispatcher模块将CPU的控制权交给调度程序选择的进程：</p>
<ul>
<li>switching to kernel mode</li>
<li>switching context</li>
<li>switching to user mode</li>
</ul>
<p><strong>Gantt Graph和time要会用</strong></p>
<h5 id="scheduling-algorithm">Scheduling Algorithm</h5>
<p>如何挑选下一个在CPU上运行的Process？</p>
<p>什么是一个Good Policy？Scheduling Objective</p>
<p>One Thing is Certain：为了让Scheduling
Algorithm能跑得更快，算法不能太复杂</p>
<ol type="1">
<li><p>First-Come，First-Served</p>
<p>哪个进程先来arrive，先调度</p>
<p><strong>waiting time = start time - arrival time</strong></p>
<p><strong>turnaround time = finish time -arrival time</strong></p>
<p><strong>Gantt图：画时间轴</strong></p>
<p>Convoy Effect：前面跑得慢的，把后面的堵住了</p></li>
<li><p>Shortest Job First-SJF</p>
<p>短的先跑，越短越优先。证明是最优的。</p>
<p>Non-Preemptive：</p>
<p>不能被抢占，在完成一个process时才会调度</p>
<p>Preemptive：</p>
<p>会被抢占，shortest-remaining-time-first，根据当前最短的时间进行调度。</p>
<p>现实情况下，burst
time我们都不知道有多少。因此，这个算法难以使用。</p>
<p>我们一般要predict这个burst time，如何predict？根据Locality。</p>
<ul>
<li><span class="math inline">\(\tau_{n+1}=\alpha
t_n+(1-\alpha)\tau_n\)</span></li>
</ul></li>
<li><p>Round-Robin轮询</p>
<p>轮询：每一个process都有一个时间片time quantum</p>
<p>跑光了就换到下一个process，FIFO的Queue。</p>
<p>No Starvation</p>
<p>wait time is bound</p>
<p>如何选择时间片大小？</p>
<ul>
<li>短：context switch太多了整体的throughput变小，response好</li>
<li>长：throughput变大，response差</li>
<li>一般选择：10-100ms</li>
<li>context-switch time：1<span class="math inline">\(\mu
s\)</span></li>
</ul></li>
<li><p>Priority</p>
<p>Priority越大优先级越高，priority can be internal和external的</p>
<p>存在starvation，Priority小的可能无法运行。</p>
<p>相同的Priority可以用轮询进行scheduling</p></li>
<li><p>Multilevel Queue</p>
<p>有多个Level的Queue，</p>
<p>针对不同的Queue可以每一个Queue有不同的Schedule方法</p>
<p>不同的Queue之间可以有Schedule方法</p></li>
<li><p>Multilevel Feedback Queue</p>
<p>一个新的process来了，放入Q0，最高优先级，使用RR(q=8)</p>
<p>如果它的8没用完，说明它可能是IO的，优先级要高，下次还是要来Q0</p>
<p>如果用完了进入Q1给q=16，用完了下次来还是Q1，否则去Q2.</p>
<p>......</p>
<p>依次类推</p></li>
</ol>
<h2 id="lecture-7-2">Lecture 7-2</h2>
<h3 id="thread-scheduling">Thread Scheduling</h3>
<ul>
<li>以Process为力度进行Scheduling，process-contention-scope，PCS</li>
<li>每一个thread都可以进行scheduling，system-contention-scope，SCS</li>
</ul>
<p>Pthread都有两种方式的API，但是在Linux和Windows中，只能用SCS</p>
<h3 id="multiple-processor">Multiple-Processor</h3>
<ul>
<li>Symmetric multiprocessing
SMP，对称的，processor是一样重要的，每一个processor可以自行调度</li>
<li>Multiple core process
<ul>
<li>core是processor的基本计算单元</li>
<li>多个core使用一个queue
<ul>
<li>简单，慢，可能有锁，有竞争，效率低</li>
</ul></li>
<li>一个core对应一个queue
<ul>
<li>效率高，维护多个queue，复杂</li>
</ul></li>
</ul></li>
<li>Multi-threaded core/hyperthreading
<ul>
<li>一个core可以通过多线程穿插来最大化cpu使用率</li>
</ul></li>
</ul>
<h4 id="os-view">OS View</h4>
<ul>
<li>CPU1，CPU2，...，CPUn
<ul>
<li>core 1，core2，...，corem</li>
</ul></li>
<li>三级cache，一级二级core独享，三级共享</li>
</ul>
<h3 id="os-scheduling">OS Scheduling</h3>
<h4 id="windows">Windows</h4>
<ul>
<li>32个level的priority，数越大priority越高</li>
<li>time quantum，轮询，抢占机制</li>
<li>除非是realtime的实时操作系统的一部分，否则执行完time
quantum会降级</li>
<li>bogus：priority=0，idle process
<ul>
<li>idle是为了让队列里一直有可调度的process</li>
<li>手机里会跑idle但是时间不长，idle跑起来，core将会被关掉</li>
</ul></li>
</ul>
<h4 id="linux">Linux</h4>
<ul>
<li>数越小，优先级越高</li>
<li><code>ps -e -o uid,pid,ppid,pri,ni,cmd</code></li>
<li><code>nice -10 ./a.out</code>
<ul>
<li>nice值越大，thread越容易把cpu给别人</li>
</ul></li>
</ul>
<h2 id="lecture-8-1">Lecture 8-1</h2>
<h3 id="synchronization同步">Synchronization同步</h3>
<ul>
<li>现在的系统都是抢占式的</li>
<li>线程和进程是协同执行的，需要share一些内存</li>
</ul>
<h5 id="data-cursh">Data Cursh</h5>
<p><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221102101408662.png" alt="image-20221102101408662" style="zoom:67%;"></p>
<p>相当于变量没来得及存入内存就又被拿来用了。</p>
<h4 id="critical-section">Critical Section</h4>
<ul>
<li><p>每一个进程都有一个Critical Section：e.g., <strong>to change
common variables, update table, write file</strong>, etc.</p></li>
<li><p>Only one process can be in the critical section</p>
<ul>
<li><p>when one process in critical section, no other may be in its
critical section</p></li>
<li><p>each process must ask permission to enter critical section in
entry section</p></li>
<li><p>the permission should be released in exit section</p></li>
<li><p>Remainder section</p></li>
</ul>
<p><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221102102043967.png" alt="image-20221102102043967" style="zoom:80%;"></p></li>
<li><p>Critical Section Handling</p>
<ul>
<li>单核CPU的Critical保护：加锁，preventing interrupts独占cpu</li>
<li>Multiple-processor：interrupt难以起效果，我们加锁</li>
<li>三个Requirement
<ul>
<li>Mutual Exclusion互斥访问</li>
<li>Progress</li>
<li>Bounded waiting</li>
</ul></li>
<li><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221102102645787.png" alt="image-20221102102645787" style="zoom:80%;"></li>
</ul></li>
<li><p>Peterson's Solution</p>
<ul>
<li><p><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221102102933936.png" alt="image-20221102102933936" style="zoom:80%;"></p></li>
<li><p>P0想进去的话，flag0=true，他要看P1是不是要进去，如果p1要进去，那么p0就等待.</p></li>
<li><p>Peterson Solution满足三个requirement</p>
<ul>
<li>Mutual Exclusion：</li>
<li><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221102103357500.png" alt="image-20221102103357500" style="zoom:70%;"></li>
<li><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221102103623266.png" alt="image-20221102103623266" style="zoom:67%;"></li>
</ul></li>
<li><p>这种Solution不实用</p>
<ul>
<li>只能解决两个thread的问题。</li>
<li>它假设Load和Store都是原子的。</li>
<li>Instruction reorder，将指令重新排序。</li>
</ul></li>
</ul></li>
<li><p>Solutions：</p>
<ul>
<li>Memory barriers</li>
<li>Hardware instruction</li>
<li>Atomic variable</li>
</ul></li>
</ul>
<h4 id="memory-barriers">Memory Barriers</h4>
<p><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221102105853025.png" alt="image-20221102105853025" style="zoom:80%;"></p>
<p>Weakly ordered：容易出Bug，有可能会data
crash。但是容易实现。<strong>一般使用这个</strong></p>
<p>Strongly ordered：难实现，一个进程对内存的修改可以马上被看到。</p>
<h4 id="hardware-instructions">Hardware Instructions</h4>
<ul>
<li>Test-and-Set Instruction
<ul>
<li><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221102110628283.png" alt="image-20221102110628283" style="zoom:67%;"></li>
</ul></li>
<li>使用Test-and-Set的锁
<ul>
<li><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221102110705623.png" alt="image-20221102110705623" style="zoom: 50%;"></li>
<li>不满足bounded-waiting</li>
</ul></li>
<li>Compare-and-Swap
<ul>
<li><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221102111411711.png" alt="image-20221102111411711" style="zoom: 67%;"></li>
<li><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221102111512392.png" alt="image-20221102111512392" style="zoom:67%;"></li>
</ul></li>
</ul>
<h3 id="mutex-locks">Mutex Locks</h3>
<p><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221109100820601.png" alt="image-20221109100820601" style="zoom:80%;"></p>
<p>太多的Spinning Looping，因为大多数的thread都在busy waiting</p>
<h2 id="lecture-9-1">Lecture 9-1</h2>
<h3 id="semaphore">Semaphore</h3>
<p>为了避免busy waiting</p>
<p>信号量：同步工具，为进程同步其活动提供更复杂的方法(比互斥锁)。</p>
<p>有一个数S，一般为正数。有两个操作。</p>
<ul>
<li><p>wait()</p>
<ul>
<li>``` wait(S){ while(S&lt;=0) ;//busy waiting S--; }
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- <span class="built_in">signal</span>()</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    <span class="built_in">signal</span>(S)&#123;</span><br><span class="line">    	S++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<p>Counting Semaphore：计数信号量，整数值可以在不受限制的域范围内</p>
<p>Binary
Semaphore：二进制信号量，整数值只能在0到1之间。与互斥锁相同</p>
<p><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221109101815929.png" alt="image-20221109101815929" style="zoom:80%;"></p>
<p>每一个Semaphore都有一个waiting queue，因此我们有另外两个操作</p>
<ul>
<li>block：阻塞，将调用操作的进程放在适当的等待队列上</li>
<li>wakeup：唤醒，删除等待队列中的一个进程，并将其放入就绪队列中</li>
<li><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221109104016736.png" alt="image-20221109104016736" style="zoom:77%;"></li>
<li><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221109104103108.png" alt="image-20221109104103108" style="zoom:67%;">
<ul>
<li>这里的Semaphore sem；是全局的</li>
<li>其他的是对单个process做的</li>
<li>对于一个process，当期需要wait，它会被加入waiting
queue，那么整个while会被block掉，不再进行，其他的process执行完critical
section，signal会弹出waiting
queue中的下一个要执行的process，之前那个block的process继续运行。</li>
<li>当wait时，我们需要对value进行锁的保护，在其block之前需要释放锁。</li>
</ul></li>
</ul>
<p><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221109101627004.png" alt="image-20221109101627004" style="zoom:80%;"></p>
<figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221109110411257.png" alt="image-20221109110411257">
<figcaption aria-hidden="true">image-20221109110411257</figcaption>
</figure>
<p><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221109110421658.png" alt="image-20221109110421658" style="zoom:80%;"></p>
<h3 id="deadlock-and-starvation">Deadlock and Starvation</h3>
<p>死锁：两个或多个进程正在无限期地等待一个事件，而该事件只能由一个等待进程引起。</p>
<p><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221109102834841.png" alt="image-20221109102834841" style="zoom:67%;"></p>
<p>Starvation：无限期阻塞进程可能永远不会从信号量的等待队列中移除</p>
<h3 id="priority-inversion">Priority Inversion</h3>
<p>优先级倒置：高优先级进程被低优先级任务间接抢占。</p>
<ul>
<li>低优先级的任务持有锁，但由于低优先级的任务永远得不到CPU，因此永远不能完成和释放锁。</li>
<li>高优先级的任务永远等待锁</li>
</ul>
<p>Solution：优先级继承</p>
<ul>
<li>临时将等待进程(PH)的最高优先级分配给持有锁的进程(PL)</li>
<li>把低优先级的优先级提升至高优先级</li>
</ul>
<h3 id="linux的synchronization">Linux的Synchronization</h3>
<ul>
<li>atomic integer</li>
<li>spinlocks</li>
<li>semaphores
<ul>
<li><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221109105928463.png" alt="image-20221109105928463" style="zoom:70%;">
<ul>
<li>在down_common中实际上已经在block之前就释放锁了。</li>
</ul></li>
<li><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221109105950971.png" alt="image-20221109105950971" style="zoom:67%;"></li>
</ul></li>
<li>reader-writer locks</li>
</ul>
<h3 id="condition-variable">Condition Variable</h3>
<p>条件变量是同步原语，它使线程能够等待特定条件发生。条件变量是不能跨进程共享的用户模式对象。</p>
<p><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221109111724978.png" alt="image-20221109111724978" style="zoom:67%;"></p>
<h3 id="bounded-buffer-problem">Bounded-Buffer Problem</h3>
<p>两个进程，生产者和消费者共享n个缓冲区</p>
<ul>
<li>生产者生成数据，将数据放入缓冲区</li>
<li>消费者通过从缓冲区中删除数据来使用数据。</li>
</ul>
<p>问题是要确保:</p>
<ul>
<li>如果缓冲区已满，生产者不会尝试向缓冲区中添加数据</li>
<li>消费者不会尝试从空缓冲区中删除数据，这也称为</li>
<li>Producer-Consumer问题</li>
</ul>
<p>解决方案：</p>
<ul>
<li>N个缓冲区，每个缓冲区可以保存一个项</li>
<li>信号量mutex互斥锁初始化为值1</li>
<li>信号量full-slots满槽初始化为值0</li>
<li>信号量empty-slots空槽初始化为值N</li>
</ul>
<h4 id="producer">Producer</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="comment">//produce an item</span></span><br><span class="line">    <span class="built_in">wait</span>(empty-slots)</span><br><span class="line">    <span class="built_in">wait</span>(mutex)</span><br><span class="line">    <span class="comment">//顺序不能换，因为如果empty为0，那么会带着mutex sleep</span></span><br><span class="line">    <span class="comment">//add the item to the buffer</span></span><br><span class="line">    <span class="built_in">signal</span>(mutex)</span><br><span class="line">    <span class="built_in">signal</span>(full-slots)</span><br><span class="line">&#125;<span class="keyword">while</span>(TRUE)</span><br></pre></td></tr></table></figure>
<h4 id="consumer">Consumer</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	<span class="comment">//consume an item</span></span><br><span class="line">    <span class="built_in">wait</span>(full-slots)</span><br><span class="line">    <span class="built_in">wait</span>(mutex)</span><br><span class="line">    <span class="comment">//add the item to the buffer</span></span><br><span class="line">    <span class="built_in">signal</span>(mutex)</span><br><span class="line">    <span class="built_in">signal</span>(empty-slots)</span><br><span class="line">&#125;<span class="keyword">while</span>(TRUE)</span><br></pre></td></tr></table></figure>
<h3 id="reader-and-writer-problem">Reader and Writer Problem</h3>
<p>一个数据集在多个并发进程读取器之间共享</p>
<ul>
<li>reader：只读取该数据集，它们不执行任何更新</li>
<li>writer：既可以读也可以写</li>
</ul>
<p>Reader-Writer问题：</p>
<ul>
<li>允许多个读取器同时读取(共享访问)share</li>
<li>只有一个写入器可以访问共享数据(独占访问)exclusive</li>
</ul>
<p>解决方案：</p>
<ul>
<li>信号量互斥锁mutex初始化为1</li>
<li>信号量写write初始化为1</li>
<li>整数读计数readcount初始化为0</li>
</ul>
<h4 id="writer">Writer</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	<span class="built_in">wait</span>(write)</span><br><span class="line">	<span class="comment">//write the data</span></span><br><span class="line">	<span class="built_in">signal</span>(write)</span><br><span class="line">&#125;<span class="keyword">while</span>(TRUE)</span><br></pre></td></tr></table></figure>
<h4 id="reader">Reader</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	<span class="built_in">wait</span>(mutex)</span><br><span class="line">	<span class="comment">//保护readcount</span></span><br><span class="line">	readcount++;</span><br><span class="line">	<span class="keyword">if</span>(readcount == <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">wait</span>(write);</span><br><span class="line">		<span class="comment">//如果有reader，不允许写</span></span><br><span class="line">        <span class="comment">//reader，first</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">signal</span>(mutex)</span><br><span class="line">	<span class="comment">//reading data</span></span><br><span class="line">	<span class="built_in">wait</span>(mutex)</span><br><span class="line">	readcount--;</span><br><span class="line">	<span class="keyword">if</span>(readcount == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">signal</span>(write);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">signal</span>(mutex);</span><br><span class="line">&#125;<span class="keyword">while</span>(TRUE)</span><br></pre></td></tr></table></figure>
<h3 id="dining-philosophers-problem">Dining-Philosophers Problem</h3>
<p>哲学家一生都在思考和吃饭</p>
<ul>
<li>他们坐在一张圆桌上，但彼此不互动</li>
</ul>
<p>只有五根筷子，他们偶尔会拿起两根筷子(一次一根)吃东西</p>
<ul>
<li>哲学家问题代表了多资源同步</li>
</ul>
<p>解决方案：</p>
<ul>
<li>semaphore chopstick[5] 初始化为1</li>
</ul>
<p>当心死锁，比如所有的人拿起了一根筷子。</p>
<h2 id="lecture-9-2">Lecture 9-2</h2>
<h3 id="deadlock">DeadLock</h3>
<ul>
<li>死锁：两个或多个进程正在无限期地等待一个事件，而该事件只能由一个等待进程引起。类似循环等待。</li>
<li>当一个死锁发生，我们可以使用back up的方法。</li>
<li><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221110131849927.png" alt="image-20221110131849927" style="zoom:67%;"></li>
</ul>
<h4 id="死锁的四个条件">死锁的四个条件</h4>
<ul>
<li>Mutual exclusion：资源互斥，一个资源一次只能被一个进程使用</li>
<li>Hold and
wait：持有至少一个资源的进程正在等待获得其他进程持有的额外资源</li>
<li>No
preemption：非抢占式，资源只能由持有它的进程在完成任务后自动释放</li>
<li>Circular wait：存在一组等待进程Po, P1，…，Pn。
<ul>
<li>Po正在等待P1持有的资源</li>
<li>P1正在等待P2持有的资源</li>
<li>......</li>
<li>Pn-1在等待由Pn持有的资源</li>
<li>Pn正在等待Po持有的资源</li>
</ul></li>
</ul>
<h4 id="resource-allocation-graph">Resource-Allocation Graph</h4>
<p>资源分配图，有两种节点：</p>
<ul>
<li><span class="math inline">\(P=\{P_1,...,P_n\}\)</span>，系统中所有的进程</li>
<li><span class="math inline">\(R=\{R_1,...,R_m\}\)</span>，系统中所有的资源类型</li>
</ul>
<p>两种边：</p>
<ul>
<li>request edge：<span class="math inline">\(P_i\rarr
R_j\)</span>，Pi需要资源Rj</li>
<li>assignment edge：<span class="math inline">\(R_j\rarr
P_i\)</span>，资源Rj被Pi占用</li>
</ul>
<p><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221110132421596.png" alt="image-20221110132421596" style="zoom:80%;"></p>
<p>如果图中不包含循环，则不存在死锁</p>
<p>如果图包含一个循环</p>
<ul>
<li>如果每个资源类型只有一个实例，则死锁</li>
<li>如果每个资源类型有多个实例，则有死锁的可能</li>
</ul>
<h3 id="死锁的解决">死锁的解决</h3>
<ul>
<li>确保系统永远不会进入死锁状态
<ul>
<li>预防Prevention：从四个条件入手，打破条件</li>
<li>避免Avoidance</li>
</ul></li>
<li>允许系统进入死锁状态，然后恢复-数据库
<ul>
<li>死锁检测和恢复</li>
</ul></li>
<li>忽略这个问题，假装系统中从未发生死锁</li>
</ul>
<h4 id="prevention">Prevention</h4>
<ul>
<li>如何防止互mutual exclusion
<ul>
<li>不需要共享资源</li>
<li>必须持有非共享资源</li>
</ul></li>
<li>如何防止持有和等待
<ul>
<li>每当一个进程请求一个资源时，它并不持有任何其他资源
<ul>
<li>要求进程在开始执行之前请求其所有资源，只有当进程有资源时，才执行</li>
<li>只有当进程有资源时，才允许进程请求资源没有一个</li>
</ul></li>
<li>资源利用率低；饥饿成为可能</li>
</ul></li>
</ul>
<p><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221110133643539.png" alt="image-20221110133643539" style="zoom:77%;"></p>
<p><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221110133630082.png" alt="image-20221110133630082" style="zoom:67%;"></p>
<h4 id="avoidance">Avoidance</h4>
<p>使用一种算法跑一下，是否发生死锁。</p>
<p>Banker’s Algorithm</p>
<ul>
<li>allocation矩阵，资源已经分配的矩阵</li>
<li>max矩阵，进程需要的资源的矩阵</li>
<li>need矩阵，max-allocation</li>
<li>available：不同资源的剩余量</li>
</ul>
<p>算法：</p>
<ul>
<li>找available大于need的process，那么这个process会运行完，资源被回收。
<ul>
<li>available = available+allocation</li>
</ul></li>
<li>一直执行，如果所有的process能被完成，那么就是safe
state，不存在死锁</li>
<li>否则就存在死锁了</li>
</ul>
<h4 id="deadlock-detection">Deadlock Detection</h4>
<p>画wait for graph</p>
<p><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221110135646024.png" alt="image-20221110135646024" style="zoom:67%;"></p>
<h4 id="deadlock-recovery">Deadlock Recovery</h4>
<ul>
<li>将process全部释放</li>
<li>一个一个释放，直到死锁没了
<ul>
<li>我们如何选择abort的process
<ul>
<li>优先级</li>
<li>resource的占用量</li>
<li>......</li>
</ul></li>
</ul></li>
<li>Resource preemption
<ul>
<li>选择一个victim</li>
<li>Rollback</li>
<li>Starvation</li>
</ul></li>
</ul>
<h2 id="lecture-10-1">Lecture 10-1</h2>
<h3 id="main-memory">Main Memory</h3>
<p>memory就是一块存储，里面是数据，如何理解取决于如何解释。memory就是一张白纸，我们需要管理它。</p>
<ul>
<li>main memory和register就是CPU能够access的储存</li>
<li>memory unit能看到address + read request或者address+data+write
request</li>
<li>Cache在main memory和CPU register之间</li>
<li>内存需要保护</li>
</ul>
<p>多processes需要同时在memory中运行</p>
<ul>
<li>fast switching</li>
<li>partitioning，分块
<ul>
<li>Protection</li>
<li>Fast execution</li>
<li>Fast context switch</li>
</ul></li>
<li><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221110142540383.png" alt="image-20221110142540383" style="zoom:50%;"></li>
<li>Loading a Process
<ul>
<li>重新定位相对于分区开始的所有地址</li>
<li>操作系统分配的内存保护
<ul>
<li>一个块一个块地到物理内存</li>
</ul></li>
<li>一旦流程启动分区
<ul>
<li>不能在内存中移动</li>
<li>为什么？因为绝对地址不能变</li>
<li>一旦绝对地址变了，程序中的数据都要变</li>
<li>因此引入Logical Address</li>
</ul></li>
</ul></li>
</ul>
<p><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221110142914044.png" alt="image-20221110142914044" style="zoom:80%;"></p>
<ul>
<li>使用相对地址，即我们使用Logical Address</li>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221110143246696.png" alt="image-20221110143246696">
<figcaption aria-hidden="true">image-20221110143246696</figcaption>
</figure></li>
<li>MMU来进行地址的转换，即操作系统进行内存的映射。</li>
</ul>
<h4 id="partition">Partition</h4>
<p>每个Process看到的地址是0到max的即<strong>逻辑地址Logical
Address</strong>，想要物理地址需要寻址。</p>
<p>有两个寄存器Base、limit</p>
<p>Base：process的起点</p>
<p>Base+limit：process的终点</p>
<p>保护：我们有用户看到的地址为a，那么a的物理地址是a+Base，判断这个地址是否在Base+limit以内，不能访问其他process的地址。</p>
<p><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221110143730229.png" alt="image-20221110143730229" style="zoom:80%;"></p>
<p>那么move的话，我们就只需要改变Base寄存器的值和复制即可</p>
<p><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221110144243060.png" alt="image-20221110144243060" style="zoom:67%;"></p>
<p>CPU使用的是Logical address</p>
<h4 id="优势">优势</h4>
<ul>
<li>加载时不重定位程序地址
<ul>
<li>所有地址都相对于零</li>
<li>限位提供内置保护
<ul>
<li>每个页面或块没有物理保护</li>
</ul></li>
<li>快速执行
<ul>
<li>在每个指令内以硬件速度进行加法和限制检查</li>
</ul></li>
<li>快速上下文切换
<ul>
<li>只需要改变base和limit寄存器</li>
</ul></li>
<li>分区可以在任何时候挂起和移动
<ul>
<li>进程不知道更改</li>
<li>对于大型流程来说成本昂贵</li>
</ul></li>
</ul></li>
</ul>
<h4 id="memory-allocation-strategies">Memory Allocation Strategies</h4>
<ul>
<li>Fixed partition：内存切分成等大小的part
<ul>
<li>process大：用多个part</li>
<li>process小：再小也要用一个</li>
<li>内部分裂Internal Fragmentation
<ul>
<li>分区内未使用的内存很大</li>
<li>内存浪费</li>
</ul></li>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221116100739690.png" alt="image-20221116100739690">
<figcaption aria-hidden="true">image-20221116100739690</figcaption>
</figure></li>
</ul></li>
<li>Variable partition：堆内存的切分是根据process的需要来的
<ul>
<li>没有internal fragmentation</li>
<li>但是有external fragmentation
<ul>
<li>已分配内存块之间的不可用内存总可用内存空间大于一个请求，由于空闲内存不是连续的，因此请求不能被满足</li>
</ul></li>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221110150028346.png" alt="image-20221110150028346">
<figcaption aria-hidden="true">image-20221110150028346</figcaption>
</figure></li>
<li>如何从空闲内存块列表中满足大小为n的请求?
<ul>
<li>First-Fit：从第一个足够大的块进行分配</li>
<li>Best-Fit：从足够大的最小块进行分配</li>
<li>Worst-Fit：从最大的块分配</li>
</ul></li>
</ul></li>
</ul>
<h3 id="segmentation">Segmentation</h3>
<p>Partition的一种方法。</p>
<figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221110151152522.png" alt="image-20221110151152522">
<figcaption aria-hidden="true">image-20221110151152522</figcaption>
</figure>
<p>将一个program分成多个segment</p>
<p>process有一个segment table（in
memory），有一个reg指向它，reg的内容是segment id + offset</p>
<p>segment id从segment
table中倒找<strong>limit和base</strong>，base+offset就是Physical
Address</p>
<p><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221110151738015.png" alt="image-20221110151738015" style="zoom:67%;"></p>
<h4 id="address-binding">Address Binding</h4>
<p>地址在不同的时期呈现不同的表示</p>
<ul>
<li>source code：symbolic</li>
<li>complier：relocatable addresses</li>
<li>linker：absolute address</li>
</ul>
<p><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221110152348495.png" alt="image-20221110152348495" style="zoom:80%;"></p>
<h4 id="logical-vs-physical-address">Logical vs Physical Address</h4>
<p>Logical Address是我们人为规定的地址，其格式是可以人为定义的。</p>
<p>绑定到单独物理地址空间的逻辑地址空间的概念是正确的内存管理的核心。</p>
<ul>
<li>逻辑地址——由CPU生成，也称为虚拟地址</li>
<li>物理地址——内存单元看到的地址</li>
</ul>
<p>逻辑地址和物理地址在编译时和加载时地址绑定方案中是相同的。逻辑(虚拟)地址和物理地址在执行时地址绑定方案中是不同的。</p>
<ul>
<li>逻辑地址空间是程序生成的所有逻辑地址的集合</li>
<li>物理地址空间是程序生成的所有物理地址的集合</li>
</ul>
<h4 id="mmu">MMU</h4>
<p><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221110152603583.png" alt="image-20221110152603583" style="zoom:80%;"></p>
<p><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221110152614740.png" alt="image-20221110152614740" style="zoom:80%;"></p>
<h3 id="paging分页">Paging分页</h3>
<p>我们想把一个process给切分了放在memory里</p>
<p><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221116102022652.png" alt="image-20221116102022652" style="zoom:67%;"></p>
<p>[分段和分页的区别][https://geek-docs.com/operating-system/os-ask-answer/the-difference-between-pagination-and-segmentation.html]</p>
<p>我们把physical address空间分成固定大小的块，叫做frames</p>
<ul>
<li>通常是4K大小</li>
</ul>
<p>把logical address分成块，叫做pages。即把process给分割了。</p>
<p>page要映射到frames上去，通过page
table，将逻辑地址转换为物理地址。</p>
<ul>
<li>不会有external fragmentation</li>
<li>internal fragmentation很小</li>
</ul>
<h4 id="page-table">Page Table</h4>
<p>储存logical page到physical frame的映射</p>
<ul>
<li>Example：
<ul>
<li>简单的page table</li>
</ul></li>
</ul>
<p>逻辑地址我们可以如下表示</p>
<figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VA</span> = | page number | page offset |</span><br><span class="line">         m-n bits       n bits</span><br></pre></td></tr></table></figure>
<p>page number：你是哪个page的</p>
<p>page
offset：你是这个page中哪个位置的，4K的page，我们用12位就可以表示</p>
<h5 id="页面转换的过程">页面转换的过程</h5>
<p>根据page number从page table中找physical frame</p>
<p>physical frame+page offset就是物理地址</p>
<figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221116101917399.png" alt="image-20221116101917399">
<figcaption aria-hidden="true">image-20221116101917399</figcaption>
</figure>
<h4 id="硬件实现">硬件实现</h4>
<p>Page Table放在内存里，我们需要寄存器存放page
table的基地址，在riscv中是SATP。</p>
<p>每一个Process有一个自己的page table，因此做context
switch时，需要save这个satp。</p>
<h3 id="tlb">TLB</h3>
<p>Translation look-aside buffer caches the address translation</p>
<p>存储一些PTE，以便后续使用</p>
<ul>
<li>if page number is in the TLB, no need to access the page table</li>
<li>if page number is not in the TLB, need to replace one TLB entry</li>
<li>TLB usually use a fast-lookup hardware cache called associative
memory</li>
<li>TLB is usually small, 64 to 1024 entries</li>
</ul>
<p>Use with page table</p>
<ul>
<li>TLB contains a few page table entries</li>
<li>Check whether page number is in TLB
<ul>
<li>If -&gt; frame number is available and used</li>
<li>If not -&gt; TLB miss. access page table and then fetch into
TLB</li>
</ul></li>
</ul>
<p>在context switch时，因为我们要防止process访问其他process的frame</p>
<ul>
<li>Option 1：TLB中的entry全部flush掉。不好0。</li>
<li>Option 2：TLB中只flush这个process的。</li>
</ul>
<p><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221116103738704.png" alt="image-20221116103738704" style="zoom:67%;"></p>
<h4 id="tlb的效率">TLB的效率</h4>
<p><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221116104546261.png" alt="image-20221116104546261" style="zoom:67%;"></p>
<h3 id="memory-protection">Memory Protection</h3>
<p>使用保护位</p>
<ul>
<li>每一个page都有一个present（valid）位，表示：page已经映射到物理frame了，能被access</li>
<li>kernel/user、read/write、execution、kernel-execution</li>
<li>保护位加在PTE中。</li>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221116110125094.png" alt="image-20221116110125094">
<figcaption aria-hidden="true">image-20221116110125094</figcaption>
</figure></li>
</ul>
<h3 id="page-sharing">Page Sharing</h3>
<p>运行两个相同的process，text段是一致的，我们想省点内存。如图，ed1、ed2、ed3是共享的，物理内存是一致的。</p>
<figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221116110557880.png" alt="image-20221116110557880">
<figcaption aria-hidden="true">image-20221116110557880</figcaption>
</figure>
<h3 id="structure-of-page-table">Structure of Page Table</h3>
<p>一级页表消耗了很多的内存。</p>
<ul>
<li>32bit的逻辑地址空间，4KB的page size</li>
<li>entry 个数：<span class="math inline">\(2^{(32-12)}=1M\)</span>的entry</li>
<li>每一个entry长度4Byte，页表一共占用了4MB的内存</li>
<li><strong>要求物理连续</strong></li>
</ul>
<p>为了减少内存消耗，有很多方法：</p>
<ul>
<li>hierarchical page table 多级页表</li>
<li>hashed page table</li>
</ul>
<p>因此我们选择使用多级页表</p>
<p>1M个entry需要1K个page(4K)来放，<strong>一个page可以放1K个entry。</strong></p>
<p><strong>有1K个Page</strong>，因此是10+10+12</p>
<h4 id="如何寻址">如何寻址：</h4>
<figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221116112111420.png" alt="image-20221116112111420">
<figcaption aria-hidden="true">image-20221116112111420</figcaption>
</figure>
<figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221116112200214.png" alt="image-20221116112200214">
<figcaption aria-hidden="true">image-20221116112200214</figcaption>
</figure>
<h4 id="内存占用">内存占用：</h4>
<ul>
<li>一级页表：1个Page</li>
<li>二级页表：按照实际的情况1Page~1Kpage不等</li>
</ul>
<h5 id="eg64bit时使用39位逻辑地址">EG：64bit时，使用39位逻辑地址</h5>
<ul>
<li>一个entry是64bit，8byte</li>
<li>一个Page 4KB</li>
<li>一个Page装512=2^9个entry</li>
<li><span class="math inline">\(2^{39-12} = 2^{27}\)</span>个entry</li>
<li>需要<span class="math inline">\(2^{18}\)</span>个page</li>
<li>有<span class="math inline">\(2^{18}\)</span>个三级页表，相当于二级页表要index这么多个entry</li>
<li>有<span class="math inline">\(2^9\)</span>个二级页表</li>
<li>有1个一级页表</li>
</ul>
<figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221116113310335.png" alt="image-20221116113310335">
<figcaption aria-hidden="true">image-20221116113310335</figcaption>
</figure>
<h4 id="多级页表的tlb">多级页表的TLB</h4>
<p>以9+9+9+12为例，一级页表可以index 1GB，二级页表可以index
2MB，三级页表可以index
4KB，因此我们需要TLB在三级也表上更多，一级更少。</p>
<h2 id="lecture-10-2">Lecture 10-2</h2>
<h3 id="inverted-page-table">Inverted Page Table</h3>
<p>使用物理内存映射虚拟内存</p>
<p>Inverted page table tracks allocation of physical frame to a
process</p>
<ul>
<li>one entry for each physical frame ➔ fixed amount of memory for page
table</li>
<li>each entry has the process id and the page# (virtual address)</li>
</ul>
<figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221117152420013.png" alt="image-20221117152420013">
<figcaption aria-hidden="true">image-20221117152420013</figcaption>
</figure>
<ul>
<li>需要遍历查找对应pid和page num，这开销很大</li>
</ul>
<h3 id="swapping">Swapping</h3>
<ul>
<li>使用physical的存储，来代替内存。</li>
<li>交换磁盘通过备份磁盘扩展物理内存进程
<ul>
<li>可以临时从内存中交换到后备存储
<ul>
<li>后备存储通常是一个(快速)磁盘</li>
</ul></li>
<li>进程将被带回内存中继续执行进程
<ul>
<li>是否需要交换回相同的物理地址?</li>
</ul></li>
</ul></li>
<li>交换通常只在内存压力下启动由于交换</li>
<li>上下文切换时间可能变得非常长
<ul>
<li>如果下一个要运行的进程不在内存中，需要交换它在</li>
<li>磁盘I/O有很高的延迟</li>
</ul></li>
</ul>
<p><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221117153226216.png" alt="image-20221117153226216" style="zoom:80%;"></p>
<p><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221117153245956.png" alt="image-20221117153245956" style="zoom:80%;"></p>
<h3 id="page和segmentation">Page和Segmentation</h3>
<ul>
<li>目的都是为了隔离。</li>
<li>https://blog.csdn.net/zhongyangtony/article/details/80879425</li>
</ul>
<h3 id="pae">PAE</h3>
<figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221117154724959.png" alt="image-20221117154724959">
<figcaption aria-hidden="true">image-20221117154724959</figcaption>
</figure>
<h3 id="linux-1">Linux</h3>
<figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221117154805082.png" alt="image-20221117154805082">
<figcaption aria-hidden="true">image-20221117154805082</figcaption>
</figure>
<h2 id="lecture-11-1">Lecture 11-1</h2>
<p>Page Size变大了：Internal fragmentation变大， 访问更迅速。</p>
<ul>
<li>Page Size 64KB
<ul>
<li>64-bit，39bitVA</li>
<li>offset：<span class="math inline">\(2^{16}=64K\)</span>，16位</li>
<li>一个Page多少个entry？
<ul>
<li><span class="math inline">\(64KB/64bit=8K=2^{13}\)</span>，13位</li>
</ul></li>
<li>多少个Page？
<ul>
<li><span class="math inline">\(2^{39-16}=2^{23}\)</span>个entry</li>
<li><span class="math inline">\(2^{23}/2^{13}=2^{10}\)</span>个Page</li>
<li>10位</li>
</ul></li>
<li>10+13+16</li>
</ul></li>
<li>Page Size 64KB
<ul>
<li>64-bit，48VA</li>
<li>offset：16位</li>
<li>一个Page有<span class="math inline">\(2^{13}\)</span>个entry，13位</li>
<li>有<span class="math inline">\(48-16=32\)</span>个entry，需要<span class="math inline">\(2^{32-13}=2^{19}\)</span>个Page</li>
<li>注意到19大于13，可以将每一个page看成一个entry，再加一级页表，13位</li>
<li>最后的是6位</li>
<li>6+13+13+16</li>
</ul></li>
</ul>
<h3 id="linux-and-virtual-memory">Linux and Virtual Memory</h3>
<h4 id="flat-memory">Flat Memory</h4>
<ul>
<li>古老和现代，但简单的系统有一个单一地址空间
<ul>
<li>内存和外设共享
<ul>
<li>内存将被映射到一个部件</li>
<li>外设将被映射到另一个外设</li>
</ul></li>
<li>所有进程和操作系统共享相同的内存空间
<ul>
<li>没有内存保护</li>
<li>用户空间可以使用内核</li>
</ul></li>
</ul></li>
<li>老的Memory Map是内存都已经分配好的
<ul>
<li>Portable C programs expect flat memory
<ul>
<li>Accessing memory by segments limits portability</li>
</ul></li>
<li>Management is tricky
<ul>
<li>Partition</li>
</ul></li>
<li>No Protection</li>
</ul></li>
</ul>
<h3 id="virtual-memory">Virtual Memory</h3>
<ul>
<li>虚拟地址（逻辑地址）是一种地址映射
<ul>
<li>将虚拟地址映射到物理地址空间上去</li>
<li>映射虚拟地址到物理RAM</li>
<li>映射虚拟内存到硬件设备</li>
</ul></li>
<li>优势：
<ul>
<li>每一个Process有不同的memory mapping
<ul>
<li>一个进程不会被别的进程看到RAM</li>
<li>Kernel和User的内存也不会共享</li>
</ul></li>
<li>Memory can be moved</li>
<li>Memory can be swapped to disk</li>
<li>硬件设备的memory能被映射到process的地址空间</li>
<li>硬件设备的memory能被多个process共享
<ul>
<li>shared memory、shared libraries</li>
</ul></li>
</ul></li>
<li>两个地址
<ul>
<li>物理地址
<ul>
<li>有真正的存储，硬件Memory、Hardware看到的地址是物理地址</li>
</ul></li>
<li>虚拟地址
<ul>
<li>没有真正的存储，CPU看到的都是虚拟地址。</li>
</ul></li>
<li>Mapping是硬件做的：MMU</li>
</ul></li>
</ul>
<h4 id="mmu-1">MMU</h4>
<p>MMU是用来转换虚拟地址到物理地址的，即做映射。</p>
<ul>
<li>坐落在CPU和Memory之间</li>
<li>Transparently handles all memory accesses from Load/Store
instructions
<ul>
<li>映射虚拟地址到物理地址</li>
<li>Handles Permissions</li>
<li>访问错误的地址，会有一个exception：Page Fault</li>
</ul></li>
</ul>
<h5 id="tlb-1">TLB</h5>
<p>TLB是MMU的一部分，MMU做地址转换前需要询问TLB。</p>
<ul>
<li>TLB类似于一个Cache</li>
</ul>
<h5 id="page-fault">Page Fault</h5>
<p>A page fault is a CPU exception, generated when software attempts to
use an invalid virtual address. There are three cases：</p>
<ul>
<li>虚拟地址没有映射，即V值为1</li>
<li>进程对请求的地址没有足够的权限。</li>
<li>虚拟地址是有效的，但swapped了（这是一个软件条件）</li>
</ul>
<h4 id="lazy-allocation">Lazy Allocation</h4>
<p>The kernel uses lazy allocation of physical memory</p>
<ul>
<li>当memory被用户程序请求，物理地址不会被申请，直到it is touched
<ul>
<li>只是加了一下数，这个程序allocate了一定的内存</li>
<li>真正用内存时，才会真的allocate这些内存</li>
</ul></li>
<li>这是一种优化，因为用户的程序申请的内存往往比使用的要大。</li>
</ul>
<h4 id="linux-virtual-addresses">Linux-Virtual Addresses</h4>
<ul>
<li>在Linux中kernel和user都是用虚拟地址
<ul>
<li>高地址部分是kernel，低地址是user</li>
<li>划分处是0xC0000000</li>
<li>32bit时是1G的kernel和3G的user</li>
<li>为什么是4G的内存？
<ul>
<li><span class="math inline">\(2^{32}\)</span>个地址</li>
<li>每个地址中存放一个Byte</li>
<li>一共是4GB</li>
</ul></li>
</ul></li>
<li><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221123105947489.png" alt="image-20221123105947489" style="zoom:50%;"></li>
<li>每一个Process将会有一个独立的对user virtual address映射</li>
<li>这个mapping也要在context switch中交换</li>
<li>在64bit中的内存划分？
<ul>
<li>前缀FFFF的是Kernel，前缀是0000的是User</li>
<li><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221123111019298.png" alt="image-20221123111019298" style="zoom:67%;"></li>
</ul></li>
<li>Arm 64
<ul>
<li>39 bit page table</li>
<li>3 level：9+9+9+12</li>
<li>那就是64位的前25位为0时，user</li>
<li>64位的前25位为1时，kernel</li>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221123195048778.png" alt="image-20221123195048778">
<figcaption aria-hidden="true">image-20221123195048778</figcaption>
</figure></li>
</ul></li>
</ul>
<h4 id="virtual-address-and-physical-ram-mapping">Virtual address and
physical RAM mapping</h4>
<ul>
<li>Kernel如何管理物理RAM？[为什么要映射所有的物理内存][https://www.zhihu.com/question/321040802]</li>
<li>必须将RAM映射到Kernel的地址空间
<ul>
<li>Must have an address in kernel AS</li>
<li>对于32bit的kernel的地址空间是1G的
<ul>
<li>32位架构下，kernel space只有1G</li>
<li>可以handle小的RAM≤896MB</li>
</ul></li>
</ul></li>
<li>那么如果物理内存大于kernel space怎么办？
<ul>
<li>我们先把896MB映射到kernel里面，剩下了128MB</li>
<li>这128MB是暂时的共享的映射</li>
</ul></li>
<li>Kernel Logical Address
<ul>
<li>通过线性映射物理内存使用PAGE_OFFSET</li>
<li>First 896MB的Kernel AS</li>
<li>先线性映射896MB，想要转换只用加减PAGE_OFFSET</li>
<li>使得虚拟地址和物理地址的转化更方便</li>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221123195550269.png" alt="image-20221123195550269">
<figcaption aria-hidden="true">image-20221123195550269</figcaption>
</figure></li>
</ul></li>
<li>32位中，如果物理内存大于1G：
<ul>
<li>不是所有的物理内存都Linear Map，只Linear
Map了896MB，剩下的128MB用来暂时映射</li>
<li>即低位【Low Memory】是Linear Map</li>
<li>高位【High
Memory】是想要用时对物理地址进行Map，使用完毕就清除掉。</li>
<li><strong>High Memory找物理地址可以使用Walk Page
Table即可</strong></li>
<li><strong>Low Memory可以使用OFFSET也可以使用Page Table</strong></li>
</ul></li>
<li>39-bit Kernel AS
<ul>
<li>kernel address space
<ul>
<li><span class="math inline">\(2^{39}*1byte=512GB\)</span></li>
</ul></li>
</ul></li>
<li>48-bit Kernel AS
<ul>
<li>kernel address space
<ul>
<li><span class="math inline">\(2^{48}*1byte=256TB\)</span></li>
</ul></li>
</ul></li>
<li><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221123201732416.png" alt="image-20221123201732416" style="zoom:67%;"></li>
</ul>
<ol type="1">
<li><p>User Virtual Address</p>
<p>是乱序的，必须走Page Table</p></li>
<li><p>Kernel Virtual Address</p>
<p>是乱序的，必须走Page Table</p></li>
<li><p>Kernel Logicl Address</p>
<p>使用PAGE_OFFSET，也可以使用Page Table</p></li>
</ol>
<h4 id="share-memory-1">Share Memory</h4>
<p>Process 1和Process 2的虚拟地址可以映射到同一个物理地址上。</p>
<h2 id="lecture-11-2">Lecture 11-2</h2>
<h3 id="page-fault-1">Page Fault</h3>
<figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221124143909685.png" alt="image-20221124143909685">
<figcaption aria-hidden="true">image-20221124143909685</figcaption>
</figure>
<ul>
<li>程序需要内存时，增大内存的虚拟地址空间，但是新的Page没有映射到物理地址</li>
<li>程序访问了新的内存，会有Page Fault</li>
<li>kernel给page一个frame对应，增加页表中的项，这个新的page映射到内存上</li>
</ul>
<h3 id="swapping-1">Swapping</h3>
<ul>
<li>当内存分配较高时，内核可能会将一些帧交换到磁盘以释放RAM。
<ul>
<li>拥有一个MMU使这成为可能。</li>
</ul></li>
<li>内核可以将一个帧复制到磁盘并删除它的TLB项。</li>
<li>该框架可以被另一个进程重用。</li>
</ul>
<p>过程：</p>
<ul>
<li>当帧再次被需要时，CPU将产生一个页面错误(因为地址不在TLB中)</li>
<li>然后，在页面出错时，内核可以
<ul>
<li>让流程休眠</li>
<li>从磁盘复制帧到RAM中</li>
<li>未使用的帧修复页表条目</li>
<li>唤醒进程</li>
</ul></li>
</ul>
<h3 id="demanding-paging">Demanding Paging</h3>
<ul>
<li><p>代码需要load到内存里才能成为进程</p></li>
<li><p>由于Lazy Allocate机制，可能一开始的Frame一个都没有</p>
<ul>
<li>一开始就出现Page Fault</li>
<li>有了Page Fault就映射一个物理地址，即Load Frame</li>
</ul></li>
<li><p>Partially Load</p>
<ul>
<li>使用Page实现内存的分次加载，需要哪些Page，Load哪些Page，不用一次性全部Load进来</li>
<li>创建一个Process，我们需要Page Table，VMA Structure</li>
</ul></li>
<li><p>Shared Library</p>
<ul>
<li>就是一块物理内存，被映射到虚拟地址</li>
</ul></li>
<li><p>Demand Paging就是之前说的Page Fault机制</p>
<ul>
<li>就是Page需要的时候，才会有物理Frame Load进来</li>
<li>mapping for new pages</li>
<li>swapping for swapped pages</li>
<li>没有不必要的IO，更少的内存需求，响应速度慢，更多apps。</li>
</ul></li>
<li><p>Page Fault Handling流程</p>
<ul>
<li>需要Load M时，发现Page Table里是Invalid的</li>
<li>操作系统介入，从存储里找到Page，Load进入内存</li>
<li>重写Page Table</li>
<li>重新执行指令</li>
</ul></li>
<li><p>Lazy Swapping</p>
<ul>
<li><p>never swaps a page in memory unless it will be needed</p></li>
<li><p>the swapper that deals with pages is also caller a pager</p></li>
</ul></li>
<li><p>Pre-Paging</p></li>
<li><p>总体过程</p>
<ol type="1">
<li><p>Trap操作系统</p></li>
<li><p>保存user寄存器和process state</p>
<p>A到kernel，进行一次context switch，进入kernel</p></li>
<li><p>查看interrupt是不是Page Fault</p>
<p>调用Page Fault Handler</p></li>
<li><p>检查Page的引用是合法的，找到Page在Disk中的位置</p></li>
<li><p>从磁盘读取到空闲帧</p>
<ol type="1">
<li>在队列中等待该设备，直到对读请求进行服务</li>
<li>等待设备寻道和/或延迟时间</li>
<li>开始将页面转移到一个空闲帧</li>
</ol></li>
<li><p>在等待时，将CPU分配给其他用户</p>
<p>context switch到其他process上</p></li>
<li><p>从磁盘I/O子系统接收中断(I/O完成)</p>
<p>disk发出一个interrupt</p></li>
<li><p>为其他用户保存寄存器和进程状态</p></li>
<li><p>确定中断来自磁盘</p></li>
<li><p>更正页表和其他表，以显示页现在在内存中</p></li>
<li><p>等待重新为该进程分配CPU</p></li>
<li><p>恢复用户寄存器、进程状态和新页表，然后恢复中断的指令</p>
<p>context switch之前的process继续执行</p></li>
</ol></li>
<li><p>Demand Paging EAT</p>
<ul>
<li>假设page fault的概率：p</li>
<li><span class="math inline">\((1-p)*memory\ access+p*page\ fault\
service\ time\)</span></li>
<li><span class="math inline">\((1-p)*memory\ access+p*(page\ fault\
overhead+swap\ page\ out/in+instruction\ restart\
overhead)\)</span></li>
<li>page越大，page fault的概率越小，EAT越小</li>
</ul></li>
<li><p>Demanding Pagin和Page Fault的关系</p>
<ul>
<li>Demanding Paging是一个机制，Page Fault是其实现方式。</li>
</ul></li>
<li><p>哪个硬件发出了Page
Fault：MMU，MMU要执行这个Page的操作，会出现Fault</p></li>
<li><p>哪个硬件造成了Page Fault：User space program accesses an
address</p></li>
<li><p>哪个硬件handle了Page Fault：OS的kernel，操作系统处理Page
Fault</p></li>
</ul>
<h3 id="copy-on-write">Copy on Write</h3>
<ul>
<li>Copy-on-Write，加入我们需要fork，我们不想讲一模一样的page拷贝一份，此时我们可以将页表映射到同一个Frame
<ul>
<li>但是当一个process要写时，那么我们就copy一份再写。</li>
<li>就是要写的时候进行copy。</li>
</ul></li>
</ul>
<h3 id="there-is-no-free-frame">There is no Free Frame</h3>
<p>memory中满了，我们需要从memory中拿Frame踢出，再从disk载入</p>
<h3 id="page-replacement">Page Replacement</h3>
<ul>
<li>系统run out of memory，memory满了</li>
<li>我们选一个victim page，将其写到disk上</li>
<li>将新的page frame映射进来</li>
</ul>
<h2 id="lecture-12">Lecture 12</h2>
<h3 id="get-free-frame">Get Free Frame</h3>
<p>出现了PageFault时，我们需要拿出一个Free
Frame来映射新的地址。我们要维护Free Frame，我们用一个list来维护。</p>
<h3 id="there-is-no-free-frame-1">There is no Free Frame</h3>
<p>memory中满了，我们需要从memory中拿Frame踢出，再从disk载入</p>
<h3 id="page-replacement-1">Page Replacement</h3>
<ul>
<li>系统run out of memory，memory满了</li>
<li>我们选一个victim page，将其写到disk上</li>
<li>将新的page frame映射进来</li>
</ul>
<p>内存是一种重要的资源，系统可能会出现内存不足的情况。</p>
<ul>
<li>为了防止内存不足，可以换出一些页面页面替换
<ul>
<li>通常是页面故障处理程序的一部分</li>
<li>选择受害页面的策略需要精心设计
<ul>
<li>需要减少开销，避免thrashing</li>
</ul></li>
<li>使用修改的dirty位来减少换出的页数
<ul>
<li>只将修改的页写入磁盘选择一些要终止的进程(最后手段)</li>
</ul></li>
<li>页面替换完成了逻辑内存和物理内存之间的分离—大的虚拟内存可以在较小的虚拟内存上提供物理内存</li>
</ul></li>
</ul>
<h3 id="fifo">FIFO</h3>
<p>先进先出法则：换出的都是Frames中最早进入的Frame</p>
<p>Page Fault比较大。</p>
<h3 id="optimal">Optimal</h3>
<p>最优法则：替换将来最长时间不使用的页面</p>
<ul>
<li>9-page-fault对于上一张幻灯片的示例是最优的</li>
<li>找Frames中之后最久不用的</li>
<li>但是一般情况下我们不知道哪个Frame是最长时间不用的，无法实现</li>
</ul>
<h3 id="lru">LRU</h3>
<p>LRU：换出最长时间没有用过的</p>
<ul>
<li>每一次使用Frame要更新这个Frame的时间</li>
<li>真正情况下怎么实现？
<ul>
<li>counter-base
<ul>
<li>每个页表条目PTE都有一个计数器</li>
<li>每一次的page被使用，我们将clock拷贝到counter中，需要替换时，从counter中找时间戳最小的，即最长久没有用的，将其替换</li>
</ul></li>
<li>stack-base
<ul>
<li>使用一个栈，使用了栈中的元素，该元素移动到栈顶。</li>
</ul></li>
<li>近似实现：reference bit
<ul>
<li>Second-Chance Page Replacement Algorithm</li>
<li>被ref了为1</li>
<li>换出ref为0的</li>
<li>为缓存中的所有对象增加一个“引用标志位”
<ul>
<li>每次对象被使用时，设置标志位为1</li>
<li>新对象加入缓存时，设置其标志位为0</li>
<li>在淘汰对象时，查看它的标志位。如果为0，则淘汰该对象；如果为1，则设置其标志位为0，重新加入队列末尾。</li>
</ul></li>
</ul></li>
<li>以固定的间隔重新排序比特
<ul>
<li>假设每个页面有8位字节在一个时间间隔(100ms)内，位权移动1位，设置高位位(如果使用)，然后丢弃低位位</li>
<li>00000000 =&gt;在8个时间间隔中没有被使用</li>
<li>11111111 =&gt;在所有时间间隔中都被使用</li>
<li>11000100 vs
01110111:哪个最近使用的更多?11000100更多，替换01110111</li>
</ul></li>
<li>Second-Chance
<ul>
<li>这是<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=FIFO&amp;spm=1001.2101.3001.7020">FIFO</a>算法的改进版，相对于FIFO算法立刻淘汰对象，该算法会检查待淘汰对象的引用标志位。如果对象被引用过，该对象引用位清零，重新插入队列尾部，像新的对象一样；如果该对象未被引用过，则将被淘汰。</li>
</ul></li>
<li>Enhance Second-Chance Algorithm
<ul>
<li>两个位</li>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221201151729446.png" alt="image-20221201151729446">
<figcaption aria-hidden="true">image-20221201151729446</figcaption>
</figure></li>
</ul></li>
</ul></li>
</ul>
<h3 id="lfu">LFU</h3>
<p>Counter Base的</p>
<ul>
<li>Least Frequently Used：最少被用的Page被换出去
<ul>
<li>一个页面在进程初始化期间被大量使用，然后从未使用过</li>
</ul></li>
<li>Most Frequently Used：用的最多的Page被换出去
<ul>
<li>根据这个论点，计数最小的页面可能刚刚被引入，还没有被使用</li>
</ul></li>
</ul>
<h3 id="page-buffering-algorithm">Page-Buffering Algorithm</h3>
<ul>
<li>始终保持一个空闲帧池
<ul>
<li>需要时可用的框架，不需要在故障时查找</li>
<li>把页面读到自由帧，而不是等待受害者写出来
<ul>
<li>尽快重新启动</li>
</ul></li>
<li>在方便的时候，驱逐受害者</li>
</ul></li>
<li>可能的话，保留修改过的页面列表
<ul>
<li>当磁盘空闲时，在那里写入分页并设置为非脏分页:可以在不写入分页到后备存储的情况下替换该分页</li>
<li>可能的是，保持空闲帧内容完整，并注意其中的内容——一种缓存
<ul>
<li>如果在重用之前再次引用，则不需要再次从磁盘加载内容</li>
<li>缓存命中</li>
</ul></li>
</ul></li>
<li>所有这些算法都让操作系统猜测未来的页面访问</li>
<li>有些应用程序有更好的知识——例如数据库</li>
<li>内存密集的应用程序可能导致双缓冲-浪费内存
<ul>
<li>操作系统将页面的副本保存在内存中作为I/O缓冲区</li>
<li>应用程序为自己的工作在内存中保留页面</li>
</ul></li>
<li>操作系统可以直接访问磁盘，避免了应用程序的妨碍
<ul>
<li>裸盘模式绕过缓冲、锁定等</li>
</ul></li>
</ul>
<h3 id="frame-allocation">Frame Allocation</h3>
<p>根据指令语义，每个进程需要最少的帧数、</p>
<p>用于进程内存分配的两种主要分配方案</p>
<ul>
<li>平等的分配Equal
<ul>
<li>For example, if there are 100 frames (after allocating frames for
the OS) and 5 processes, give each process 20 frames</li>
</ul></li>
<li>按比例分配Proportional
<ul>
<li><strong>Allocate according to the size of process</strong></li>
</ul></li>
</ul>
<h4 id="globallocal-allocation">Global/Local Allocation</h4>
<ul>
<li>全局替换
<ul>
<li>进程从所有帧集合中选择一个替换帧</li>
<li>一个进程可以从另一个进程获取帧但是流程执行时间可能会有很大的差异，这取决于其他流程但更大的吞吐量</li>
</ul></li>
<li>本地替换
<ul>
<li>每个进程只从自己分配的帧集合中进行选择</li>
<li>更一致的每进程性能但可能是没有充分利用内存</li>
</ul></li>
</ul>
<h4 id="page-reclaiming">Page Reclaiming</h4>
<ul>
<li><p>实现全局页面替换策略的策略</p></li>
<li><p>所有的内存请求都从空闲帧列表中得到满足</p></li>
<li><p><strong>当列表低于某个阈值时，将触发页面替换，而不是等待列表降为零才开始选择要替换的页面</strong>。</p>
<ul>
<li>积极地回收页面</li>
<li>终止一些进程
<ul>
<li>根据OOM评分</li>
<li>在可用内存不足的情况下终止的可能性有多大</li>
</ul></li>
</ul>
<figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221207102507867.png" alt="image-20221207102507867">
<figcaption aria-hidden="true">image-20221207102507867</figcaption>
</figure></li>
<li><p>这种策略试图确保总有足够的空闲内存来满足新请求。</p></li>
</ul>
<h4 id="major-and-minor-page-fault">Major and Minor Page Fault</h4>
<ul>
<li>Major：page is referenced but not in memory
<ul>
<li>需要去disk里面找Frame</li>
</ul></li>
<li>Minor：mapping does not exist, but the page is in memory
<ul>
<li>没有页表映射，但是Page在memory中了</li>
</ul></li>
</ul>
<h4 id="thrashing">Thrashing</h4>
<ul>
<li>如果进程没有“足够的”页面Page Fault可能会很高
<ul>
<li>Page Fault获取页面，替换一些现有的Frame</li>
<li>但很快需要替换的Frame回来</li>
</ul></li>
<li>一个process一直在换进换出，<strong>导致cpu使用率低</strong>。
<ul>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221207103156652.png" alt="image-20221207103156652">
<figcaption aria-hidden="true">image-20221207103156652</figcaption>
</figure></li>
</ul></li>
<li>为什么需要分页工作?
<ul>
<li>进程内存访问具有高局部性locality</li>
<li>进程从一个局部性迁移到另一个局部性</li>
</ul></li>
<li>为什么Thrashing发生？
<ul>
<li>total memory size &lt; total size of locality</li>
<li>比如说
物理内存不够，进程所访问的页都没有被加载到内存，从而导致缺页中断
需要把该页加载
而如果此时内存不够的话，却发现系统的可替换的页(从内存-&gt;
虚拟内存)很少，这个好像是使用 最近最少使用（访问）的算法判断的吧，
这里可能就会出问题了</li>
</ul></li>
</ul>
<h4 id="working-sets-model">Working Sets Model</h4>
<p>在单纯的分页系统里，刚启动进程时，在内存中并没有页面。在CPU试图取第一条指令时就会产生一次<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=缺页中断&amp;spm=1001.2101.3001.7020">缺页中断</a>，使操作系统装入含有第一条指令的页面。其他由访问全局数据和<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=堆栈&amp;spm=1001.2101.3001.7020">堆栈</a>引起的缺页中断通常会紧接着发生。一段时间以后，进程需要的大部分页面都已经在内存了，进程开始在较少缺页中断的情况下运行。这个策略称为请求调页（demand
paging），因为页面是在需要时被调入的，而不是预先装入。不过幸运的是，大部分进程不是这样工作的，它们都表现出了一种局部性访问行为，即在进程运行的任何阶段，它都只访问较少的一部分页面。例如，在一个多次扫描编译器中，各次扫描时只访问所有页面中的一小部分，并且是不同的部分。</p>
<ul>
<li>一个进程当前正在使用的页面的集合称为它的工作集（working set）</li>
<li>working-set window一个时间窗口，working
set就是统计在这个时间窗口使用的页面的集合
<ul>
<li>如果时间窗小：不会include entire locality</li>
<li>如果时间窗大：会include entire locality</li>
<li>如果时间窗为无穷：将include entire program</li>
</ul></li>
<li>进程<span class="math inline">\(p_i\)</span>的working
set：时间窗口内进程使用的页面的集合</li>
<li>Total working sets：<span class="math inline">\(D=\sum
WSS_i\)</span>
<ul>
<li>全部的locality的近似</li>
<li>如果<span class="math inline">\(m&lt;D\)</span>，可能会thrashing</li>
</ul></li>
<li>Example：
<ul>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221207103650289.png" alt="image-20221207103650289">
<figcaption aria-hidden="true">image-20221207103650289</figcaption>
</figure></li>
</ul></li>
<li>interval time + a reference bit
<ul>
<li>假设：时间窗<span class="math inline">\(\Delta = 10000\)</span>
<ul>
<li>time interrupts after every 5000 time units</li>
<li>keep in memory 2 bits for each page</li>
<li>当time interrupt发生，我们把其他的reference bit设置为0</li>
<li>当内存中的bits=1，page就是在working set中</li>
</ul></li>
<li>改进：更多的bit和更短的timer interrupt</li>
</ul></li>
<li>假设没有颠簸</li>
<li>进程的工作集与其页面故障率之间的直接关系</li>
<li>工作集随着时间的推移而变化</li>
<li>随着时间的推移出现高峰和低谷</li>
</ul>
<h4 id="page-fault-frequency">Page-Fault Frequency</h4>
<ul>
<li>比WSS更直接的方法</li>
<li>建立“可接受的”Page Fault Frquency(PFF)
<ul>
<li>如果实际速率过低，进程丢失帧</li>
<li>如果实际速率过高，进程获得帧</li>
</ul></li>
<li>需要换出一个process，如果没有free frames可用</li>
</ul>
<h2 id="lecture-13">Lecture 13</h2>
<h3 id="kernel-memory-allocation">Kernel Memory Allocation</h3>
<ul>
<li>内核内存分配不同于用户内存，它通常从一个空闲内存池中分配
<ul>
<li>为什么用Lazy Allocation？
<ul>
<li>节约内存资源</li>
<li>"加入购物车不下单"，在真正使用时才申请</li>
</ul></li>
<li>怎么节约CPU的资源？
<ul>
<li>通过调度，如果需要等IO或者等内存，那么就要将CPU让出来，即context
switch。</li>
<li>为了让下一个process尽快进入CPU，使用Ready Queue</li>
</ul></li>
<li>Semaphore
<ul>
<li>busy waiting会占用cpu，引入Semaphore</li>
</ul></li>
</ul></li>
<li>内核为不同大小的结构请求内存
<ul>
<li>可以最大限度地减少由于碎片造成的浪费</li>
</ul></li>
<li>一些内核内存需要在物理上是连续的</li>
<li><strong>在kernel中，申请内存要一个一个Page的申请，并且需要全部用完，避免浪费</strong></li>
<li>Kernel不能使用Lazy
Allocation，是立即满足内存需求的。Kernel一定要Lean&amp;Mean，Lean就是精简，Mean就是一心一意只做一件事</li>
</ul>
<h3 id="page-fault-handling-in-linux">Page Fault Handling in Linux</h3>
<ul>
<li>do_page_fault
<ul>
<li>判断是bad area还是good area</li>
<li>就是看Page在memory中没有映射还是没有在内存中。</li>
</ul></li>
<li>当一个program需要内存，操作系统将VMA的大小增大，当真的要去访问这个地址，出现了Page
Fault，判断是good还是bad area。</li>
</ul>
<h3 id="buddy-system">Buddy System</h3>
<ul>
<li>为了减少碎片化，物理内存都是2的n次方。Memory Allocation使用2的幂次
<ul>
<li>内存以2的幂为单位分配
<ul>
<li>向最近的分配单位提出请求</li>
<li>将单位分成两个“伙伴”，直到有合适大小的块可用</li>
</ul></li>
<li>比如我们假设只有256KB的块可用，内核请求21KB
<ul>
<li>分成A1和A2，各128KB</li>
<li>进一步将一个128KB的块分割为B1和B2的64KB</li>
<li>再分割为32KB+32KB</li>
<li>....</li>
</ul></li>
<li>优点:它可以快速地将未使用的块合并为更大的块</li>
<li>缺点:内部碎片化</li>
</ul></li>
</ul>
<h3 id="slab-allocator">Slab Allocator</h3>
<ul>
<li>Slab分配器是一个缓存对象
<ul>
<li>slab分配器中的cache由一个或多个slab组成</li>
<li>一个slab包含一个或多个page，这些页面被划分为大小相等的对象</li>
<li>内核为每个惟一的内核数据结构使用一个cache
<ul>
<li>当创建缓存时，分配一个slab，将slab划分为空闲对象</li>
<li>数据结构的对象是从slab中的自由对象中分配的</li>
<li>如果一个slab充满了用过的对象，下一个对象来自一个空的/新的slab</li>
</ul></li>
</ul></li>
<li>优点:<strong>无碎片（物理连续），内存分配快pool</strong>
<ul>
<li>一些对象字段可能是可重用的;不需要再次初始化</li>
</ul></li>
</ul>
<h3 id="prepaging">Prepaging</h3>
<ul>
<li>减少进程启动时出现的大量页面错误
<ul>
<li>在引用流程所需的全部或部分页面之前，将它们预先分页</li>
<li>但是如果未使用prepaging的页面，则会浪费I/O和内存</li>
</ul></li>
<li>假设s个page被prepaged了，有α比例的page被使用了
<ul>
<li>s(1-α)被浪费</li>
</ul></li>
</ul>
<h3 id="pagesize">PageSize</h3>
<ul>
<li>有时操作系统设计者有一个选择
<ul>
<li>特别是如果运行在定制的CPU上</li>
</ul></li>
<li>页面大小的选择必须考虑
<ul>
<li>碎片-&gt;小页面</li>
<li>页表大小-&gt;大页面</li>
<li>分辨率-&gt;小页面</li>
<li>I/O开销-&gt;大页面</li>
<li>页面错误数-&gt;大页面</li>
<li>Locality -&gt;小页面</li>
<li>TLB size和有效性-&gt;大页面</li>
</ul></li>
<li>总是2的幂，通常在<span class="math inline">\(2^{12}\)</span>(4096字节)到<span class="math inline">\(2^{22}\)</span>的范围内（4194304 字节）</li>
<li>平均而言，随着时间的推移而增长</li>
</ul>
<h3 id="tlb-reach">TLB reach</h3>
<ul>
<li>TLB访问范围：从TLB可访问的内存量
<ul>
<li><span class="math inline">\(TLB\ Reach = (TLB\ size)\times(page\
size)\)</span></li>
</ul></li>
<li>理想情况下，每个进程的工作集都存储在TLB中
<ul>
<li>否则会出现严重的TLB缺失</li>
</ul></li>
<li>增加页面大小以减少TLB压力
<ul>
<li>它可能会增加碎片，因为并非所有应用程序都需要大页面</li>
<li>多个页面大小允许需要更大页面的应用程序使用它们，而不会增加碎片</li>
</ul></li>
</ul>
<h3 id="io-interlock">I/O interlock</h3>
<ul>
<li>I/O互锁——页面有时必须锁在内存中</li>
<li>考虑I/O—用于从设备复制文件的页必须被锁定，不能被页替换算法选择为清除</li>
</ul>
<h2 id="lecture-13-1">Lecture 13-1</h2>
<h3 id="memory-management-summary">Memory Management Summary</h3>
<ul>
<li>Partition
<ul>
<li>直接管理物理Phy memory</li>
<li>一开始只用run一个job无需担心内存分配，后来需要多个进程，要把系统内存分配</li>
<li>fix len：internal</li>
<li>variable len：external</li>
</ul></li>
<li>Segmentation
<ul>
<li>Base+limit</li>
<li>Logic Address</li>
<li>没有避免external fragmentation</li>
</ul></li>
<li>Paging
<ul>
<li>一级页表：页表本身占用空间大</li>
<li>多级页表</li>
<li>demand paging</li>
<li>page replacement</li>
<li>working set</li>
</ul></li>
</ul>
<h3 id="mass-storage-structure">Mass-Storage Structure</h3>
<ul>
<li>永久的存储介质</li>
<li>磁盘为计算机系统提供大量的二次存储
<ul>
<li>硬盘是最受欢迎的；一些磁盘可以移动</li>
<li>驱动程序通过I/O总线连接到计算机(例如，USB, SCSI，EIDE，SATA...)</li>
<li>驱动器以每秒60到250次的速度旋转(7200rpm= 120rps)</li>
<li>磁盘有盘片，范围从.85"到14"(历史上)
<ul>
<li>3.5"，2.5"，和1.8"现在很常见英寸</li>
</ul></li>
</ul></li>
<li>每个驱动器的容量范围从30GB到3TB，甚至更大</li>
</ul>
<h3 id="moving-head-magentic-disk">Moving-head Magentic Disk</h3>
<ul>
<li><p>磁盘驱动器被编址为1维逻辑块阵列(LBA)</p>
<ul>
<li>逻辑块是传输的最小单位</li>
</ul></li>
<li><p>逻辑块按顺序映射到硬盘的扇区中</p>
<ul>
<li>扇区sector 0是最外层圆柱体上第一轨道的第一扇区</li>
<li>按顺序绘制进度</li>
<li>然后是cylinder里剩下的痕迹</li>
<li>然后通过其余的cylinder从最外到最内</li>
</ul></li>
<li><p>逻辑到物理地址应该是容易的</p>
<ul>
<li>除了坏扇区</li>
</ul>
<figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221208144911779.png" alt="image-20221208144911779">
<figcaption aria-hidden="true">image-20221208144911779</figcaption>
</figure></li>
<li><p>Positioning time移动磁盘臂到所需的节的时间</p>
<ul>
<li>positioning time includes seek time and rotational latency
<ul>
<li>Seek time：挪动磁头，在不同道上移动</li>
<li>Rotation lantency：转动磁盘，在同一个道上获取sector</li>
</ul></li>
<li>定位时间也称为随机访问时间</li>
</ul></li>
<li><p>Performance</p>
<ul>
<li>传输速率：理论6GB/sec；有效(真实)约1GB/sec
<ul>
<li>传输速率是数据在驱动器和计算机之间流动的速率</li>
</ul></li>
<li>寻道时间从3ms到12ms(桌面驱动器常见为9ms)</li>
<li>基于主轴转速的延迟:1/rpm * 60
<ul>
<li>rpm：rotation per minute</li>
<li>平均延迟=0.5延迟</li>
</ul></li>
</ul></li>
<li><p>Average Access Time = average seek time + average latency</p>
<ul>
<li>for fastest disk 3ms + 2ms = 5ms</li>
<li>for slow disk 9ms + 5.56ms = 14.56ms</li>
</ul></li>
<li><p>Average I/O time：average access time + (data to transfer /
transfer rate) + controller overhead</p>
<ul>
<li>e.g., to transfer a 4KB block on a 7200 RPM disk; 5ms average seek
time, 1Gb/sec transfer rate with a .1ms controller overhead:</li>
<li>5ms+4KB/1GB/1sec+0.1ms+4.17ms（average latency）</li>
</ul></li>
</ul>
<h3 id="disk-scheduling">Disk Scheduling</h3>
<ul>
<li><p>Disk scheduling usually tries to minimize <strong>seek
time</strong>，在cylinder之间移动</p>
<ul>
<li>rotational latency is difficult for OS to calculate</li>
<li>近似两个cylinder的距离，让磁头移动距离最短。</li>
<li>We use a request queue of cylinders “98, 183, 37, 122, 14, 124, 65,
67” ([0, 199]), and initial head position 53 as the example
<ul>
<li>一共是640</li>
</ul></li>
</ul></li>
<li><p>SSTF：Shortest Seek Time First</p>
<ul>
<li>每一次找寻道时间最短的</li>
<li>不是最优的</li>
</ul></li>
<li><p>SCAN：电梯算法</p></li>
</ul>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SCAN</span>算法，也就是很形象的电梯调度算法。先按照一个方向(比如从外向内扫描)，扫描的过程中依次访问要求服务的序列。当扫描到最里层的一个服务序列时反向扫描，这里要注意，假设最里层为<span class="number">0</span>号磁道，最里面的一个要求服务的序列是<span class="number">5</span>号，访问完<span class="number">5</span>号之后，就反向了，不需要再往里扫。结合电梯过程更好理解，在电梯往下接人的时候，明知道最下面一层是没有人的，它是不会再往下走的。</span><br><span class="line">过程：</span><br><span class="line">总是从磁臂当前位置开始，沿磁臂的移动方向去选择当前离磁臂最近的那个位置。 </span><br><span class="line">当沿磁臂方向无访问请求时，改变磁臂的移动方向。 </span><br><span class="line">需要为访问者设置两个队列，依据磁头的移动方向，能访问到的访问者由近及远排队。 </span><br><span class="line">背离磁头移动方向的访问者也由近及远排队。 </span><br><span class="line">先按磁头移动方向队列调度访问者访问磁盘，当该方向没有访问者时，再改变方向，选择还有一个访问者队列访问磁盘。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>硬盘臂从硬盘的一端开始向另一端移动</p></li>
<li><p>服务请求在移动期间，直到它到达另一端</p></li>
<li><p>然后，反转头部运动，继续服务。</p></li>
<li><p>优势</p>
<ul>
<li>高吞吐量</li>
<li>响应时间方差低</li>
<li>平均响应时间</li>
</ul></li>
<li><p>缺点</p>
<ul>
<li>对磁盘臂刚刚访问的位置的请求等待时间过长</li>
</ul></li>
<li><p>C-SCAN</p>
<ul>
<li>Circular-SCAN旨在提供更统一的等待时间</li>
<li>头部从一端移动到另一端，同时为请求提供服务</li>
<li>当头部到达末端时，它立即回到起点
<ul>
<li>回程时不处理任何请求</li>
</ul></li>
<li>它本质上把圆柱体当作一个循环列表</li>
</ul></li>
<li><p>LOOK/C-LOOK</p>
<ul>
<li>SCAN和C-SCAN从头到尾移动</li>
<li>即使在实现中没有I/O，头也只到最后一个请求方向</li>
<li>LOOK是SCAN的一个版本，C-LOOK是C-SCAN的一个版本</li>
</ul></li>
</ul>
<p>磁盘调度性能取决于请求的数量和类型</p>
<ul>
<li>磁盘调度应该被写成一个独立的，可替换的模块
<ul>
<li>SSTF是常见的，是默认算法的合理选择</li>
<li>LOOK和C-LOOK对于I/O负载较重的系统性能更好</li>
</ul></li>
<li>磁盘性能会受到文件分配和元数据布局的影响
<ul>
<li>文件系统花费大量精力来增加空间局部性</li>
</ul></li>
</ul>
<h3 id="nonvolatile-memory-devices">Nonvolatile Memory Devices</h3>
<ul>
<li>SSD，有写的寿命，需要一个较好的管理。</li>
<li>以“页”增量(考虑扇区)读取和写入，但不能就地覆盖
<ul>
<li>必须首先被擦除，擦除发生在更大的“块”中</li>
<li>假设块大小:64k有16页，页面大小:4k</li>
</ul></li>
<li>一般能写100000次</li>
<li>Management
<ul>
<li>将一个常写的文件写在不同的block上。</li>
<li>需要一个调度
<ul>
<li>将常写的一直挪动。</li>
</ul></li>
</ul></li>
</ul>
<p>优点：</p>
<ul>
<li>没有机械结构，不易损坏</li>
<li>体积小，密度高</li>
</ul>
<h3 id="nand-flash-controller-algorithm">NAND Flash Controller
Algorithm</h3>
<ul>
<li>With no overwrite, pages end up with mix of valid and invalid
data</li>
<li>为了跟踪哪些逻辑块是有效的，控制器维护flash转换层(FTL)表格</li>
<li>还实现了垃圾收集以释放无效的页面空间-可用的页面，但没有空闲块</li>
<li>分配超额配置，为GC提供工作空间
<ul>
<li>将好的数据复制到超额配置区域，并擦除该块以备以后使用</li>
</ul></li>
<li>每个单元格都有生命周期，因此需要对所有单元格进行平等写入</li>
</ul>
<h3 id="magnetic-tape">Magnetic Tape</h3>
<p>磁带是早期的二级存储，现在主要用于备份</p>
<ul>
<li>大容量:200GB ~ 1.5 TB</li>
<li>访问时间慢，特别是随机访问
<ul>
<li>是<strong>顺序访问</strong></li>
<li>寻道时间比磁盘高得多</li>
<li>一旦数据在磁头下，传输速率相当于磁盘(140 MB/s)</li>
<li>需要对磁带进行随机访问</li>
</ul></li>
<li>存储在磁带上的数据相对永久</li>
</ul>
<h4 id="disk-management">Disk Management</h4>
<ul>
<li>物理格式化Physical
Formatting：将磁盘划分成<strong>扇区</strong>，供控制器读写
<ul>
<li>每个扇区可以保存报头信息，外加数据，外加纠错码(ECC)</li>
<li>通常是512字节的数据，但也可以选择</li>
</ul></li>
<li>操作系统将自己的数据结构记录在磁盘上
<ul>
<li>将磁盘划分为几组cylinders，每组cylinders视为一个<strong>逻辑磁盘</strong></li>
</ul></li>
<li>逻辑格式化Logical Formatting分区以在其上创建文件系统
<ul>
<li>一些FS预留了备用扇区来处理坏块</li>
<li>FS可以进一步将块分组到集群中以提高性能
<ul>
<li>磁盘I/O以块方式完成blocks</li>
<li>文件I/O以集群方式完成cluster</li>
</ul></li>
<li>如果分区包含操作系统镜像，则初始化引导扇区</li>
</ul></li>
<li>根分区包含操作系统，其他分区可以存放其他操作系统、其他文件、系统或为原始分区
<ul>
<li>在引导时安装Mounted</li>
<li>其他分区可以自动或手动挂载</li>
</ul></li>
<li>对于想要进行自己的块管理的应用程序，可以访问原始磁盘，避免操作系统(例如数据库)
<ul>
<li>引导块初始化系统</li>
<li>存储在引导分区引导块中的引导加载程序</li>
<li>处理坏块的方法，如扇区保留</li>
</ul></li>
</ul>
<h4 id="swap-space-management">Swap Space Management</h4>
<ul>
<li>当DRAM容量不足以容纳所有进程时，用于将整个进程(交换)或页面(分页)从DRAM移动到辅助存储</li>
<li>操作系统提供交换空间管理
<ul>
<li>二级存储比DRAM慢，因此优化性能很重要</li>
<li>可能的多个交换空间-减少任何给定设备上的I/O负载</li>
<li>最好有专门的设备</li>
<li>可以在单独的分区中，也可以在文件系统中的一个文件中(为了方便添加)</li>
<li>Linux系统上交换的数据结构:
<ul>
<li>0表示未使用</li>
<li>3表示映射到3个proc</li>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221214105131726.png" alt="image-20221214105131726">
<figcaption aria-hidden="true">image-20221214105131726</figcaption>
</figure></li>
</ul></li>
</ul></li>
</ul>
<h2 id="lecture-14">Lecture 14</h2>
<h3 id="raid">RAID</h3>
<ul>
<li>磁盘不可靠，速度慢，但是便宜</li>
<li>我们用冗余增强其可靠性、增加速度</li>
<li>Redundant Array of Independent Disks (RAID)</li>
<li></li>
</ul>
<h3 id="io">IO</h3>
<h4 id="overview">OverView</h4>
<p>IO设备的特点</p>
<ul>
<li>IO设备多样</li>
<li>每一个IO设备的差别很大
<ul>
<li><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221214105825998.png" alt="image-20221214105825998" style="zoom:67%;"></li>
</ul></li>
<li>我们怎么管IO？</li>
</ul>
<p>操作系统怎么访问IO</p>
<ul>
<li>Polling：轮询</li>
<li>Interrupt</li>
</ul>
<h4 id="io-hardwaare">IO Hardwaare</h4>
<ul>
<li>CPU有IO的指令</li>
<li>设备有IO设备的寄存器</li>
<li>和CPU交互：通过IO指令、将设备的寄存器映射到内存地址空间、读写内存地址就是读写设备寄存器。</li>
</ul>
<h4 id="polling">Polling</h4>
<p>对于每一个IO操作：</p>
<ul>
<li>busy-waiting如果设备是busy的
<ul>
<li>busy时不能接受command</li>
</ul></li>
<li>发一个command给device controller，通过command register</li>
<li>主动问设备，设备忙，OS做busy waiting</li>
<li>设备慢了的话，busy waiting的时间长</li>
</ul>
<h4 id="interrupt">Interrupt</h4>
<ul>
<li>发一个command给device，然后去做别的事情</li>
<li>device结束了会interrupt</li>
<li>os调用interrupt handler</li>
<li>要进行context switch</li>
<li>因此一个设备很快的话，就用polling，避免context switch</li>
<li>有一个Interrput table</li>
</ul>
<p>中断也用于异常</p>
<ul>
<li>访问违规protection错误</li>
<li>内存访问错误</li>
<li>软件中断</li>
</ul>
<p>CPU affinity</p>
<h4 id="dma-1">DMA</h4>
<p>DMA直接在I/O设备和内存之间传输数据</p>
<ul>
<li>操作系统只需要发出命令，数据传输绕过CPU</li>
<li>没有编程的I/O(一次一个字节)，数据以大块传输</li>
<li>它需要在设备或系统中使用DMA控制器</li>
</ul>
<p>设备的数据不经过CPU直接进入memory</p>
<h4 id="application-io-interface">Application IO Interface</h4>
<p>I/O系统调用将设备行为封装在泛型类中</p>
<ul>
<li>在Linux中，设备可以作为文件访问
<ul>
<li>使用ioctl的低级访问</li>
</ul></li>
</ul>
<h4 id="characteristics-of-io-device">Characteristics of IO Device</h4>
<ul>
<li>每个设备的差异性大，很不同
<ul>
<li>一读就是一个Block，或者一个字符流</li>
<li>read&amp;write、write only、read only</li>
<li>synchronous or asynchronous</li>
</ul></li>
</ul>
<h2 id="lecture-15">Lecture 15</h2>
<h3 id="linux-io">Linux IO</h3>
<p>Everything is a file，所有东西都是文件</p>
<ul>
<li>device下也有文件：/dev/ptmx，device有一个自己的文件，操作device，就对文件进行读写以操作</li>
<li>如何把device link到fops：cdev_init中cdev指向了ptmx_fops
<ul>
<li>ptmx_fops.unlock_ioctl = tty_ioctl</li>
</ul></li>
<li>file_operations：都是函数，对文件的操作
<ul>
<li>unlock_ioctl</li>
</ul></li>
</ul>
<h3 id="file-system-interface">File System Interface</h3>
<h4 id="mass-storage">Mass Storage</h4>
<p>现在我们有了mass storage和IO，如何使用他们？</p>
<p>操作系统管理硬件，抽象成了文件系统：</p>
<ul>
<li>文件会消耗disk上track/sector等资源</li>
<li>对于用户process而言，file是一个连续的block的bytes</li>
<li>文件系统有保护系统</li>
</ul>
<p>文件的分类：</p>
<ul>
<li>用存储的数据来分类numeric、character（text）、binary</li>
<li>program</li>
<li>proc file
system：使用文件系统接口来检索系统信息，只有内存的buffer，没有disk上的映射。也称为in
memory file system。</li>
</ul>
<h4 id="file-attributes">File Attributes</h4>
<ul>
<li>Name、Identifier、Type、Location、Size、Protection、Time/date/user
identification</li>
</ul>
<h4 id="file-operations">File Operations</h4>
<ul>
<li>Create：找到一个空间，申请一块entry在directory中</li>
<li>Open：所有的操作要先打开，将文件的源信息load到内存里</li>
<li>Read/Write：需要有一个pointer指向现在要操作的地方</li>
<li>seek：挪动pointer</li>
<li>close：释放掉fd</li>
<li>delete：删掉一些文件</li>
<li>truncate：清空文件，但是保存attributes</li>
<li>copy：create、read、write</li>
</ul>
<h5 id="open-files">Open Files</h5>
<p>需要一些数据来管理文件的打开</p>
<ul>
<li>Openfile table：追踪打开的文件</li>
<li>File pointer：指向上一次操作的地方</li>
<li>File-open
count：全局的，允许从打开的文件表中删除数据时，最后进程关闭它</li>
</ul>
<p>Lock：</p>
<ul>
<li>shared lock：多个read可以share</li>
<li>Exclusive lock：有写的不可以share，使用exclusive</li>
</ul>
<p>Lock Mechanisms：</p>
<ul>
<li>Mandatory强制锁：根据持有的锁和请求的锁拒绝访问</li>
<li>Advisory咨询锁：进程可以发现锁的状态并决定要做什么</li>
</ul>
<p><strong>文件的类型</strong></p>
<p>如何判断文件的类型？使用后缀？</p>
<p>使用Magic Number</p>
<ul>
<li>executable(exe,com,bin,none)</li>
<li>object(obj,o)</li>
</ul>
<p><strong>文件的结构</strong></p>
<p>一个文件可以有不同的结构，由操作系统或程序决定</p>
<ul>
<li>no structure：一串字节或单词的流</li>
<li>简单的记录结构
<ul>
<li>记录行，固定长度或可变长度，例如数据库</li>
</ul></li>
<li>复杂的结构例
<ul>
<li>如:word文档，可重定位的程序文件通常用户程序负责识别文件结构</li>
</ul></li>
</ul>
<h3 id="access-method">Access Method</h3>
<ul>
<li>访问文件有顺序访问、直接访问</li>
<li>Sequential access：只能从头开始一个一个访问</li>
<li>Direct access：支持直接访问文件中指定的位置</li>
<li>使用index实现Direct access</li>
</ul>
<h3 id="directory-structure">Directory Structure</h3>
<p>一个disk文成不同的partition，一个partition 有一个文件系统。</p>
<ul>
<li>有meta数据，存储文件系统的数据</li>
<li><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221215151616963.png" alt="image-20221215151616963" style="zoom:67%;"></li>
<li><strong>Directory</strong>是包含所有<strong>文件信息</strong>的节点的集合
<ul>
<li>可以理解为，这个node里面存的是文件的metadata而不是直接的数据</li>
<li>目录就是一个nodes的集合</li>
</ul></li>
</ul>
<h4 id="directory-organization">Directory Organization</h4>
<ul>
<li>组织目录以实现
<ul>
<li>效率：快速定位文件</li>
<li>命名：组织目录结构方便用户</li>
<li>两个用户对不同的文件可以有相同的名称，同一个文件可以有几个不同的名称</li>
</ul></li>
<li>单级目录：
<ul>
<li>一个目录给所有用户用
<ul>
<li>命名问题和分组问题</li>
<li>两个用户希望拥有相同的文件名</li>
</ul></li>
</ul></li>
<li>二级目录：
<ul>
<li>先有用户的目录，就是说用户每一个人都有自己的一个目录</li>
<li>然后再用户目录下保存用户的文件</li>
<li>共享？使用一个Dummy目录，所有用户都可以用</li>
</ul></li>
<li>Tree Based：
<ul>
<li>由Path演化而来</li>
<li>树形结构</li>
<li>可以使用绝对路径名或相对路径名访问文件</li>
<li>创建文件：touch</li>
<li>删除文件：rm</li>
<li>创建子目录：mkdir</li>
<li>删除目录：rm -rf 递归删除</li>
</ul></li>
</ul>
<h5 id="acyclic-graph-directories">Acyclic-Graph Directories</h5>
<p>无环图：允许链接到目录条目/文件进行别名(不再是树)</p>
<p><img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221215152656182.png" alt="image-20221215152656182" style="zoom:80%;"></p>
<p>如果一个被连接的文件被删除，会有bug发生。</p>
<p>backpointer：有回指的指针，当有link指向它就不会被删除。</p>
<h5 id="genral-graph-directories">Genral Graph Directories</h5>
<p>不要求无环，可以随意指。</p>
<p>允许循环，但使用垃圾收集回收磁盘空间</p>
<p>每次添加新链路时，使用循环检测算法</p>
<h4 id="file-system-mounting">File System Mounting</h4>
<ul>
<li>文件系统必须先挂载Mount后才能被访问
<ul>
<li>挂载将文件系统file ops链接到系统，通常形成一个单一的名称空间</li>
<li>要挂载的文件系统的位置称为挂载点</li>
<li>挂载的文件系统使挂载点上的旧目录不可见，就是进行了一个替换，将旧目录替换成新挂载的目录</li>
</ul></li>
</ul>
<h4 id="file-sharing">File Sharing</h4>
<ul>
<li>在多用户系统上共享文件是可取的</li>
<li>Network也可以进行共享，如FTP</li>
<li>Client-Server model：一个server发送信息，多个user从上面下载</li>
</ul>
<h3 id="protection">Protection</h3>
<ul>
<li>要控制文件的访问的权限：能做哪些事？谁能做？</li>
<li>Linux中使用了ACL：Access Control List
<ul>
<li>优点：细粒度控制</li>
<li>缺点：如何构建list，list存在哪里？</li>
</ul></li>
</ul>
<h2 id="lecture-16">Lecture 16</h2>
<h3 id="file-system-structure">File-system structure</h3>
<ul>
<li>文件是一种逻辑存储单元，用于收集相关信息。</li>
<li>有许多文件系统：操作系统可能同时支持几种</li>
<li>文件系统位于<strong>二级存储</strong>(磁盘disk)上
<ul>
<li>提供读和写的接口</li>
</ul></li>
<li>文件系统通常被实现并组织成层</li>
</ul>
<h4 id="layered-file-system">Layered File System</h4>
<figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221221103558247.png" alt="image-20221221103558247">
<figcaption aria-hidden="true">image-20221221103558247</figcaption>
</figure>
<ul>
<li>Logical file system
<ul>
<li>保留文件系统所需的所有元数据</li>
<li>它存储目录结构</li>
<li>它存储一个存储文件描述的数据结构(文件控制块- FCB)</li>
<li>以上输入:打开/读/写filepath</li>
<li>输出如下:读/写逻辑块</li>
</ul></li>
<li>file-organization module
<ul>
<li>了解逻辑文件块(从0到N)和相应的物理文件块，它执行转换</li>
<li>它还管理空闲空间</li>
<li>以上输入:读取逻辑块3,写逻辑块17</li>
<li>输出如下:读取物理块43,写物理块421</li>
</ul></li>
<li>basic file system
<ul>
<li>Linux中的“块I/O子系统”</li>
<li>分配/维护包含文件系统、目录和数据块的各种缓冲区</li>
<li>这些缓冲区是缓存，用于提高性能</li>
<li>以上输入:读取物理块#43写入物理块#421</li>
<li>输出如下:读取物理块#43写入物理块#421</li>
</ul></li>
<li>IO control
<ul>
<li>设备驱动程序和中断处理程序</li>
<li>以上输入:读取物理块#43写入物理块#124</li>
<li>输出如下:写入设备控制器的内存以执行磁盘读，写对相关中断做出反应</li>
</ul></li>
</ul>
<h4 id="file-system-data-structure">File system Data structure</h4>
<ul>
<li>文件系统由数据结构组成</li>
<li>On-disk
<ul>
<li>一个可选择的boot control block
<ul>
<li>存储操作系统中的卷的第一个块</li>
<li>UFS中的boot block，在NTFS中存储分区引导扇区</li>
</ul></li>
<li>一个volume control block
<ul>
<li>包含volume中的块数、块大小、free-block计数、freeblock指针、free-FCB计数、fcb指针等信息</li>
<li>UFS中的super block，NTFS中的master文件表</li>
</ul></li>
<li>一个Directory
<ul>
<li>与ID关联的文件名，FCB指针</li>
</ul></li>
<li>per-file File Control Block (FCB）
<ul>
<li>在NTFS中，FCB是关系数据库中的一行</li>
</ul></li>
</ul></li>
<li>In-memory
<ul>
<li>一个挂载表，每个挂载卷有一个条目</li>
<li>用于快速路径转换的目录缓存(性能)directory cache</li>
<li>一个全局的打开文件表global open-file table</li>
<li>一个per-process open-file table</li>
<li>不同的缓冲区保存“正在传输”的磁盘块(性能)</li>
</ul></li>
</ul>
<h4 id="typical-file-control-block">Typical File Control Block</h4>
<ul>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221221104235209.png" alt="image-20221221104235209">
<figcaption aria-hidden="true">image-20221221104235209</figcaption>
</figure></li>
</ul>
<h4 id="文件的操作">文件的操作</h4>
<h5 id="creation">Creation()</h5>
<ul>
<li>分配一个新的FCB，一个新的File control block</li>
<li>更新相应的目录，将file的指针等放入</li>
</ul>
<h5 id="open">open()</h5>
<ul>
<li>将FCB进行Load到内存中</li>
<li>寻找System-Wide Open-File Table看看这个文件是否在use了
<ul>
<li>如果打开过，创建一个Per-Process Open-File Table
entry，指向存在的System-Wide Open-File Table就好</li>
<li>如果没找到，则找directory，将FCB从磁盘load到内存，放进Open-File
Table</li>
</ul></li>
<li>增加System-Wide Open-File Table中的open count</li>
<li>returns a pointer to the appropriate entry in the Per-Process
Open-File Table</li>
<li>所有后续操作都使用该指针执行</li>
<li>process closes file -&gt; Per-Process Open-File Table entry is
removed; open count decremented</li>
<li>all processes close file -&gt; copy in-memory directory information
to disk and System-Wide Open-File Table is removed from memory</li>
</ul>
<h4 id="mounting-file-system">Mounting File System</h4>
<ul>
<li>引导块——一系列连续的块，包含程序的内存映像，调用引导加载程序，定位并挂载根分区;分区包含内核;引导加载程序定位、加载并启动内核执行</li>
</ul>
<h4 id="virtual-file-system">Virtual File System</h4>
<ul>
<li>Question：OS如何handle这么多类型的文件系统(EXT、FAT、NTFS...)？
<ul>
<li>“All problems in computer science can be solved by another level of
indirection,except for the problem of too many layers of
indirection.”</li>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221221110605912.png" alt="image-20221221110605912">
<figcaption aria-hidden="true">image-20221221110605912</figcaption>
</figure></li>
</ul></li>
<li>虚拟文件系统
<ul>
<li>VFS提供了一种面向对象的实现文件系统的方法</li>
<li>OS为FS定义了一个公共接口，所有的FS都实现了它们。</li>
<li>系统调用是基于这个公共接口实现的
<ul>
<li>它允许相同的系统调用API用于不同类型的FS</li>
</ul></li>
<li>VFS将FS泛型操作与实现细节分离
<ul>
<li>实现可以是许多FS类型之一，或网络文件系统</li>
<li>OS可以将系统调用分派给适当的FS实现例程</li>
</ul></li>
<li>我们调用时只用调用write、read等，底层会自动调用正确的文件系统的write、read函数
<ul>
<li>Write syscall → vfs_write → indirect call →
ext4_file_write_iter</li>
</ul></li>
<li>What’s the call path when writing a nfs file?
<ul>
<li>Write syscall → vfs_write → indirect call → nfs_file_write_iter</li>
</ul></li>
<li>When is file-&gt; f_op setted?
<ul>
<li>f_op是指向不同文件系统的f_op的，这个f_op什么时候被set？</li>
<li>被open的时候，它知道它来自哪个文件系统了，它是in memory的data
structure</li>
</ul></li>
</ul></li>
</ul>
<h3 id="directory-implementation">Directory Implementation</h3>
<ul>
<li>目录是一种特殊的file
<ul>
<li>存储mapping，从file name 到inode</li>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221221111719401.png" alt="image-20221221111719401">
<figcaption aria-hidden="true">image-20221221111719401</figcaption>
</figure></li>
<li>Linear List
<ul>
<li>带有指向文件元数据指针的文件名的线性列表</li>
<li>需要一个一个对比，搜索时间长</li>
<li>编程简单，但搜索耗时(如线性搜索)</li>
</ul></li>
<li>B+树组织</li>
<li>按照字母表顺序</li>
<li>存hash table
<ul>
<li>具有哈希数据结构的线性列表</li>
<li>以减少搜索时间冲突是可能的:两个或多个文件名散列到同一位置</li>
</ul></li>
</ul></li>
</ul>
<h4 id="disk-block-allocation">Disk Block Allocation</h4>
<ul>
<li>文件需要分配磁盘块来存储数据
<ul>
<li>不同的分配策略具有不同的复杂性和性能</li>
</ul></li>
<li>Contiguous Allocation
<ul>
<li>连续分配,每个文件都在一组连续的块中</li>
<li>好是因为顺序访问导致磁盘头很少移动，从而缩短了寻道时间</li>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221221113007474.png" alt="image-20221221113007474">
<figcaption aria-hidden="true">image-20221221113007474</figcaption>
</figure></li>
<li>directory包含了start和len</li>
<li>优点：
<ul>
<li>读一个block很快能读到，方便定位</li>
</ul></li>
<li>缺点：类比连续的内存分配
<ul>
<li>找空闲空间困难</li>
<li>external fragmentation</li>
<li>文件很难增长</li>
</ul></li>
</ul></li>
<li>Linked Allocation
<ul>
<li>每一个block包含一个指向下一个block的指针</li>
<li>块可以分散在磁盘的任何地方(没有External
Fragmentation，没有压缩)</li>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221221112753408.png" alt="image-20221221112753408">
<figcaption aria-hidden="true">image-20221221112753408</figcaption>
</figure></li>
<li>目录就只需要包含start和end的block</li>
<li>缺点
<ul>
<li>需要sequencial访问，比如要访问16，必须从9开始</li>
<li>容错率低，若16被损坏了，后面的都坏了</li>
</ul></li>
<li>FAT32使用的是Linked的，支持文件大小最大为4G
<ul>
<li>为什么是4GB？</li>
</ul></li>
</ul></li>
<li>Indexed Allocation
<ul>
<li>索引分配，每个文件都有自己的指向其数据块的指针索引块</li>
<li>需要分配一个index block，对于小文件比较浪费</li>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221221113137733.png" alt="image-20221221113137733">
<figcaption aria-hidden="true">image-20221221113137733</figcaption>
</figure></li>
<li>缺点：
<ul>
<li>浪费</li>
</ul></li>
<li>改进：
<ul>
<li>index大小可变</li>
<li>index block可以指向index block</li>
<li>linked index block</li>
</ul></li>
</ul></li>
</ul>
<h4 id="inode">inode</h4>
<figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221225194226514.png" alt="image-20221225194226514">
<figcaption aria-hidden="true">image-20221225194226514</figcaption>
</figure>
<ul>
<li>有15个data block的指针：
<ul>
<li>12个直接指向data block的指针</li>
<li>3个间接指针：single、double、triple</li>
<li>假如我们有一个block为512bytes，一个pointer为4bytes，那么文件最大有多大？
<ul>
<li><span class="math inline">\(Max Size =
12*512+1*(512/4)*512+1*(512/4)^2*512+1*(512/4)^3*512\
bytes\)</span></li>
<li>约等于1G</li>
</ul></li>
<li>若block size为4KB？
<ul>
<li><span class="math inline">\(Max Size=
12*4K+(4K/4)*4K+(4K/4)^2*4K+(4K/4)^3*4K\ bytes\)</span></li>
<li>约等于4TB</li>
</ul></li>
</ul></li>
<li>前6KB可以直接找到block，越访问后面越慢！</li>
</ul>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Linux的Ext文件系统是如何与磁盘内存产生对应的呢？我们知道，在使用磁盘内存之前，需要为磁盘分区，然后为所分区域格式化出一个统一的文件系统（也有例外，如LVM与磁盘阵列技术）。那么，在这样一个统一的文件系统中，根据数据的不同，就可以将内存分为以下<span class="number">3</span>种类型：</span><br><span class="line"></span><br><span class="line">- inode 记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的<span class="keyword">block</span>号码</span><br><span class="line">- <span class="keyword">block</span> 实际记录文件的内容，如果文件太大，则会占用多个<span class="keyword">block</span></span><br><span class="line">- super <span class="keyword">block</span> 记录文件系统的整体信息，包括inode/<span class="keyword">block</span>的总量、使用量、剩余量，以及文件系统的格式与相关信息等</span><br></pre></td></tr></table></figure>
<h3 id="free-space-management">Free Space Management</h3>
<h4 id="bit-map">Bit Map</h4>
<p>使用比特来标记block是否被使用</p>
<ul>
<li>一个block对应一个bit
<ul>
<li>bit[i]=1，free</li>
<li>bit[i]=0，occupied</li>
</ul></li>
<li>例子：
<ul>
<li>block size = 4 KB = 2^12 bytes</li>
<li>disk size = 1TB = 2^40 bytes</li>
<li>block number = 2^28</li>
<li>也就是说我们需要这么多个bits来表示，折合成Byte有32MB！</li>
<li>太浪费了</li>
</ul></li>
<li>我们可以把多个block看成一个cluster，一个cluster用一个bit表示</li>
</ul>
<h4 id="linked-free-space">Linked Free Space</h4>
<p>将没有用的block进行link起来，不会浪费内存</p>
<p>缺点在于，我们IO操作很多！不能容易拿到连续空间。</p>
<ul>
<li>Grouping分组
<ul>
<li>n个一组，在第一个空闲块中存储n-1个空闲块的地址，加上一个指针到下一个索引块</li>
<li>分配多个空闲块不需要遍历列表</li>
</ul></li>
<li>Counting
<ul>
<li>集群的链接(起始块+连续块数量)</li>
<li>经常连续地使用和释放空间</li>
<li>在链接节点中，保留第一个空闲块的地址和后面空闲块的编号</li>
</ul></li>
</ul>
<h3 id="file-system-performance">File System Performance</h3>
<ul>
<li>把metadata和data放得近一些</li>
<li>使用cache</li>
<li>用asynchronous writes，写cached/buffered</li>
<li>read-ahead/free-behind：多读一些放进buffer</li>
<li>读通常比写慢，读涉及disk，写的时候已经在buffer里面了</li>
</ul>
<h4 id="page-cache">Page Cache</h4>
<ul>
<li>缓存的是文件，所有的文件都在page cache中有一份，读写都在page
cache中</li>
<li>多级的cache：以文件为力度存、以block为力度存IO block
buffer，通常会有double cache，同一个被cache了两次，又浪费</li>
</ul>
<h4 id="recovery">Recovery</h4>
<ul>
<li>文件系统需要可以recover
<ul>
<li>backup，使用冗余</li>
<li>log-structured File System</li>
</ul></li>
</ul>
<h4 id="log-structured-file-system">Log-Structured File System</h4>
<ul>
<li>LSFS，基于日志的文件系统
<ul>
<li>更新的元数据按顺序写入循环日志</li>
<li>比如我们现在写这个文件，日志中添加写操作，并没有直接写。</li>
<li>同时，我们有线程，会把log entry进行慢慢执行，这时才会真正写。</li>
<li>当system crash了，我们只需要根据log进行恢复即可</li>
</ul></li>
</ul>
<h2 id="lecture-17">Lecture 17</h2>
<h3 id="file-system-in-practice">File System in Practice</h3>
<ul>
<li>File
<ul>
<li>字节的线性数组，每个字节都可以读/写</li>
<li>有一个低级的名称(用户不知道)- inode号</li>
<li>通常操作系统不知道文件的确切类型</li>
</ul></li>
<li>目录
<ul>
<li>有一个低级名称</li>
<li>它的内容非常具体:包含用户可读的ame到低级名称的列表。Like ("foo"，
inode number 10)</li>
<li>每个条目都指向文件或其他目录</li>
</ul></li>
</ul>
<h5 id="file">File</h5>
<ul>
<li>External Name：人读的名字</li>
<li>Internal Name：Low-Level Names即inode number
<ul>
<li>相当于序列号，存着一些pointer，之前提到的</li>
</ul></li>
</ul>
<h5 id="directory">Directory</h5>
<ul>
<li>从External外部名称转换为Internal内部名称</li>
<li>inode到external name的映射</li>
</ul>
<h4 id="操作">操作</h4>
<ul>
<li><p>Create file</p>
<ul>
<li><pre><code>  int fd = open(&quot;foo&quot;,O_CREAT|O_WRONLY|O_TRUNC)</code></pre></li>
<li><p>一般不返回inode，返回给user也不理解，fd是什么？</p></li>
<li><p>一个file descriptior，类似一个文件编号一个句柄。文件在file
desciptor table中的index</p></li>
</ul></li>
<li><p>Write and fsync</p>
<ul>
<li>写到buffer中，buffer每隔一段时间会同步一下</li>
<li>或者用fsync强制同步写磁盘</li>
</ul></li>
<li><p>获得inode信息</p>
<ul>
<li><code>stat foo</code>即可获得文件信息</li>
</ul></li>
<li><p>Remove file</p></li>
</ul>
<h5 id="hard-link-vs-soft-link">Hard link vs Soft link</h5>
<ul>
<li>Hard link
<ul>
<li>硬链接是与文件相关联的目录条目，是一个<strong>目录项</strong>，指向一个文件</li>
<li>目录中的文件名“.”是到该目录本身的硬链接</li>
<li>文件名“..”是到父目录的硬链接</li>
<li>hard link没有inode</li>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221225191853797.png" alt="image-20221225191853797">
<figcaption aria-hidden="true">image-20221225191853797</figcaption>
</figure></li>
<li>一个hard link是一个目录中的目录项，目录有inode，目录项没有inode</li>
</ul></li>
<li>Soft link
<ul>
<li>Symbolic链接是包含路径名的文件另一个文件，<strong>是一个文件</strong></li>
<li>有自己的数据块，数据块存的内容是path to target file</li>
<li>有inode</li>
</ul></li>
<li>轻量级的是hard link，不涉及inode分配</li>
</ul>
<h3 id="fs">FS</h3>
<ul>
<li>VFS：inode</li>
<li>In-memory data structure：ext2_inode_info</li>
<li>On-disk data structure：ext2_inode</li>
</ul>
<p>【Example】</p>
<p>假设我们有64个block，每一个block为4KB，我们有256KB的disk</p>
<p>我们会有56个存data，8个存metadata(其中5个存inode，假设一个block有16个inodes，那么我们有80个inode)，还有三个block，两个给bit
map，一个是bitmap给free inode的，一个是给free data
region的，剩下一个给文件系统的superblock。</p>
<figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221225193606886.png" alt="image-20221225193606886">
<figcaption aria-hidden="true">image-20221225193606886</figcaption>
</figure>
<h5 id="inode-address-calculation">inode address calculation</h5>
<p>假设我们的inode是256bytes，4KB的block有16个inode，那么5个block就有80个inode，那就可以有80个files(directories)。</p>
<figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221225194110441.png" alt="image-20221225194110441">
<figcaption aria-hidden="true">image-20221225194110441</figcaption>
</figure>
<p>每个inode有number，叫做inumber</p>
<p>想要读inumber = 32的inode</p>
<ul>
<li><span class="math inline">\(4K+4K+4K+32*256bytes=20K(bytes)\)</span></li>
</ul>
<p>inode里面就有data pointer了，就可以访问data了！</p>
<h3 id="directory的组织">Directory的组织</h3>
<p>假设我们的dir有三个文件foo,bar,foobar</p>
<ul>
<li>inode number，name</li>
<li>strlen：名字的长度</li>
<li>reclen：名称的长度加上剩余的空格
<ul>
<li>用于重复使用入口的目的</li>
</ul></li>
</ul>
<h3 id="分析">分析</h3>
<ul>
<li>读 /foo/bar
<ul>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221225194808304.png" alt="image-20221225194808304">
<figcaption aria-hidden="true">image-20221225194808304</figcaption>
</figure></li>
<li>读root inode的data里面有目录项即foo的inode</li>
<li>读foo的data找到里面的目录项，拿到bar的inode</li>
<li>把bar的inode拿出来</li>
</ul></li>
<li>写 /foo/bar
<ul>
<li><figure>
<img src="/Learning/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221225195350091.png" alt="image-20221225195350091">
<figcaption aria-hidden="true">image-20221225195350091</figcaption>
</figure></li>
</ul></li>
</ul>


        <hr>
        <!-- Pager -->
        <ul class="pager">
          
          
          <li class="next">
            <a href="/Learning/CV/" data-toggle="tooltip" data-placement="top" title="CV复习版">Next Post &rarr;</a>
          </li>
          
        </ul>

        
        <!-- tip start -->
        <!-- tip -->
<!-- tip start -->
<div class="tip">
  <p>
    
      如果您喜欢此博客或发现它对您有用，则欢迎对此发表评论。 也欢迎您共享此博客，以便更多人可以参与。 如果博客中使用的图像侵犯了您的版权，请与作者联系以将其删除。 谢谢 ！
    
  </p>
</div>
<!-- tip end -->

        <!-- tip end -->
        

        
        <!-- Sharing Srtart -->
        <!-- Social Social Share Post -->
<!-- Docs:https://github.com/overtrue/share.js -->

<div class="social-share" data-initialized="true" data-disabled="tencent ,douban ,qzone ,linkedin ,facebook ,google ,diandian" data-wechat-qrcode-helper="" align="center">
  <ul class="list-inline text-center social-share-ul">
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon icon-twitter">
        <i class="fa fa-twitter fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a class="social-share-icon icon-wechat">
        <i class="fa fa-weixin fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon icon-weibo">
        <i class="fa fa-weibo fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon icon-qq">
        <i class="fa fa-qq fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon" href="mailto:?subject=操作系统&body=Hi,I found this website and thought you might like it http://Hualingz.cn/Learning/操作系统/">
        <i class="fa fa-envelope fa-1x" aria-hidden="true"></i>
      </a>
    </li>
  </ul>
</div>

<!-- css & js -->
<!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css"> -->
<script defer="defer" async="true" src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>

        <!-- Sharing End -->
        
        <hr>

        <!-- comments start -->
        <!-- 1. gitalk comment -->

  <!-- gitalk start -->
  <!-- Docs:https://github.com/gitalk/gitalk/blob/master/readme-cn.md -->

  <div id="gitalk-container"></div>

  
    <!-- <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.js"></script> -->
    <script src="/js/comment/gitalk.js"></script>
  

  <script>
    var gitalk = new Gitalk({
      clientID: '',
      clientSecret: '',
      repo: '',
      owner: '',
      admin: '',
      id: 'Thu Feb 16 2023 19:04:38 GMT+0800', // Ensure uniqueness and length less than 50
      distractionFreeMode: false, // Facebook-like distraction free mode
      perPage: 10,
      pagerDirection: 'last',
      createIssueManually: false,
      language: 'en',
      proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token'
    });
    gitalk.render('gitalk-container');

    var gtFolded = () => {
      setTimeout(function () {
        let markdownBody = document.getElementsByClassName("markdown-body");
        let list = Array.from(markdownBody);
        list.forEach(item => {
          if (item.clientHeight > 250) {
            item.classList.add('gt-comment-body-folded');
            item.style.maxHeight = '250px';
            item.title = 'Click to Expand';
            item.onclick = function () {
              item.classList.remove('gt-comment-body-folded');
              item.style.maxHeight = '';
              item.title = '';
              item.onclick = null;
            };
          }
        })
      }, 800);
    }
  </script>

  <!-- gitalk end -->


<!-- 2. gitment comment -->


<!-- 3. disqus comment -->


        <!-- comments end -->
        <hr>

      </div>

      <!-- Catalog: Tabe of Content -->
      <!-- Table of Contents -->

    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">目录</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">操作系统</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#lecture-1-1"><span class="toc-nav-number">1.1.</span> <span class="toc-nav-text">Lecture 1-1</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#prerequirement"><span class="toc-nav-number">1.1.1.</span> <span class="toc-nav-text">Prerequirement</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#grading"><span class="toc-nav-number">1.1.2.</span> <span class="toc-nav-text">Grading</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#lab"><span class="toc-nav-number">1.1.3.</span> <span class="toc-nav-text">Lab</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#data-stored-in-memory"><span class="toc-nav-number">1.1.4.</span> <span class="toc-nav-text">Data Stored in Memory</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#lecture-1-2"><span class="toc-nav-number">1.2.</span> <span class="toc-nav-text">Lecture 1-2</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#review"><span class="toc-nav-number">1.2.1.</span> <span class="toc-nav-text">Review</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#cpu"><span class="toc-nav-number">1.2.1.1.</span> <span class="toc-nav-text">CPU</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#dma"><span class="toc-nav-number">1.2.1.2.</span> <span class="toc-nav-text">DMA</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#memory-hierarchy"><span class="toc-nav-number">1.2.1.3.</span> <span class="toc-nav-text">Memory Hierarchy</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#cache%E4%B8%BA%E4%BB%80%E4%B9%88work"><span class="toc-nav-number">1.2.1.3.1.</span> <span class="toc-nav-text">Cache为什么work？</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#moores-law"><span class="toc-nav-number">1.2.1.3.2.</span> <span class="toc-nav-text">Moore&#39;s Law</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#smp-system"><span class="toc-nav-number">1.2.1.4.</span> <span class="toc-nav-text">SMP System</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#multi-core-chips"><span class="toc-nav-number">1.2.1.5.</span> <span class="toc-nav-text">Multi-core Chips</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#os"><span class="toc-nav-number">1.2.2.</span> <span class="toc-nav-text">OS</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#running-os"><span class="toc-nav-number">1.2.2.1.</span> <span class="toc-nav-text">Running OS</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E7%A1%AC%E4%BB%B6%E8%B5%84%E6%BA%90"><span class="toc-nav-number">1.2.2.2.</span> <span class="toc-nav-text">操作系统如何管理硬件资源</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#lecture-2-1"><span class="toc-nav-number">1.3.</span> <span class="toc-nav-text">Lecture 2-1</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#os-events"><span class="toc-nav-number">1.3.1.</span> <span class="toc-nav-text">OS Events</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#event%E5%88%86%E7%B1%BB"><span class="toc-nav-number">1.3.1.1.</span> <span class="toc-nav-text">Event分类</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#system-calls"><span class="toc-nav-number">1.3.1.2.</span> <span class="toc-nav-text">System Calls</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#main-os-services"><span class="toc-nav-number">1.3.2.</span> <span class="toc-nav-text">Main OS Services</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#os-structures"><span class="toc-nav-number">1.3.3.</span> <span class="toc-nav-text">OS Structures</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#user-and-operating-system-interface"><span class="toc-nav-number">1.3.3.1.</span> <span class="toc-nav-text">User and Operating System
Interface</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#system-calls-1"><span class="toc-nav-number">1.3.4.</span> <span class="toc-nav-text">System Calls</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#lecture-2-2"><span class="toc-nav-number">1.4.</span> <span class="toc-nav-text">Lecture 2-2</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#system-calls-2"><span class="toc-nav-number">1.4.1.</span> <span class="toc-nav-text">System Calls</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#sys-call%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-nav-number">1.4.1.1.</span> <span class="toc-nav-text">Sys Call的例子</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#sys-call%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-nav-number">1.4.1.2.</span> <span class="toc-nav-text">Sys Call的参数传递</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#system-service"><span class="toc-nav-number">1.4.1.3.</span> <span class="toc-nav-text">System Service</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#linkers-and-loaders"><span class="toc-nav-number">1.4.2.</span> <span class="toc-nav-text">Linkers and Loaders</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#linkers"><span class="toc-nav-number">1.4.2.1.</span> <span class="toc-nav-text">Linkers</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#loaders"><span class="toc-nav-number">1.4.2.2.</span> <span class="toc-nav-text">Loaders</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#lecture-3-1"><span class="toc-nav-number">1.5.</span> <span class="toc-nav-text">Lecture 3-1</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#linkers-and-loaders-1"><span class="toc-nav-number">1.5.1.</span> <span class="toc-nav-text">Linkers and Loaders</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#loaders-1"><span class="toc-nav-number">1.5.1.1.</span> <span class="toc-nav-text">Loaders</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#clarify"><span class="toc-nav-number">1.5.1.2.</span> <span class="toc-nav-text">Clarify</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#static%E5%92%8Cdynamic-link%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-nav-number">1.5.2.</span> <span class="toc-nav-text">Static和Dynamic Link的区别</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#os%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-nav-number">1.5.3.</span> <span class="toc-nav-text">OS的设计</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#os%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-nav-number">1.5.4.</span> <span class="toc-nav-text">OS的结构</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#lecture-3-2"><span class="toc-nav-number">1.6.</span> <span class="toc-nav-text">Lecture 3-2</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#processes-concept"><span class="toc-nav-number">1.6.1.</span> <span class="toc-nav-text">Processes Concept</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#stack"><span class="toc-nav-number">1.6.2.</span> <span class="toc-nav-text">Stack</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#multi-tasking"><span class="toc-nav-number">1.6.2.0.1.</span> <span class="toc-nav-text">multi-Tasking</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#process-state"><span class="toc-nav-number">1.6.3.</span> <span class="toc-nav-text">Process State</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#pcbprocess-control-block"><span class="toc-nav-number">1.6.4.</span> <span class="toc-nav-text">PCB（Process Control Block）</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#process-creation"><span class="toc-nav-number">1.6.5.</span> <span class="toc-nav-text">【1】Process Creation</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#process-terminations"><span class="toc-nav-number">1.6.6.</span> <span class="toc-nav-text">【2】Process Terminations</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#processes-and-signals"><span class="toc-nav-number">1.6.7.</span> <span class="toc-nav-text">【3】Processes and Signals</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#lecture-4-1"><span class="toc-nav-number">1.7.</span> <span class="toc-nav-text">Lecture 4-1</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#process-state-1"><span class="toc-nav-number">1.7.1.</span> <span class="toc-nav-text">Process State</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#lecture-5-1"><span class="toc-nav-number">1.8.</span> <span class="toc-nav-text">Lecture 5-1</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#fork-return-values"><span class="toc-nav-number">1.8.1.</span> <span class="toc-nav-text">Fork( ) return values</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#zombie"><span class="toc-nav-number">1.8.2.</span> <span class="toc-nav-text">Zombie</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#orphans"><span class="toc-nav-number">1.8.3.</span> <span class="toc-nav-text">Orphans</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#lecture-5-2"><span class="toc-nav-number">1.9.</span> <span class="toc-nav-text">Lecture 5-2</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#ipcsinter-process-communication"><span class="toc-nav-number">1.9.1.</span> <span class="toc-nav-text">IPCs：Inter-Process
Communication</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#share-memory"><span class="toc-nav-number">1.9.1.1.</span> <span class="toc-nav-text">Share Memory</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#exampleposix-shared-memory"><span class="toc-nav-number">1.9.1.1.1.</span> <span class="toc-nav-text">Example：POSIX Shared Memory</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#message-passing"><span class="toc-nav-number">1.9.1.2.</span> <span class="toc-nav-text">Message passing</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#pipe"><span class="toc-nav-number">1.9.1.3.</span> <span class="toc-nav-text">Pipe</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#ordinary-pipes"><span class="toc-nav-number">1.9.1.3.1.</span> <span class="toc-nav-text">Ordinary Pipes</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#named-pipes"><span class="toc-nav-number">1.9.1.3.2.</span> <span class="toc-nav-text">Named Pipes</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#client-server-communication"><span class="toc-nav-number">1.9.1.4.</span> <span class="toc-nav-text">Client-Server Communication</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#lecture-6-1"><span class="toc-nav-number">1.10.</span> <span class="toc-nav-text">Lecture 6-1</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#thread"><span class="toc-nav-number">1.10.1.</span> <span class="toc-nav-text">Thread</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#advantages-of-thread"><span class="toc-nav-number">1.10.2.</span> <span class="toc-nav-text">Advantages of Thread</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#drawbacks"><span class="toc-nav-number">1.10.3.</span> <span class="toc-nav-text">DrawBacks</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#user-thread%E5%92%8Ckernel-thread"><span class="toc-nav-number">1.10.4.</span> <span class="toc-nav-text">User Thread和Kernel Thread</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#lecture-6-2"><span class="toc-nav-number">1.11.</span> <span class="toc-nav-text">Lecture 6-2</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#semantics-of-fork-and-exec"><span class="toc-nav-number">1.11.1.</span> <span class="toc-nav-text">Semantics of fork() and exec()</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#thread%E7%9A%84fork"><span class="toc-nav-number">1.11.1.1.</span> <span class="toc-nav-text">thread的fork</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#signals"><span class="toc-nav-number">1.11.1.2.</span> <span class="toc-nav-text">Signals</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#safe-thread-cancellation"><span class="toc-nav-number">1.11.1.3.</span> <span class="toc-nav-text">Safe Thread Cancellation</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#windows-threads"><span class="toc-nav-number">1.11.2.</span> <span class="toc-nav-text">Windows Threads</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#linux-threads"><span class="toc-nav-number">1.11.3.</span> <span class="toc-nav-text">Linux Threads</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#threads-within-process"><span class="toc-nav-number">1.11.4.</span> <span class="toc-nav-text">Threads within Process</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#user-thread-to-kernel-thread-mapping"><span class="toc-nav-number">1.11.5.</span> <span class="toc-nav-text">User Thread to Kernel
Thread Mapping</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#lecture-7-1"><span class="toc-nav-number">1.12.</span> <span class="toc-nav-text">Lecture 7-1</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#cpu-scheduling"><span class="toc-nav-number">1.12.1.</span> <span class="toc-nav-text">CPU Scheduling</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#scheduling%E6%96%B9%E6%B3%95"><span class="toc-nav-number">1.12.1.1.</span> <span class="toc-nav-text">Scheduling方法</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#scheduling%E7%9A%84%E5%86%B3%E7%AD%96%E6%97%B6%E6%9C%BA"><span class="toc-nav-number">1.12.1.1.1.</span> <span class="toc-nav-text">Scheduling的决策时机</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#scheduling%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-nav-number">1.12.1.1.2.</span> <span class="toc-nav-text">Scheduling的目标</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#scheduling-queue"><span class="toc-nav-number">1.12.1.1.3.</span> <span class="toc-nav-text">Scheduling Queue</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#scheduling-algorithm"><span class="toc-nav-number">1.12.1.1.4.</span> <span class="toc-nav-text">Scheduling Algorithm</span></a></li></ol></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#lecture-7-2"><span class="toc-nav-number">1.13.</span> <span class="toc-nav-text">Lecture 7-2</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#thread-scheduling"><span class="toc-nav-number">1.13.1.</span> <span class="toc-nav-text">Thread Scheduling</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#multiple-processor"><span class="toc-nav-number">1.13.2.</span> <span class="toc-nav-text">Multiple-Processor</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#os-view"><span class="toc-nav-number">1.13.2.1.</span> <span class="toc-nav-text">OS View</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#os-scheduling"><span class="toc-nav-number">1.13.3.</span> <span class="toc-nav-text">OS Scheduling</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#windows"><span class="toc-nav-number">1.13.3.1.</span> <span class="toc-nav-text">Windows</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#linux"><span class="toc-nav-number">1.13.3.2.</span> <span class="toc-nav-text">Linux</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#lecture-8-1"><span class="toc-nav-number">1.14.</span> <span class="toc-nav-text">Lecture 8-1</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#synchronization%E5%90%8C%E6%AD%A5"><span class="toc-nav-number">1.14.1.</span> <span class="toc-nav-text">Synchronization同步</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#data-cursh"><span class="toc-nav-number">1.14.1.0.1.</span> <span class="toc-nav-text">Data Cursh</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#critical-section"><span class="toc-nav-number">1.14.1.1.</span> <span class="toc-nav-text">Critical Section</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#memory-barriers"><span class="toc-nav-number">1.14.1.2.</span> <span class="toc-nav-text">Memory Barriers</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#hardware-instructions"><span class="toc-nav-number">1.14.1.3.</span> <span class="toc-nav-text">Hardware Instructions</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#mutex-locks"><span class="toc-nav-number">1.14.2.</span> <span class="toc-nav-text">Mutex Locks</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#lecture-9-1"><span class="toc-nav-number">1.15.</span> <span class="toc-nav-text">Lecture 9-1</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#semaphore"><span class="toc-nav-number">1.15.1.</span> <span class="toc-nav-text">Semaphore</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#deadlock-and-starvation"><span class="toc-nav-number">1.15.2.</span> <span class="toc-nav-text">Deadlock and Starvation</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#priority-inversion"><span class="toc-nav-number">1.15.3.</span> <span class="toc-nav-text">Priority Inversion</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#linux%E7%9A%84synchronization"><span class="toc-nav-number">1.15.4.</span> <span class="toc-nav-text">Linux的Synchronization</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#condition-variable"><span class="toc-nav-number">1.15.5.</span> <span class="toc-nav-text">Condition Variable</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#bounded-buffer-problem"><span class="toc-nav-number">1.15.6.</span> <span class="toc-nav-text">Bounded-Buffer Problem</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#producer"><span class="toc-nav-number">1.15.6.1.</span> <span class="toc-nav-text">Producer</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#consumer"><span class="toc-nav-number">1.15.6.2.</span> <span class="toc-nav-text">Consumer</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#reader-and-writer-problem"><span class="toc-nav-number">1.15.7.</span> <span class="toc-nav-text">Reader and Writer Problem</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#writer"><span class="toc-nav-number">1.15.7.1.</span> <span class="toc-nav-text">Writer</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#reader"><span class="toc-nav-number">1.15.7.2.</span> <span class="toc-nav-text">Reader</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#dining-philosophers-problem"><span class="toc-nav-number">1.15.8.</span> <span class="toc-nav-text">Dining-Philosophers Problem</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#lecture-9-2"><span class="toc-nav-number">1.16.</span> <span class="toc-nav-text">Lecture 9-2</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#deadlock"><span class="toc-nav-number">1.16.1.</span> <span class="toc-nav-text">DeadLock</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%9B%9B%E4%B8%AA%E6%9D%A1%E4%BB%B6"><span class="toc-nav-number">1.16.1.1.</span> <span class="toc-nav-text">死锁的四个条件</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#resource-allocation-graph"><span class="toc-nav-number">1.16.1.2.</span> <span class="toc-nav-text">Resource-Allocation Graph</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E8%A7%A3%E5%86%B3"><span class="toc-nav-number">1.16.2.</span> <span class="toc-nav-text">死锁的解决</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#prevention"><span class="toc-nav-number">1.16.2.1.</span> <span class="toc-nav-text">Prevention</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#avoidance"><span class="toc-nav-number">1.16.2.2.</span> <span class="toc-nav-text">Avoidance</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#deadlock-detection"><span class="toc-nav-number">1.16.2.3.</span> <span class="toc-nav-text">Deadlock Detection</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#deadlock-recovery"><span class="toc-nav-number">1.16.2.4.</span> <span class="toc-nav-text">Deadlock Recovery</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#lecture-10-1"><span class="toc-nav-number">1.17.</span> <span class="toc-nav-text">Lecture 10-1</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#main-memory"><span class="toc-nav-number">1.17.1.</span> <span class="toc-nav-text">Main Memory</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#partition"><span class="toc-nav-number">1.17.1.1.</span> <span class="toc-nav-text">Partition</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-nav-number">1.17.1.2.</span> <span class="toc-nav-text">优势</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#memory-allocation-strategies"><span class="toc-nav-number">1.17.1.3.</span> <span class="toc-nav-text">Memory Allocation Strategies</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#segmentation"><span class="toc-nav-number">1.17.2.</span> <span class="toc-nav-text">Segmentation</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#address-binding"><span class="toc-nav-number">1.17.2.1.</span> <span class="toc-nav-text">Address Binding</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#logical-vs-physical-address"><span class="toc-nav-number">1.17.2.2.</span> <span class="toc-nav-text">Logical vs Physical Address</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#mmu"><span class="toc-nav-number">1.17.2.3.</span> <span class="toc-nav-text">MMU</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#paging%E5%88%86%E9%A1%B5"><span class="toc-nav-number">1.17.3.</span> <span class="toc-nav-text">Paging分页</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#page-table"><span class="toc-nav-number">1.17.3.1.</span> <span class="toc-nav-text">Page Table</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#%E9%A1%B5%E9%9D%A2%E8%BD%AC%E6%8D%A2%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-nav-number">1.17.3.1.1.</span> <span class="toc-nav-text">页面转换的过程</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0"><span class="toc-nav-number">1.17.3.2.</span> <span class="toc-nav-text">硬件实现</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#tlb"><span class="toc-nav-number">1.17.4.</span> <span class="toc-nav-text">TLB</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#tlb%E7%9A%84%E6%95%88%E7%8E%87"><span class="toc-nav-number">1.17.4.1.</span> <span class="toc-nav-text">TLB的效率</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#memory-protection"><span class="toc-nav-number">1.17.5.</span> <span class="toc-nav-text">Memory Protection</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#page-sharing"><span class="toc-nav-number">1.17.6.</span> <span class="toc-nav-text">Page Sharing</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#structure-of-page-table"><span class="toc-nav-number">1.17.7.</span> <span class="toc-nav-text">Structure of Page Table</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%A6%82%E4%BD%95%E5%AF%BB%E5%9D%80"><span class="toc-nav-number">1.17.7.1.</span> <span class="toc-nav-text">如何寻址：</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8"><span class="toc-nav-number">1.17.7.2.</span> <span class="toc-nav-text">内存占用：</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#eg64bit%E6%97%B6%E4%BD%BF%E7%94%A839%E4%BD%8D%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80"><span class="toc-nav-number">1.17.7.2.1.</span> <span class="toc-nav-text">EG：64bit时，使用39位逻辑地址</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%9A%84tlb"><span class="toc-nav-number">1.17.7.3.</span> <span class="toc-nav-text">多级页表的TLB</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#lecture-10-2"><span class="toc-nav-number">1.18.</span> <span class="toc-nav-text">Lecture 10-2</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#inverted-page-table"><span class="toc-nav-number">1.18.1.</span> <span class="toc-nav-text">Inverted Page Table</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#swapping"><span class="toc-nav-number">1.18.2.</span> <span class="toc-nav-text">Swapping</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#page%E5%92%8Csegmentation"><span class="toc-nav-number">1.18.3.</span> <span class="toc-nav-text">Page和Segmentation</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#pae"><span class="toc-nav-number">1.18.4.</span> <span class="toc-nav-text">PAE</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#linux-1"><span class="toc-nav-number">1.18.5.</span> <span class="toc-nav-text">Linux</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#lecture-11-1"><span class="toc-nav-number">1.19.</span> <span class="toc-nav-text">Lecture 11-1</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#linux-and-virtual-memory"><span class="toc-nav-number">1.19.1.</span> <span class="toc-nav-text">Linux and Virtual Memory</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#flat-memory"><span class="toc-nav-number">1.19.1.1.</span> <span class="toc-nav-text">Flat Memory</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#virtual-memory"><span class="toc-nav-number">1.19.2.</span> <span class="toc-nav-text">Virtual Memory</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#mmu-1"><span class="toc-nav-number">1.19.2.1.</span> <span class="toc-nav-text">MMU</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#tlb-1"><span class="toc-nav-number">1.19.2.1.1.</span> <span class="toc-nav-text">TLB</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#page-fault"><span class="toc-nav-number">1.19.2.1.2.</span> <span class="toc-nav-text">Page Fault</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#lazy-allocation"><span class="toc-nav-number">1.19.2.2.</span> <span class="toc-nav-text">Lazy Allocation</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#linux-virtual-addresses"><span class="toc-nav-number">1.19.2.3.</span> <span class="toc-nav-text">Linux-Virtual Addresses</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#virtual-address-and-physical-ram-mapping"><span class="toc-nav-number">1.19.2.4.</span> <span class="toc-nav-text">Virtual address and
physical RAM mapping</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#share-memory-1"><span class="toc-nav-number">1.19.2.5.</span> <span class="toc-nav-text">Share Memory</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#lecture-11-2"><span class="toc-nav-number">1.20.</span> <span class="toc-nav-text">Lecture 11-2</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#page-fault-1"><span class="toc-nav-number">1.20.1.</span> <span class="toc-nav-text">Page Fault</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#swapping-1"><span class="toc-nav-number">1.20.2.</span> <span class="toc-nav-text">Swapping</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#demanding-paging"><span class="toc-nav-number">1.20.3.</span> <span class="toc-nav-text">Demanding Paging</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#copy-on-write"><span class="toc-nav-number">1.20.4.</span> <span class="toc-nav-text">Copy on Write</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#there-is-no-free-frame"><span class="toc-nav-number">1.20.5.</span> <span class="toc-nav-text">There is no Free Frame</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#page-replacement"><span class="toc-nav-number">1.20.6.</span> <span class="toc-nav-text">Page Replacement</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#lecture-12"><span class="toc-nav-number">1.21.</span> <span class="toc-nav-text">Lecture 12</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#get-free-frame"><span class="toc-nav-number">1.21.1.</span> <span class="toc-nav-text">Get Free Frame</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#there-is-no-free-frame-1"><span class="toc-nav-number">1.21.2.</span> <span class="toc-nav-text">There is no Free Frame</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#page-replacement-1"><span class="toc-nav-number">1.21.3.</span> <span class="toc-nav-text">Page Replacement</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#fifo"><span class="toc-nav-number">1.21.4.</span> <span class="toc-nav-text">FIFO</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#optimal"><span class="toc-nav-number">1.21.5.</span> <span class="toc-nav-text">Optimal</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#lru"><span class="toc-nav-number">1.21.6.</span> <span class="toc-nav-text">LRU</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#lfu"><span class="toc-nav-number">1.21.7.</span> <span class="toc-nav-text">LFU</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#page-buffering-algorithm"><span class="toc-nav-number">1.21.8.</span> <span class="toc-nav-text">Page-Buffering Algorithm</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#frame-allocation"><span class="toc-nav-number">1.21.9.</span> <span class="toc-nav-text">Frame Allocation</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#globallocal-allocation"><span class="toc-nav-number">1.21.9.1.</span> <span class="toc-nav-text">Global&#x2F;Local Allocation</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#page-reclaiming"><span class="toc-nav-number">1.21.9.2.</span> <span class="toc-nav-text">Page Reclaiming</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#major-and-minor-page-fault"><span class="toc-nav-number">1.21.9.3.</span> <span class="toc-nav-text">Major and Minor Page Fault</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#thrashing"><span class="toc-nav-number">1.21.9.4.</span> <span class="toc-nav-text">Thrashing</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#working-sets-model"><span class="toc-nav-number">1.21.9.5.</span> <span class="toc-nav-text">Working Sets Model</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#page-fault-frequency"><span class="toc-nav-number">1.21.9.6.</span> <span class="toc-nav-text">Page-Fault Frequency</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#lecture-13"><span class="toc-nav-number">1.22.</span> <span class="toc-nav-text">Lecture 13</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#kernel-memory-allocation"><span class="toc-nav-number">1.22.1.</span> <span class="toc-nav-text">Kernel Memory Allocation</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#page-fault-handling-in-linux"><span class="toc-nav-number">1.22.2.</span> <span class="toc-nav-text">Page Fault Handling in Linux</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#buddy-system"><span class="toc-nav-number">1.22.3.</span> <span class="toc-nav-text">Buddy System</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#slab-allocator"><span class="toc-nav-number">1.22.4.</span> <span class="toc-nav-text">Slab Allocator</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#prepaging"><span class="toc-nav-number">1.22.5.</span> <span class="toc-nav-text">Prepaging</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#pagesize"><span class="toc-nav-number">1.22.6.</span> <span class="toc-nav-text">PageSize</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#tlb-reach"><span class="toc-nav-number">1.22.7.</span> <span class="toc-nav-text">TLB reach</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#io-interlock"><span class="toc-nav-number">1.22.8.</span> <span class="toc-nav-text">I&#x2F;O interlock</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#lecture-13-1"><span class="toc-nav-number">1.23.</span> <span class="toc-nav-text">Lecture 13-1</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#memory-management-summary"><span class="toc-nav-number">1.23.1.</span> <span class="toc-nav-text">Memory Management Summary</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#mass-storage-structure"><span class="toc-nav-number">1.23.2.</span> <span class="toc-nav-text">Mass-Storage Structure</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#moving-head-magentic-disk"><span class="toc-nav-number">1.23.3.</span> <span class="toc-nav-text">Moving-head Magentic Disk</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#disk-scheduling"><span class="toc-nav-number">1.23.4.</span> <span class="toc-nav-text">Disk Scheduling</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#nonvolatile-memory-devices"><span class="toc-nav-number">1.23.5.</span> <span class="toc-nav-text">Nonvolatile Memory Devices</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#nand-flash-controller-algorithm"><span class="toc-nav-number">1.23.6.</span> <span class="toc-nav-text">NAND Flash Controller
Algorithm</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#magnetic-tape"><span class="toc-nav-number">1.23.7.</span> <span class="toc-nav-text">Magnetic Tape</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#disk-management"><span class="toc-nav-number">1.23.7.1.</span> <span class="toc-nav-text">Disk Management</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#swap-space-management"><span class="toc-nav-number">1.23.7.2.</span> <span class="toc-nav-text">Swap Space Management</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#lecture-14"><span class="toc-nav-number">1.24.</span> <span class="toc-nav-text">Lecture 14</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#raid"><span class="toc-nav-number">1.24.1.</span> <span class="toc-nav-text">RAID</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#io"><span class="toc-nav-number">1.24.2.</span> <span class="toc-nav-text">IO</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#overview"><span class="toc-nav-number">1.24.2.1.</span> <span class="toc-nav-text">OverView</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#io-hardwaare"><span class="toc-nav-number">1.24.2.2.</span> <span class="toc-nav-text">IO Hardwaare</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#polling"><span class="toc-nav-number">1.24.2.3.</span> <span class="toc-nav-text">Polling</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#interrupt"><span class="toc-nav-number">1.24.2.4.</span> <span class="toc-nav-text">Interrupt</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#dma-1"><span class="toc-nav-number">1.24.2.5.</span> <span class="toc-nav-text">DMA</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#application-io-interface"><span class="toc-nav-number">1.24.2.6.</span> <span class="toc-nav-text">Application IO Interface</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#characteristics-of-io-device"><span class="toc-nav-number">1.24.2.7.</span> <span class="toc-nav-text">Characteristics of IO Device</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#lecture-15"><span class="toc-nav-number">1.25.</span> <span class="toc-nav-text">Lecture 15</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#linux-io"><span class="toc-nav-number">1.25.1.</span> <span class="toc-nav-text">Linux IO</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#file-system-interface"><span class="toc-nav-number">1.25.2.</span> <span class="toc-nav-text">File System Interface</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#mass-storage"><span class="toc-nav-number">1.25.2.1.</span> <span class="toc-nav-text">Mass Storage</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#file-attributes"><span class="toc-nav-number">1.25.2.2.</span> <span class="toc-nav-text">File Attributes</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#file-operations"><span class="toc-nav-number">1.25.2.3.</span> <span class="toc-nav-text">File Operations</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#open-files"><span class="toc-nav-number">1.25.2.3.1.</span> <span class="toc-nav-text">Open Files</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#access-method"><span class="toc-nav-number">1.25.3.</span> <span class="toc-nav-text">Access Method</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#directory-structure"><span class="toc-nav-number">1.25.4.</span> <span class="toc-nav-text">Directory Structure</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#directory-organization"><span class="toc-nav-number">1.25.4.1.</span> <span class="toc-nav-text">Directory Organization</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#acyclic-graph-directories"><span class="toc-nav-number">1.25.4.1.1.</span> <span class="toc-nav-text">Acyclic-Graph Directories</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#genral-graph-directories"><span class="toc-nav-number">1.25.4.1.2.</span> <span class="toc-nav-text">Genral Graph Directories</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#file-system-mounting"><span class="toc-nav-number">1.25.4.2.</span> <span class="toc-nav-text">File System Mounting</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#file-sharing"><span class="toc-nav-number">1.25.4.3.</span> <span class="toc-nav-text">File Sharing</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#protection"><span class="toc-nav-number">1.25.5.</span> <span class="toc-nav-text">Protection</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#lecture-16"><span class="toc-nav-number">1.26.</span> <span class="toc-nav-text">Lecture 16</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#file-system-structure"><span class="toc-nav-number">1.26.1.</span> <span class="toc-nav-text">File-system structure</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#layered-file-system"><span class="toc-nav-number">1.26.1.1.</span> <span class="toc-nav-text">Layered File System</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#file-system-data-structure"><span class="toc-nav-number">1.26.1.2.</span> <span class="toc-nav-text">File system Data structure</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#typical-file-control-block"><span class="toc-nav-number">1.26.1.3.</span> <span class="toc-nav-text">Typical File Control Block</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-nav-number">1.26.1.4.</span> <span class="toc-nav-text">文件的操作</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#creation"><span class="toc-nav-number">1.26.1.4.1.</span> <span class="toc-nav-text">Creation()</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#open"><span class="toc-nav-number">1.26.1.4.2.</span> <span class="toc-nav-text">open()</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#mounting-file-system"><span class="toc-nav-number">1.26.1.5.</span> <span class="toc-nav-text">Mounting File System</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#virtual-file-system"><span class="toc-nav-number">1.26.1.6.</span> <span class="toc-nav-text">Virtual File System</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#directory-implementation"><span class="toc-nav-number">1.26.2.</span> <span class="toc-nav-text">Directory Implementation</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#disk-block-allocation"><span class="toc-nav-number">1.26.2.1.</span> <span class="toc-nav-text">Disk Block Allocation</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#inode"><span class="toc-nav-number">1.26.2.2.</span> <span class="toc-nav-text">inode</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#free-space-management"><span class="toc-nav-number">1.26.3.</span> <span class="toc-nav-text">Free Space Management</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#bit-map"><span class="toc-nav-number">1.26.3.1.</span> <span class="toc-nav-text">Bit Map</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#linked-free-space"><span class="toc-nav-number">1.26.3.2.</span> <span class="toc-nav-text">Linked Free Space</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#file-system-performance"><span class="toc-nav-number">1.26.4.</span> <span class="toc-nav-text">File System Performance</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#page-cache"><span class="toc-nav-number">1.26.4.1.</span> <span class="toc-nav-text">Page Cache</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#recovery"><span class="toc-nav-number">1.26.4.2.</span> <span class="toc-nav-text">Recovery</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#log-structured-file-system"><span class="toc-nav-number">1.26.4.3.</span> <span class="toc-nav-text">Log-Structured File System</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#lecture-17"><span class="toc-nav-number">1.27.</span> <span class="toc-nav-text">Lecture 17</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#file-system-in-practice"><span class="toc-nav-number">1.27.1.</span> <span class="toc-nav-text">File System in Practice</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#file"><span class="toc-nav-number">1.27.1.0.1.</span> <span class="toc-nav-text">File</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#directory"><span class="toc-nav-number">1.27.1.0.2.</span> <span class="toc-nav-text">Directory</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E6%93%8D%E4%BD%9C"><span class="toc-nav-number">1.27.1.1.</span> <span class="toc-nav-text">操作</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#hard-link-vs-soft-link"><span class="toc-nav-number">1.27.1.1.1.</span> <span class="toc-nav-text">Hard link vs Soft link</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#fs"><span class="toc-nav-number">1.27.2.</span> <span class="toc-nav-text">FS</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#inode-address-calculation"><span class="toc-nav-number">1.27.2.0.1.</span> <span class="toc-nav-text">inode address calculation</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#directory%E7%9A%84%E7%BB%84%E7%BB%87"><span class="toc-nav-number">1.27.3.</span> <span class="toc-nav-text">Directory的组织</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%88%86%E6%9E%90"><span class="toc-nav-number">1.27.4.</span> <span class="toc-nav-text">分析</span></a></li></ol></li></ol></li></ol>
        
        </div>
      </aside>
    



      <!-- Sidebar Container -->
      <div class="
                col-lg-8 col-lg-offset-1
                col-md-10 col-md-offset-1
                sidebar-container">

        <!-- Featured Tags -->
        
        <section>
          <!-- no hr -->
          <h5>
            <a href="/tags/">特色标签</a>
          </h5>
          <div class="tags">
            
            <a class="tag" href="/tags/#浙江大学" title="浙江大学">浙江大学</a>
            
            <a class="tag" href="/tags/#OS操作系统" title="OS操作系统">OS操作系统</a>
            
          </div>
        </section>
        

        <!-- Friends Blog -->
        
        <hr>
        <h5>链友</h5>
        <ul class="list-inline">

          
        </ul>
        
      </div>
    </div>
  </div>
</article>



<!-- anchorjs start -->
<!-- async load function -->
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script type="text/javascript">
  // async load function
  function async (u, c) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) {
      o.addEventListener('load', function(e) {
        c(null, e);
      }, false);
    }
    s.parentNode.insertBefore(o, s);
  };
</script>
<script type="text/javascript">
  //anchor-js, Doc:http://bryanbraun.github.io/anchorjs/
  async ("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js", function() {
    anchors.options = {
      visible: 'hover',
      placement: 'left',
      // icon: 'ℬ'
      icon: '❡'
    };
    anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
  });
</script>
<style>
  /* place left on bigger screen */
  @media all and (min-width: 800px) {
    .anchorjs-link {
      position: absolute;
      left: -0.75em;
      font-size: 1.1em;
      margin-top: -0.1em;
    }
  }
</style>

<!-- anchorjs end -->



		<!-- Footer (contains ThemeColor、viewer) -->
		<!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center">
          

          
            <li>
              <a target="_blank" href="https://github.com/Hualeez">
                <span class="fa-stack fa-lg">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
          

          

          

          

          

          

          

        </ul>
        <p class="copyright text-muted">
          Copyright &copy;
          Hualingz
          2023
          <br>
          Theme by
          <a target="_blank" rel="noopener" href="http://beantech.org">BeanTech</a>
          <span style="display: inline-block; margin: 0 5px;">
            <i class="fa fa-heart"></i>
          </span>
          re-Ported by
          <a target="_blank" rel="noopener" href="https://v-vincen.life/">Live My Life</a>
          |
          <iframe style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0" width="91px" height="20px" src="https://ghbtns.com/github-btn.html?user=V-Vincen&repo=V-Vincen.github.io&type=star&count=true"></iframe>
        </p>
      </div>
    </div>
  </div>
</footer>

<a id="rocket" href="#top" class=""></a>


  <!-- jQuery -->
  <script type="text/javascript" src="/js/jquery.min.js"></script>
  <!-- Bootstrap Core JavaScript -->
  <script type="text/javascript" src="/js/bootstrap.min.js"></script>
  <!-- Custom Theme JavaScript -->
  <script type="text/javascript" src="/js/hux-blog.min.js"></script>
  <!-- catalog -->
  <script async="true" type="text/javascript" src="/js/catalog.js"></script>
  <!-- totop(rocket) -->
  <script async="true" type="text/javascript" src="/js/totop.js"></script>

  
    <!-- Busuanzi JavaScript -->
    <script async="async" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <!-- Scroll start -->
    <script async="async" type="text/javascript" src="/js/scroll.js"></script>
    <!-- Scroll end -->
  

  
    <!-- LangSelect start -->
    <script type="text/javascript" src="/js/langselect.js"></script>
    <!-- LangSelect end -->
  

  
    <!-- Mouseclick -->
    <script type="text/javascript" src="/js/mouseclick.js" content='The first step is as good as half over...,Laugh and grow fat...,Man proposes God disposes...,When all else is lost the future still remains...,Wasting time is robbing oneself...,Sharp tools make good work...,Cease to struggle and you cease to live...,A friend in need is a friend indeed...,Faith can move mountains...' color='#9933CC,#339933,#66CCCC,#FF99CC,#CCCCFF,#6666CC,#663399,#66CC99,#FF0033'></script>
  

  
    <!-- ribbon -->
    <script type="text/javascript" src="/js/ribbonDynamic.js"></script>
  

  






  <!-- viewer start -->
  <!-- viewer start (Picture preview) -->
  
    <script async="async" type="text/javascript" src="/js/viewer/viewer.min.js"></script>
    <script async="async" type="text/javascript" src="/js/viewer/pic-viewer.js"></script>
  

  <!-- viewer end -->


<script>
  // async load function
  function async (u, c) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) {
      o.addEventListener('load', function (e) {
        c(null, e);
      }, false);
    }
    s.parentNode.insertBefore(o, s);
  }

  // fastClick.js
  async ("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function () {
    var $nav = document.querySelector("nav");
    if ($nav)
      FastClick.attach($nav);
    }
  )
</script>

<!-- Because of the native support for backtick-style fenced code blocks right within the Markdown is landed in Github Pages, From V1.6, There is no need for Highlight.js, so Huxblog drops it officially. -
https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0 - https://help.github.com/articles/creating-and-highlighting-code-blocks/ -->
<!-- <script> async ("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function () { hljs.initHighlightingOnLoad(); }) </script> <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet"> -->

<!-- jquery.tagcloud.js -->
<!-- <script> // only load tagcloud.js in tag.html if ($('#tag_cloud').length !== 0) { async ("http://Hualingz.cn/js/jquery.tagcloud.js", function () { $.fn.tagcloud.defaults = { // size: { start: 1, end: 1, unit: 'em' }, color: {
start: '#bbbbee', end: '#0085a1' } }; $('#tag_cloud a').tagcloud(); }) } </script> -->


		<!-- Search -->
		
		<div class="popup search-popup local-search-popup">
  <span class="popup-btn-close">
    ESC
  </span>
  <div class="container">
    <div class="row">
      <!-- <div class="col-md-9 col-md-offset-1"> -->
      <div class="col-lg-9 col-lg-offset-1 col-md-10 col-md-offset-1 local-search-content">

        <div class="local-search-header clearfix">

          <div class="local-search-input-wrapper">
            <span class="search-icon">
              <i class="fa fa-search fa-lg" style="margin: 25px 10px 25px 20px;"></i>
            </span>
            <input autocomplete="off" placeholder="搜索..." type="text" id="local-search-input">
          </div>
        </div>
        <div id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>


  
    <script src="/js/ziploader.js"></script>
  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.json";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    // monitor main search box;
    var onPopupClose = function (e) {
      $('.popup').fadeOut(300);
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $('.popup').fadeIn(300);
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }
    // get search zip version
    $.get('/searchVersion.json?t=' + (+new Date()), function (res) {
      if (localStorage.getItem('searchVersion') !== res) {
        localStorage.setItem('searchVersion', res);
        initSearchJson();
      }
    });

    function initSearchJson() {
      initLoad(['/search.flv'], {
        loadOptions: {
          success: function (obj) {
            localStorage.setItem('searchJson', obj['search.json'])
          },
          error: function (e) {
            return console.log(e)
          }
        },
        returnOptions: {
          'json': TYPE_TEXT
        },
        mimeOptions: {
          'json': 'application/json'
        }
      })
    }
    // search function;
    var searchFunc = function (search_id, content_id) {
      'use strict';
      isfetched = true;
      var datas = JSON.parse(localStorage.getItem('searchJson'));
      // console.log(search_id)
      var input = document.getElementById(search_id);
      var resultContent = document.getElementById(content_id);
      var inputEventFunction = function () {
        var searchText = input.value.trim().toLowerCase();
        var keywords = searchText.split(/[\s\-]+/);
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        var resultItems = [];
        if (searchText.length > 0) {
          // perform local searching
          datas.forEach(function (data) {
            var isMatch = false;
            var hitCount = 0;
            var searchTextCount = 0;
            var title = data.title
              ? data.title.trim()
              : '';
            var titleInLowerCase = title.toLowerCase();
            var content = data.content
              ? data.content.trim().replace(/<[^>]+>/g, "")
              : '';
            var contentInLowerCase = content.toLowerCase();
            var articleUrl = decodeURIComponent(data.url);

            var date = data.date;
            var dateTime = date.replace(/T/, " ").replace(/.000Z/, "");
            var imgUrl = data.header_img;
            


            var indexOfTitle = [];
            var indexOfContent = [];
            // only match articles with not empty titles
            keywords.forEach(function (keyword) {
              function getIndexByWord(word, text, caseSensitive) {
                var wordLen = word.length;
                if (wordLen === 0) {
                  return [];
                }
                var startPosition = 0,
                  position = [],
                  index = [];
                if (!caseSensitive) {
                  text = text.toLowerCase();
                  word = word.toLowerCase();
                }
                while ((position = text.indexOf(word, startPosition)) > -1) {
                  index.push({position: position, word: word});
                  startPosition = position + wordLen;
                }
                return index;
              }
              indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
              indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
            });
            if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
              isMatch = true;
              hitCount = indexOfTitle.length + indexOfContent.length;
            }
            // show search results
            if (isMatch) {
              // sort index by position of keyword
              [indexOfTitle, indexOfContent].forEach(function (index) {
                index.sort(function (itemLeft, itemRight) {
                  if (itemRight.position !== itemLeft.position) {
                    return itemRight.position - itemLeft.position;
                  } else {
                    return itemLeft.word.length - itemRight.word.length;
                  }
                });
              });
              // merge hits into slices
              function mergeIntoSlice(text, start, end, index) {
                var item = index[index.length - 1];
                var position = item.position;
                var word = item.word;
                var hits = [];
                var searchTextCountInSlice = 0;
                while (position + word.length <= end && index.length != 0) {
                  if (word === searchText) {
                    searchTextCountInSlice++;
                  }
                  hits.push({position: position, length: word.length});
                  var wordEnd = position + word.length;
                  // move to next position of hit
                  index.pop();
                  while (index.length != 0) {
                    item = index[index.length - 1];
                    position = item.position;
                    word = item.word;
                    if (wordEnd > position) {
                      index.pop();
                    } else {
                      break;
                    }
                  }
                }
                searchTextCount += searchTextCountInSlice;
                return {hits: hits, start: start, end: end, searchTextCount: searchTextCountInSlice};
              }
              var slicesOfTitle = [];
              if (indexOfTitle.length != 0) {
                slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
              }
              var slicesOfContent = [];
              while (indexOfContent.length != 0) {
                var item = indexOfContent[indexOfContent.length - 1];
                var position = item.position;
                var word = item.word;
                // cut out 100 characters
                var start = position - 20;
                var end = position + 80;
                if (start < 0) {
                  start = 0;
                }
                if (end < position + word.length) {
                  end = position + word.length;
                }
                if (end > content.length) {
                  end = content.length;
                }
                slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
              }
              // sort slices in content by search text's count and hits' count
              slicesOfContent.sort(function (sliceLeft, sliceRight) {
                if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                  return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                  return sliceRight.hits.length - sliceLeft.hits.length;
                } else {
                  return sliceLeft.start - sliceRight.start;
                }
              });
              // select top N slices in content
              var upperBound = parseInt('1');
              if (upperBound >= 0) {
                slicesOfContent = slicesOfContent.slice(0, upperBound);
              }
              // highlight title and content
              function highlightKeyword(text, slice) {
                var result = '';
                var prevEnd = slice.start;
                slice.hits.forEach(function (hit) {
                  result += text.substring(prevEnd, hit.position);
                  var end = hit.position + hit.length;
                  result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                  prevEnd = end;
                });
                result += text.substring(prevEnd, slice.end);
                return result;
              }
              var resultItem = '';

              // if (slicesOfTitle.length != 0) {   resultItem += "<li><a target='_blank' href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>"; } else {   resultItem += "<li><a target='_blank' href='" +
              // articleUrl + "' class='search-result-title'>" + title + "</a>"; } slicesOfContent.forEach(function (slice) {   resultItem += "<a target='_blank' href='" + articleUrl + "'><p class=\"search-result\">" + highlightKeyword(content, slice) +
              // "...</p></a>"; }); resultItem += "</li>";

              if (slicesOfTitle.length != 0) {
                resultItem += "<a target='_blank' href='" + articleUrl + "' class='search-result'><div class='search-result-left'><div class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</div><time class='search-result-date'>" + dateTime + "</time>";
              } else {
                resultItem += "<a target='_blank' href='" + articleUrl + "' class='search-result'><div class='search-result-left'><div class='search-result-title'>" + title + "</div><time class='search-result-date'>" + dateTime + "</time>";
              }
              slicesOfContent.forEach(function (slice) {
                resultItem += "<p class=\"search-result-content\">" + highlightKeyword(content, slice) + "...</p>";
              });
              resultItem += "</div><div class='search-result-right'><img class='media-image' src='" + imgUrl + "' width='64px' height='48px'></img></div></a>";

              resultItems.push({item: resultItem, searchTextCount: searchTextCount, hitCount: hitCount, id: resultItems.length});
            }
          })
        };

        if (keywords.length === 1 && keywords[0] === "") {
          resultContent.innerHTML = '<div id="no-result"></div>'
        } else if (resultItems.length === 0) {
          resultContent.innerHTML = '<div id="no-result"></div>'
        } else {
          resultItems.sort(function (resultLeft, resultRight) {
            if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
              return resultRight.searchTextCount - resultLeft.searchTextCount;
            } else if (resultLeft.hitCount !== resultRight.hitCount) {
              return resultRight.hitCount - resultLeft.hitCount;
            } else {
              return resultRight.id - resultLeft.id;
            }
          });
          var searchResultList = '<div class=\"search-result-list\">';
          resultItems.forEach(function (result) {
            searchResultList += result.item;
          })
          searchResultList += "</div>";
          resultContent.innerHTML = searchResultList;
        }
      }
      if ('auto' === 'auto') {
        input.addEventListener('input', inputEventFunction);
      } else {
        $('.search-icon').click(inputEventFunction);
        input.addEventListener('keypress', function (event) {
          if (event.keyCode === 13) {
            inputEventFunction();
          }
        });
      }
      // remove loading animation
      $('body').css('overflow', '');
      proceedsearch();
    }
    // handle and trigger popup window;
    $('.popup-trigger').click(function (e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc('local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });
    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function (e) {
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 && $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });

    document.addEventListener('mouseup', (e) => {
      var _con = document.querySelector(".local-search-content");
      if (_con) {
        if (!_con.contains(e.target)) {
          onPopupClose();
        }
      }
    });
  </script>


		
	<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
