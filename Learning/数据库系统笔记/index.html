<!DOCTYPE html>
<html lang="en">

<!-- Head tag (contains Google-Analytics、Baidu-Tongji)-->
<head>
  <!-- Google Analytics -->
  
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-xxxxxx-xx"></script>
    <script type="text/javascript">
      window.dataLayer = window.dataLayer || [];

      function gtag() {
        dataLayer.push(arguments);
      }
      gtag('js', new Date());

      gtag('config', 'UA-xxxxxx-xx');
    </script>
  

  <!-- Baidu Tongji -->
  
    <script type="text/javascript">
      // Originial
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  <!-- Baidu Push -->
  
    <script>
      (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
      })();
    </script>
  

  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>

  <meta name="google-site-verification" content="lxDfCplOZbIzjhG34NuQBgu2gdyRlAtMB4utP5AgEBc"/>
  <meta name="baidu-site-verification" content="PpzM9WxOJU"/>

  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="description" content="这里是Hualingz，一个乐观主义者"/>
  <meta name="keyword" content="Hualingz,hualeez,hualingz,cyc"/>
  <link rel="shortcut icon" href="/img/avatar/fin_32.png"/>

  <!-- Place this tag in your head or just before your close body tag. -->
  <script async="async" defer="defer" src="https://buttons.github.io/buttons.js"></script>

  
    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css"/>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/beantech.min.css"/>

    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css"/>
    <link rel="stylesheet" href="/css/widget.css"/>
    <link rel="stylesheet" href="/css/rocket.css"/>
    <link rel="stylesheet" href="/css/signature.css"/>
    <link rel="stylesheet" href="/css/catalog.css"/>
    <link rel="stylesheet" href="/css/livemylife.css"/>

    
      <!-- wave start -->
      <link rel="stylesheet" href="/css/wave.css"/>
      <!-- wave end -->
    

    
      <!-- top start (article top hot config) -->
      <link rel="stylesheet" href="/css/top.css"/>
      <!-- top end -->
    

    
      <!-- ThemeColor start -->
      <link rel="stylesheet" href="/css/scroll.css"/>
      <!-- ThemeColor end -->
    

    
      <!-- viewer start (Picture preview) -->
      <link rel="stylesheet" href="/css/viewer.min.css"/>
      <!-- viewer end -->
    

    
      <!-- Search start -->
      <link rel="stylesheet" href="/css/search.css"/>
      <!-- Search end -->
    

    
      <!-- ThemeColor start -->
      <link rel="stylesheet" href="/css/themecolor.css"/>
      <!-- ThemeColor end -->
    

    

    
      <!-- gitalk start -->
      <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"> -->
      <link rel="stylesheet" href="/css/gitalk.css"/>
      <!-- gitalk end -->
    
  

  <!-- Custom Fonts -->
  <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
  <!-- Hux change font-awesome CDN to qiniu -->
  <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" type="text/css">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

  <!-- Hux Delete, sad but pending in China <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'> <link
  href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/ css'> -->

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]> <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script> <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script> <![endif]-->

  <!-- ga & ba script hoook -->
  <link rel="canonical" href="http://Hualingz.cn/Learning/数据库系统笔记/">
  <title>
    
      数据库系统笔记 - Hualingz_Channel
    
  </title>
<meta name="generator" content="Hexo 5.4.2"></head>


<!-- hack iOS CSS :active style -->

	<body ontouchstart="" class="body--light body--dark">


		<!-- ThemeColor -->
		
		<!-- ThemeColor -->
<style type="text/css">
  .body--light {
    --light-mode: none;
    --dark-mode: block;
  }
  .body--dark {
    --light-mode: block;
    --dark-mode: none;
  }
  i.mdui-icon.material-icons.light-mode {
    display: var(--light-mode);
  }
  i.mdui-icon.material-icons.dark-mode {
    display: var(--dark-mode);
  }
</style>
<div class="toggle" onclick="document.body.classList.toggle('body--dark')">
  <i class="mdui-icon material-icons light-mode"></i>
  <i class="mdui-icon material-icons dark-mode"></i>
</div>
<script>
  //getCookieValue
  function getCookieValue(a) {
    var b = document.cookie.match('(^|[^;]+)\\s*' + a + '\\s*=\\s*([^;]+)');
    return b
      ? b.pop()
      : '';
  }
  let themeMode = 'dark';
  if (getCookieValue('sb-color-mode') && (getCookieValue('sb-color-mode') !== themeMode)) {
    let dbody = document.body.classList;
    themeMode === 'dark' ? dbody.remove('body--dark') : dbody.add('body--dark');
  }

  //setCookieValue
  var toggleBtn = document.querySelector(".toggle");
  toggleBtn.addEventListener("click", function () {
    var e = document.body.classList.contains("body--dark");
    var cookieString = e
      ? "dark"
      : "light";
    var exp = new Date();
    exp.setTime(exp.getTime() + 3 * 24 * 60 * 60 * 1000); //3天过期
    document.cookie = "sb-color-mode=" + cookieString + ";expires=" + exp.toGMTString() + ";path=/";
  });
</script>

		

		<!-- Gitter -->
		
		<!-- Gitter -->
<!-- Docs:https://gitter.im/?utm_source=left-menu-logo -->
<script>
  ((window.gitter = {}).chat = {}).options = {
    room: 'your-community/your-room'
  };
</script>
<script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script>

		

		<!-- Navigation (contains search)-->
		<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header page-scroll">
      <button type="button" class="navbar-toggle">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">Hualingz_Channel</a>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <!-- Known Issue, found by Hux: <nav>'s height woule be hold on by its content. so, when navbar scale out, the <nav> will cover tags. also mask any touch event of tags, unfortunately. -->
    <div id="huxblog_navbar">
      <div class="navbar-collapse">
        <ul class="nav navbar-nav navbar-right">
          <li>
            <a href="/">首页</a>
          </li>

          
          
          
          
          <li>
            <a href="/about/">
              
              关于
              
              
            </a>
          </li>
          
          
          
          
          
          <li>
            <a href="/categories/">
              
              分类
              
              
            </a>
          </li>
          
          
          
          <li>
            <a href="/tags/">
              
              标签
              
              
            </a>
          </li>
          
          

          
          <li>
            <a class="popup-trigger">
              <span class="search-icon"></span>搜索</a>
          </li>
          

          <!-- LangSelect -->
          
          
          
          
          
        </ul>
      </div>
    </div>
    <!-- /.navbar-collapse -->
  </div>
  <!-- /.container -->
</nav>
<!-- progress -->
<div id="progress">
  <div class="line" style="width: 0%;"></div>
</div>

<script>
  // Drop Bootstarp low-performance Navbar Use customize navbar with high-quality material design animation in high-perf jank-free CSS3 implementation
  var $body = document.body;
  var $toggle = document.querySelector('.navbar-toggle');
  var $navbar = document.querySelector('#huxblog_navbar');
  var $collapse = document.querySelector('.navbar-collapse');

  $toggle.addEventListener('click', handleMagic)

  function handleMagic(e) {
    if ($navbar.className.indexOf('in') > 0) {
      // CLOSE
      $navbar.className = " ";
      // wait until animation end.
      setTimeout(function() {
        // prevent frequently toggle
        if ($navbar.className.indexOf('in') < 0) {
          $collapse.style.height = "0px"
        }
      }, 400)
    } else {
      // OPEN
      $collapse.style.height = "auto"
      $navbar.className += " in";
    }
  }
</script>


		<!-- Post Header (contains intro-header、signature、wordcount、busuanzi、waveoverlay) -->
		<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->

  <style type="text/css">
    .body--light {
      /* intro-header */
      --intro-header-background-image-url-home: url('/img/header_img/newhome_bg.jpg');
      --intro-header-background-image-url-post: url('');
      --intro-header-background-image-url-page: url('/img/header_img/archive_bg2.jpg');
    }
    .body--dark {
      --intro-header-background-image-url-home: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url('/img/header_img/newhome_bg.jpg');
      --intro-header-background-image-url-post: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url('');
      --intro-header-background-image-url-page: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url('/img/header_img/archive_bg2.jpg');
    }

    header.intro-header {
       /*post*/
        background-image: var(--intro-header-background-image-url-post);
        /* background-image: url(''); */
      
    }

    
      #signature {/*signature*/
        background-image: url('/img/signature/vincent-white.png');
      }
    
  </style>





<header class="intro-header">
  <!-- Signature -->
  <div id="signature">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
          
          <div class="post-heading">
            <div class="tags">
              
              <a class="tag" href="/tags/#数据库" title="数据库">数据库</a>
              
              <a class="tag" href="/tags/#浙江大学" title="浙江大学">浙江大学</a>
              
            </div>
            <h1>数据库系统笔记</h1>
            <h2 class="subheading">Hualingz</h2>
            <span class="meta">
              Posted by Hualingz on
              2022-06-25
            </span>


            
            <!-- WordCount start -->
            <div class="blank_box"></div>
            <span class="meta">
              Estimated Reading Time <span class="post-count">59</span> Minutes
            </span>
            <div class="blank_box"></div>
            <span class="meta">
              Words <span class="post-count">15.4k</span> In Total
            </span>
            <div class="blank_box"></div>
            <!-- WordCount end -->
            
            
            <!-- 不蒜子统计 start -->
            <span class="meta" id="busuanzi_container_page_pv">
              Viewed <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span> Times
            </span>
            <!-- 不蒜子统计 end -->
            


          </div>
          
        </div>
      </div>
    </div>
  </div>

  
  <!-- waveoverlay start -->
  <div class="preview-overlay">
    <svg class="preview-waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
      <defs>
        <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path>
      </defs>
      <g class="preview-parallax">
        <use xlink:href="#gentle-wave" x="48" y="0" fill=var(--gentle-wave1)></use>
        <use xlink:href="#gentle-wave" x="48" y="3" fill=var(--gentle-wave2)></use>
        <use xlink:href="#gentle-wave" x="48" y="5" fill=var(--gentle-wave3)></use>
        <use xlink:href="#gentle-wave" x="48" y="7" fill=var(--gentle-wave)></use>
      </g>
    </svg>
  </div>
  <!-- waveoverlay end -->
  

</header>



		<!-- Main Content (Post contains
	Pager、
	tip、
	socialshare、
	gitalk、gitment、disqus-comment、
	Catalog、
	Sidebar、
	Featured-Tags、
	Friends Blog、
	anchorjs、
	) -->
		<!-- Modify by Yu-Hsuan Yen -->
<!-- Post Content -->
<article>
  <div class="container">
    <div class="row">
      <!-- Post Container -->
      <div class="col-lg-8 col-lg-offset-1 col-md-10 col-md-offset-1 post-container">

        <h2 id="1-Entity-Sets"><a href="#1-Entity-Sets" class="headerlink" title="1. Entity Sets"></a>1. Entity Sets</h2><h4 id="1-1-Entity-Sets实体集的定义"><a href="#1-1-Entity-Sets实体集的定义" class="headerlink" title="1.1 Entity Sets实体集的定义"></a>1.1 Entity Sets实体集的定义</h4><ul>
<li>世界能被模型化为：许多实体Entities和实体间的联系Relationships</li>
<li>实体是存在可分别的对象，可抽象可具体</li>
<li>实体具有属性Attributes</li>
<li>实体集Entity set是一系列相同类型的实体，有着共同的属性</li>
</ul>
<h4 id="1-2-Attributes属性"><a href="#1-2-Attributes属性" class="headerlink" title="1.2 Attributes属性"></a>1.2 Attributes属性</h4><ul>
<li>一个实体有一系列的属性</li>
<li>域Domain(Value set)是属性的取值集合</li>
<li>属性的种类：<ol>
<li>简单属性：sex</li>
<li>复合属性：name（由first name和last name组成）</li>
<li>单值属性：birthday</li>
<li>多值属性：phone（可能有多个电话）</li>
<li>派生属性Derived attributes：能从其他属性中计算出来，如age可以从birthday中计算，有基属性或者储存属性</li>
</ol>
</li>
</ul>
<h2 id="2-Relationship-Sets"><a href="#2-Relationship-Sets" class="headerlink" title="2.  Relationship Sets"></a>2.  Relationship Sets</h2><ul>
<li><p>一个关系可以是多个不同类实体之间的关系，也可以是自关系</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">borrower(Jones,L<span class="number">-17</span>)</span><br><span class="line">relationship(customer<span class="operator">-</span>entity,loan<span class="operator">-</span>entity)</span><br><span class="line">manager(<span class="number">001</span>,<span class="number">002</span>)</span><br><span class="line">relationship(workerid,workerid)</span><br></pre></td></tr></table></figure>
</li>
<li><p>联系集是多个同类联系的集合</p>
</li>
<li><p>对于许许多多的特定的两个实体组有关系R1、R2、R3…这些关系有相同的类型,那么R就是关系集</p>
</li>
</ul>
<h4 id="2-1-关系的表示"><a href="#2-1-关系的表示" class="headerlink" title="2.1 关系的表示"></a>2.1 关系的表示</h4><h5 id="2-1-1-集合的表示"><a href="#2-1-1-集合的表示" class="headerlink" title="2.1.1 集合的表示"></a>2.1.1 集合的表示</h5><p>${ (e_1,e_2,…,e_n)|e_i∈E_i,i&#x3D;1,…,n}$</p>
<p>这里，$(e_1,e_2,…,e_n)$是一个关系，$E_i$是实体集</p>
<h5 id="2-1-2-table中的表示"><a href="#2-1-2-table中的表示" class="headerlink" title="2.1.2 table中的表示"></a>2.1.2 table中的表示</h5><p>对于二元关系一般用两个实体集的主码来表示，当然可以添加一些其他的属性，这是<strong>关系的属性</strong></p>
<ul>
<li><p>Example</p>
<p>Student的主码为Sid</p>
<p>Course的主码为Cid</p>
<p>那么参与课程的学生的期末成绩</p>
<p>$Marks(Sid,Cid,grade)$</p>
</li>
</ul>
<h4 id="2-2-Degree关系集的度"><a href="#2-2-Degree关系集的度" class="headerlink" title="2.2 Degree关系集的度"></a>2.2 Degree关系集的度</h4><ul>
<li><p>定义: 引用的实体集的个数(如二元集度数为2)</p>
</li>
<li><p>关系集可能不止两个实体集,但是比较稀少,并且多元关系可以转化为多个二元关系</p>
</li>
</ul>
<h4 id="2-3-Mapping-Cardinalities映射基数"><a href="#2-3-Mapping-Cardinalities映射基数" class="headerlink" title="2.3 Mapping Cardinalities映射基数"></a>2.3 Mapping Cardinalities映射基数</h4><ul>
<li><p>定义: 在一个联系集中,一个实体可以与另一类实体相联系的实体数目,数目指的是最多一个还是可以多个</p>
</li>
<li><p>种类:</p>
<p> 1-1 , 1-n , n-1 , n-m</p>
</li>
</ul>
<h2 id="3-Keys"><a href="#3-Keys" class="headerlink" title="3. Keys"></a>3. Keys</h2><h4 id="3-1-实体集的keys"><a href="#3-1-实体集的keys" class="headerlink" title="3.1 实体集的keys"></a>3.1 实体集的keys</h4><ul>
<li>super key: 能够唯一决定实体的单个或者多个属性</li>
<li>candidate key: 候选码是最小的super key</li>
<li>可能存在很多的候选码,我们在选择主码的时候要谨慎(</li>
</ul>
<h4 id="3-2-关系集的keys"><a href="#3-2-关系集的keys" class="headerlink" title="3.2 关系集的keys"></a>3.2 关系集的keys</h4><ul>
<li>参与关系集的各实体集的主码的组合构成一个关系集的<strong>超码</strong></li>
<li>作为主码的属性不可为空</li>
</ul>
<h2 id="4-E-R-Diagrams"><a href="#4-E-R-Diagrams" class="headerlink" title="4. E-R Diagrams"></a>4. E-R Diagrams</h2><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220419084522586.png">

<h4 id="4-2-不同类型的属性表达"><a href="#4-2-不同类型的属性表达" class="headerlink" title="4.2 不同类型的属性表达"></a>4.2 不同类型的属性表达</h4><p><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220419084604968.png">&gt;</p>
<h4 id="4-3-关系集的属性的表达"><a href="#4-3-关系集的属性的表达" class="headerlink" title="4.3 关系集的属性的表达"></a>4.3 关系集的属性的表达</h4><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220419084648499.png">

<h4 id="4-4-自关系和Role的表达"><a href="#4-4-自关系和Role的表达" class="headerlink" title="4.4 自关系和Role的表达"></a>4.4 自关系和Role的表达</h4><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220419084726281.png">

<h4 id="4-5-映射基数的表达"><a href="#4-5-映射基数的表达" class="headerlink" title="4.5 映射基数的表达"></a>4.5 映射基数的表达</h4><p>箭头(→)指的是one</p>
<p>直接的线(—)指的是many</p>
<p>从而在二元关系上表达映射基数种类</p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220419085003299.png">

<h4 id="4-6-全参与与部分参与"><a href="#4-6-全参与与部分参与" class="headerlink" title="4.6 全参与与部分参与"></a>4.6 全参与与部分参与</h4><ul>
<li>Total Participation: 实体集中所有的实体都参与了这个关系</li>
<li>全参与我们使用双横线表示</li>
<li>Partial Participation: 实体集中部分的实体参与了这个关系</li>
<li>部分参与直接用直线</li>
<li><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220419085246064.png"></li>
</ul>
<h4 id="4-7-关系约束的替代信号"><a href="#4-7-关系约束的替代信号" class="headerlink" title="4.7 关系约束的替代信号"></a>4.7 关系约束的替代信号</h4><p>如果不想用复杂的箭头和双横线,可以在实体集和关系集之间的横线上可以使用$x..y$的信号,表示最少x个,最多y个参与关系</p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220419090459225.png">

<h4 id="4-8-多元关系"><a href="#4-8-多元关系" class="headerlink" title="4.8 多元关系"></a>4.8 多元关系</h4><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220419090540938.png">

<p>多元关系可以转化为多个二元关系</p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220419090659296.png">

<h2 id="5-Weak-Entity-Sets"><a href="#5-Weak-Entity-Sets" class="headerlink" title="5. Weak Entity Sets"></a>5. Weak Entity Sets</h2><ul>
<li>定义: 一个实体集没有主码即为弱实体集,使用<strong>双框矩形</strong>表示</li>
<li>弱实体集单独存在不具有实际意义,它必须依赖于一个确定的实体集,要与一个确定实体集建立关系,<strong>这里的关系我们使用双框菱形</strong></li>
<li>discriminator鉴别符是在弱实体内部鉴别使用的,使用<strong>虚线下划线</strong>表示</li>
<li>弱实体的主码是由<strong>强实体集的主码</strong>+<strong>弱实体的鉴别符</strong>组成的</li>
<li><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220419091234036.png"></li>
<li>注意:强实体集的主键没有显式地与弱实体集存储在一起，因为它在标识关系中是隐式的。如果显式地存储了course_id，则可以将section作为一个强实体，但是section和course之间的关系将被一个由course和section共同的属性course id定义的隐式关系复制</li>
</ul>
<p><strong><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220419091432702.png"></strong></p>
<h2 id="6-Extended-E-R-Features"><a href="#6-Extended-E-R-Features" class="headerlink" title="6. Extended E-R Features"></a>6. Extended E-R Features</h2><h4 id="6-1-Specialization-特殊化、具体化"><a href="#6-1-Specialization-特殊化、具体化" class="headerlink" title="6.1 Specialization(特殊化、具体化)"></a>6.1 Specialization(特殊化、具体化)</h4><ul>
<li>一种top-down的设计过程</li>
<li>设计的实体集可以从上层的实体集继承派生而来</li>
<li><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220419092203816.png"></li>
</ul>
<h4 id="6-2-Generalization-泛化、普遍化"><a href="#6-2-Generalization-泛化、普遍化" class="headerlink" title="6.2 Generalization(泛化、普遍化)"></a>6.2 Generalization(泛化、普遍化)</h4><ul>
<li>一种bottom-up的设计过程</li>
<li>把下层具有相同属性的实体集生成新的父类</li>
</ul>
<h4 id="6-3-Specialization和Generalization的设计方式"><a href="#6-3-Specialization和Generalization的设计方式" class="headerlink" title="6.3 Specialization和Generalization的设计方式"></a>6.3 Specialization和Generalization的设计方式</h4><p>用**倒三角(加上ISA)**表示继承,子类可以在父类的基础上额外增加属性</p>
<p>在倒三角下方<strong>加上Disj</strong>表示不相交,即一个父类如果成为了子类要么是子类A要么是子类B,不可能同时为A和B</p>
<p>倒三角上方使用<strong>双线</strong>表示父类全参与,所有的父类都要成为子类</p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220419092706130.png">

<h4 id="6-4-Aggregation聚合"><a href="#6-4-Aggregation聚合" class="headerlink" title="6.4 Aggregation聚合"></a>6.4 Aggregation聚合</h4><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220419092902192.png">

<p>在这个ER图中,manager管理着works-on的所有实体集,我们可以把上方的所有集合看成一个复合实体集,更加方便地表示,即为聚合</p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220419093042027.png">

<h4 id="6-5-ER图的整理"><a href="#6-5-ER图的整理" class="headerlink" title="6.5 ER图的整理"></a>6.5 ER图的整理</h4><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220419093115094.png">



<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220419093121072.png">

<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220419093132362.png">

<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220419093139242.png">

<h2 id="7-Design-of-an-E-R-Database-Schema"><a href="#7-Design-of-an-E-R-Database-Schema" class="headerlink" title="7. Design of an E-R Database Schema"></a>7. Design of an E-R Database Schema</h2><p>设计Database的步骤:</p>
<ol>
<li>需求分析</li>
<li>概念模型设计(ER图)</li>
<li>逻辑模型设计(关系模式表结构)</li>
<li>物理模型设计(储存模式)</li>
</ol>
<p>要考虑的事情:</p>
<ol>
<li>用属性<strong>attribute</strong>还是实体集<strong>entity set</strong>表示一个对象?如多值属性怎么表示?</li>
<li>将其当作<strong>entity set</strong>还是<strong>relationship set</strong>?relationship set是两个entity set之间动作的表示</li>
<li>将其当作<strong>attribute of an entity</strong>还是<strong>relationship</strong>? 不要在一个实体集中添加太多的无关属性,可以用新的实体集加关系来表示,<strong>减少冗余</strong></li>
<li>用n元关系还是一些二元关系?</li>
<li>用强实体还是弱实体?</li>
<li>是否需要用继承、派生、泛化?有助于模块化</li>
<li>是否需要聚合?</li>
</ol>
<h2 id="8-Reduction-of-an-E-R-Schema-to-Tables"><a href="#8-Reduction-of-an-E-R-Schema-to-Tables" class="headerlink" title="8. Reduction of an E-R Schema to Tables"></a>8. Reduction of an E-R Schema to Tables</h2><ul>
<li>一个数据库可以从ER图中获得一系列的table</li>
<li>每一个实体集和关系集都有表对应</li>
</ul>
<h4 id="8-1-表示方法"><a href="#8-1-表示方法" class="headerlink" title="8.1 表示方法"></a>8.1 表示方法</h4><ol>
<li><p>强实体集: 变成有相同属性的表</p>
</li>
<li><p>复合属性: 拆开成为单个有原子性的属性</p>
</li>
<li><p>多值属性: 将多值属性拆成表,如</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">employee(emp<span class="operator">-</span>id,ename,sex,age,dep<span class="operator">-</span>names)</span><br><span class="line"></span><br><span class="line">employee(emp<span class="operator">-</span>id,ename,sex,age)</span><br><span class="line">employee<span class="operator">-</span>dept(emp<span class="operator">-</span>id,dept<span class="operator">-</span>name)</span><br></pre></td></tr></table></figure>
</li>
<li><p>弱实体集: 加入关联强实体的主码,成为表</p>
</li>
<li><p>关系: 关系的实体集的主码,(成为表的外码)和关系自带的属性写成一个表</p>
</li>
</ol>
<h4 id="8-2-表的冗余的处理"><a href="#8-2-表的冗余的处理" class="headerlink" title="8.2 表的冗余的处理"></a>8.2 表的冗余的处理</h4><ul>
<li><p>在一对多的关系中,可以将联系表合并如多端的实体中<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220419111802771.png"></p>
</li>
<li><p>一对多的合并,有些部分参与的实体集合的关系并为table要合并到many的一端,并且要设置为可以为NULL Values</p>
</li>
<li><p>一对一的关系集可以任选一边作为”many”</p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220419113457353.png">
</li>
<li><p>在强弱实体集的关系中,这个关系identifying relationship其实是多余的,因为弱实体的表已经包含了强实体的主码</p>
</li>
</ul>
<h4 id="8-3-Specialization的表示"><a href="#8-3-Specialization的表示" class="headerlink" title="8.3 Specialization的表示"></a>8.3 Specialization的表示</h4><ol>
<li><p>建立父表,在子表中包括父表的主码</p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220419114254858.png">
</li>
<li><p>建立父表<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220419114358726.png"></p>
</li>
</ol>
<h2 id="9-Relational-Database-Design"><a href="#9-Relational-Database-Design" class="headerlink" title="9: Relational Database Design"></a>9: Relational Database Design</h2><h3 id="1-First-Normal-Form"><a href="#1-First-Normal-Form" class="headerlink" title="1. First Normal Form"></a>1. First Normal Form</h3><p>第一范式: <strong>Domain is atomic: 域是原子的,不可再分</strong></p>
<p>有非原子的域要拆分为有原子性的如:</p>
<ul>
<li>Composite attributes — set of names </li>
<li>Multi-value attribute — a person’s phones </li>
<li>Complex data type— object-oriented</li>
</ul>
<h3 id="2-Pitfalls-in-Relational-Database-Design"><a href="#2-Pitfalls-in-Relational-Database-Design" class="headerlink" title="2. Pitfalls in Relational Database Design"></a>2. Pitfalls in Relational Database Design</h3><h4 id="2-1-错误的设计"><a href="#2-1-错误的设计" class="headerlink" title="2.1 错误的设计"></a>2.1 错误的设计</h4><p>错误的设计导致的问题：</p>
<ol>
<li>内存冗余</li>
<li>删除、插入、更新操作出错</li>
</ol>
<p>一个常见的错误设计：把无用的属性加入实体集中，导致实体集冗长，应该要采用top-down或者button-up的设计方式，因此我们需要分解！</p>
<h4 id="2-2-分解"><a href="#2-2-分解" class="headerlink" title="2.2 分解"></a>2.2 分解</h4><p>分解是把一个冗长的关系、实体分解为小的关系、实体。</p>
<p>如把原始的模式R分解为($R_1,R_2$)，那么R的所有属性要出现在$R_1∪R_2$中，且分解要保证是<strong>无损分解</strong>，即</p>
<p>$r&#x3D;\prod_{R_1}(r)\Join \prod_{R_2}(r)$</p>
<ul>
<li><p>Example:</p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220419135446013.png"></li>
</ul>
<h3 id="3-Functional-Dependencies"><a href="#3-Functional-Dependencies" class="headerlink" title="3. Functional Dependencies"></a>3. Functional Dependencies</h3><p>函数依赖性定义：若$t_1[\alpha]&#x3D;t_2[\alpha]$则一定有$t_1[\beta]&#x3D;t_2[\beta]$</p>
<p>那么我们称β依赖于α，α决定β，即<strong>α的值唯一确定时，β的值也唯一确定</strong></p>
<p>记作<strong>α→β</strong></p>
<h4 id="3-1-函数依赖性和key的关系"><a href="#3-1-函数依赖性和key的关系" class="headerlink" title="3.1 函数依赖性和key的关系"></a>3.1 函数依赖性和key的关系</h4><ul>
<li>函数依赖性是key的一种泛化</li>
<li>K是superkey，等价于K→R</li>
<li>K是candidate key，等价于K→R且不存在α是K的真子集，且α→R</li>
<li>我们可以写出函数依赖集从而找出最小的闭包从而确定key</li>
</ul>
<p>函数依赖集：F&#x3D;{a→b，c→d，a→e，…}</p>
<ul>
<li>Example：</li>
<li><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220419140313750.png"></li>
</ul>
<h4 id="3-2-函数依赖性的应用"><a href="#3-2-函数依赖性的应用" class="headerlink" title="3.2 函数依赖性的应用"></a>3.2 函数依赖性的应用</h4><ul>
<li><p>Example：</p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220419140441563.png">
</li>
<li><p>我们容易判断一个r是否满足给定的F，但是不易判断F在R是是否成立，我们使用<strong>函数依赖集来判断</strong></p>
</li>
</ul>
<h5 id="3-2-1-平凡和非平凡的依赖性的定义"><a href="#3-2-1-平凡和非平凡的依赖性的定义" class="headerlink" title="3.2.1 平凡和非平凡的依赖性的定义"></a>3.2.1 平凡和非平凡的依赖性的定义</h5><p>平凡的（trivial）：α→β，if β$\subseteq$α</p>
<p>非平凡的（Non-trivial）：α→×β，if β$\subseteq $α</p>
<p>我们一般关注非平凡的函数依赖，平凡的函数依赖一般来说比较弱</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(customer<span class="operator">-</span>name,loan<span class="operator">-</span>number)→customer<span class="operator">-</span>name</span><br></pre></td></tr></table></figure>

<h5 id="3-2-2-函数依赖性的闭包"><a href="#3-2-2-函数依赖性的闭包" class="headerlink" title="3.2.2 函数依赖性的闭包"></a>3.2.2 函数依赖性的闭包</h5><p>定义：给定一组函数依赖性F，还有一些其他的函数依赖性在逻辑上由F隐含，所有的函数依赖性合起来就是函数依赖集F的闭包记作$F^+$。</p>
<ul>
<li><p>Example：</p>
<p>$F&#x3D;{A→B，B→C}$</p>
<p>$F^+&#x3D;{A→B，B→C，A→C，A→A，AB→B，AC→C…}$</p>
</li>
</ul>
<h5 id="3-2-3-如何找闭包？"><a href="#3-2-3-如何找闭包？" class="headerlink" title="3.2.3 如何找闭包？"></a>3.2.3 如何找闭包？</h5><p>使用Armstrong’s Axioms：</p>
<ol>
<li><strong>自反律：</strong>若$\beta\subseteq \alpha$则$\alpha→\beta$</li>
<li><strong>增补律：</strong>若$\alpha→\beta$则$\gamma\alpha→\gamma\beta$（且$\gamma\alpha→\beta$）</li>
<li><strong>传递率：</strong>若$\alpha→\beta且\beta→\gamma$则$\alpha→\gamma$</li>
<li><em><em>$合并律^</em>$：</em>*若$\alpha→\beta且\alpha→\gamma$则$\alpha→\beta\gamma$</li>
<li><em><em>分解律$^</em>$：</em>*若$\alpha→\beta\gamma$则若$\alpha→\beta且\alpha→\gamma$</li>
<li><em><em>伪传递律$^</em>$：</em>*若$\alpha→\beta且\gamma\beta→\delta$则$\alpha\gamma→\delta$</li>
</ol>
<p>使用定律可以从已有的依赖中求出其他依赖关系</p>
<h5 id="3-2-4-如何判断a是不是一个superkey？"><a href="#3-2-4-如何判断a是不是一个superkey？" class="headerlink" title="3.2.4 如何判断a是不是一个superkey？"></a>3.2.4 如何判断a是不是一个superkey？</h5><p><strong>使用属性闭包！</strong></p>
<p>Method 1：找到闭包依赖函数集$F^+$，若a→$\beta_i$对所有的$\beta_i$属于$F^+$成立则a是一个superkey</p>
<p>Method 2：找a的闭包$a^+$</p>
<ul>
<li><p>a的闭包：</p>
<p>F下所有被a直接或者间接<strong>决定的</strong>的属性的集合为a的闭包记作$a^+$</p>
<p>如果$a^+$决定了R，即a→R is in $F^+$，则a是superkey</p>
</li>
</ul>
<h5 id="3-2-5-画图找闭包的方法"><a href="#3-2-5-画图找闭包的方法" class="headerlink" title="3.2.5 画图找闭包的方法"></a>3.2.5 画图找闭包的方法</h5><p>决定和依赖关系使用箭头表示，如图</p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220419202812152.png">

<p>则，没有箭头指向的一定是候选码（AG）再验证AG的闭包是否为全集即可</p>
<h4 id="3-3-属性闭包的总结"><a href="#3-3-属性闭包的总结" class="headerlink" title="3.3 属性闭包的总结"></a>3.3 属性闭包的总结</h4><ol>
<li><p>测试superkey</p>
<p>检查$R\subseteq \alpha^+$</p>
</li>
<li><p>测试函数依赖性</p>
<p>检测α→β是否成立只需测试$\beta\subseteq \alpha^+$</p>
</li>
<li><p>计算F的闭包</p>
<p>每一个$\gamma \in R$,我们可以找到闭包$\gamma^+$,这个闭包是属于$F^+$的</p>
</li>
</ol>
<h4 id="3-4-Canonical-Cover正则覆盖"><a href="#3-4-Canonical-Cover正则覆盖" class="headerlink" title="3.4 Canonical Cover正则覆盖"></a>3.4 Canonical Cover正则覆盖</h4><p>我们要简化依赖函数集合F，使得F不仅和$F^+$等价而且要规模最小</p>
<p>我们把这个正则覆盖记作$F_c$，它是一个最小的FDs（Functional Dependency），等价于F</p>
<p>特点：</p>
<ol>
<li>没有冗余的FDs</li>
<li>FDs中没有冗余的部分，即FDs中不要有无用的属性如A→BC，B→C，直接写A→B，B→C即可</li>
<li>每一个左边的值是唯一的unique</li>
</ol>
<p>如何获得$F_c$：</p>
<ol>
<li>合并率，将左侧相同的依赖函数合并为一个，如${A→B，A→E，…}$合并为${A→BE,…}$</li>
<li>在合并完的函数依赖集中寻找一个无关属性，删除它</li>
</ol>
<ul>
<li><p>何为无关属性及其判断：</p>
<ol>
<li><p>右侧判断</p>
<p>如F&#x3D;{A→BC，B→AC，C→AB}<br>关注B属性。它在依赖右侧。删除该属性，余下F’&#x3D;{A→C，B→AC，C→AB},计算左侧剩余属性集（A）的闭包$A^+$。因为A→C，C→AB，所以$A^+$中包含删去的属性B。故B是无关属性</p>
</li>
<li><p>左侧判断</p>
<p>若要判断的属性位于依赖的左侧，例如{undefinedAB→C}，则删除该属性，在原本的依赖集F中计算该依赖左部集合的闭包α+。若α+闭包中包含该依赖右侧所有的属性，则该属性则是无关属性，如函数依赖集F&#x3D;{Z→X，X→P，XY→WP，XYP→ZW}<br> 关注到XYP中的P属性。它在左侧。删除它，求解左侧剩下属性集XY的闭包，求取域是原来的F{Z→X，X→P，XY→WP，XYP→ZW}。因为XY→WP，所以（XY）+  &#x3D; XYWP；又因为XYP→ZW，所以（XY）+ &#x3D; XYWPZ，包含依赖右侧ZW。故P是无关属性</p>
</li>
</ol>
</li>
</ul>
<h3 id="4-Decomposition"><a href="#4-Decomposition" class="headerlink" title="4. Decomposition"></a>4. Decomposition</h3><h4 id="4-1-分解的要点"><a href="#4-1-分解的要点" class="headerlink" title="4.1 分解的要点"></a>4.1 分解的要点</h4><ol>
<li>分解要是无损分解</li>
<li>依赖保持</li>
<li>每一个子关系是good form（BCNF或者3NF）</li>
</ol>
<h5 id="4-1-1-无损分解的要点"><a href="#4-1-1-无损分解的要点" class="headerlink" title="4.1.1 无损分解的要点"></a>4.1.1 无损分解的要点</h5><ol>
<li>分解后的两个子模式的共同属性必须是R1或者R2的<strong>码</strong></li>
<li>一定是要码！！！</li>
<li>即${R_1∩R_2}→R_1orR_2$</li>
</ol>
<h5 id="4-1-2-依赖保持"><a href="#4-1-2-依赖保持" class="headerlink" title="4.1.2 依赖保持"></a>4.1.2 依赖保持</h5><p>R的依赖关系F，$R_1$的依赖关系有$F_1$，$R_2$的依赖关系是$F_2$，这里的F1和F2一定是在F的闭包$F^*$之中的，我们所说的依赖保持指的是</p>
<p>$(F_1∪F_2)^*&#x3D;F^*$</p>
<p>多元的分解也是如此：</p>
<p>$R_i$的依赖$F_i\subseteq F$，</p>
<p>$(F_1∪F_2∪..F_n)^*&#x3D;F^*$</p>
<h3 id="5-Boyce-Codd-Normal-Form"><a href="#5-Boyce-Codd-Normal-Form" class="headerlink" title="5. Boyce-Codd Normal Form"></a>5. Boyce-Codd Normal Form</h3><p>BC范式定义：</p>
<ul>
<li>每一个表中<strong>所有的函数依赖α→β</strong>，至少满足一条<ol>
<li>α→β是平凡的</li>
<li>α是R的superkey</li>
</ol>
</li>
</ul>
<p><strong>一个表中只剩下两个属性，那么一定满足BC范式</strong></p>
<p>不满足BC范式的模式可以分解为BC范式的形式</p>
<ul>
<li>Example：</li>
<li><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220419143123504.png"></li>
</ul>
<h4 id="5-1-表的BCNF的验证"><a href="#5-1-表的BCNF的验证" class="headerlink" title="5.1 表的BCNF的验证"></a>5.1 表的BCNF的验证</h4><p>不能仅仅使用依赖函数F来验证！</p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220419143446770.png">

<p>例子中，码是（A,D），而A→B，B→C，AB均不是码，因此不满足BCNF，因此我们需要分解为BDNF。</p>
<p>$F^*&#x3D;{A→B，B→C，A→C}$</p>
<p>$R_1:F_1&#x3D;{A→B}$</p>
<p>$R_2:F_2&#x3D;A→C$</p>
<p>这样子R2仍不是BCNF，因为A→C这个依赖关系被继承下来了</p>
<h4 id="5-2-如何分解为BC范式"><a href="#5-2-如何分解为BC范式" class="headerlink" title="5.2 如何分解为BC范式"></a>5.2 如何分解为BC范式</h4><p>为什么不是BC范式：因为有A→B，而A不是key也不是B的子集</p>
<p>我们怎么做：通过分解让A成为key</p>
<ul>
<li>Example</li>
<li><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220419144131526.png"></li>
</ul>
<p>首先看一下原来的表是不是BCNF：</p>
<p>候选码：{loan-number，customer-name}</p>
<p>注意到branch-name →{branch-city，assets}中branch-name不是key</p>
<p>$R_1&#x3D;(branch-name,branch-city,assets)&#x3D;(\alpha,\beta)$       </p>
<p>$R_2&#x3D;(branch-name,customer-name,loan-number,amount)&#x3D;R-\beta$</p>
<p>但是此时的R2还不是BCNF，因为</p>
<p>loan-number→{amount，branch-name}中loan-number不是key</p>
<p>继续分解直到满足BCNF</p>
<h4 id="5-2-为什么有时不用BCNF？"><a href="#5-2-为什么有时不用BCNF？" class="headerlink" title="5.2 为什么有时不用BCNF？"></a>5.2 为什么有时不用BCNF？</h4><ul>
<li><p>因为在保持依赖性和减少冗余之间有冲突</p>
</li>
<li><p>Example：丧失函数依赖性的例子</p>
</li>
<li><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220419145334413.png"></li>
</ul>
<h3 id="6-Third-Normal-Form"><a href="#6-Third-Normal-Form" class="headerlink" title="6. Third Normal Form"></a>6. Third Normal Form</h3><p>定义：对所有的依赖函数集闭包中的依赖关系α→β，至少满足</p>
<ol>
<li>α→β是平凡的</li>
<li>α是key</li>
<li>对每一个属性A∈β-α，A是R的某个候选码的一部分(又称A为主属性)</li>
</ol>
<h4 id="6-1-如何构建第三范式"><a href="#6-1-如何构建第三范式" class="headerlink" title="6.1 如何构建第三范式"></a>6.1 如何构建第三范式</h4><p>把正则覆盖$F_c$中的所有α→β分解为子模式$R_i&#x3D;(\alpha,\beta)$</p>
<p>参见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/sumaliqinghua/article/details/86246762">https://blog.csdn.net/sumaliqinghua/article/details/86246762</a></p>
<h3 id="7-Multivalued-Dependencies"><a href="#7-Multivalued-Dependencies" class="headerlink" title="7. Multivalued Dependencies"></a>7. Multivalued Dependencies</h3><p>目前我们要求最高的范式是BC范式，但是有时BCNF并不是冗余最小的</p>
<p>有时表无法找到依赖关系，且key是全部的属性的组合，这么做仍然是满足BCNF的，但是仍有很多的冗余。</p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220419152400043.png">

<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220419152412757.png">

<p>可以看到这张表是满足BCNF的，但是能明显看出有很多的冗余。这是因为之前所说的依赖关系是建立在一对一的基础上的，一对多没有定义一种依赖关系。</p>
<h4 id="7-1-多值依赖关系MVDs"><a href="#7-1-多值依赖关系MVDs" class="headerlink" title="7.1 多值依赖关系MVDs"></a>7.1 多值依赖关系MVDs</h4><p>定义：存在$t_1[\alpha]&#x3D;t_2[\alpha]$，则存在$t_2[\alpha]&#x3D;t_4[\alpha]$，且</p>
<p>$t_3[\beta]&#x3D;t_1[\beta]$</p>
<p>$t_4[\beta]&#x3D;t_2[\beta]$</p>
<p>$t_3[R-\alpha-\beta]&#x3D;t_2[R-\alpha-\beta]$</p>
<p>$t_4[R-\alpha-\beta]&#x3D;t_1[R-\alpha-\beta]$</p>
<p>那么β多值依赖于α，α多值决定β，记作α→→β</p>
<ul>
<li>如果α→β则α→→β</li>
<li><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220419153806209.png"></li>
</ul>
<h3 id="8-Fourth-Normal-Form"><a href="#8-Fourth-Normal-Form" class="headerlink" title="8. Fourth Normal Form"></a>8. Fourth Normal Form</h3><p>定义：对于多值依赖函数集合的闭包$D^+$中的所有α→→β，一定满足其一：</p>
<ol>
<li>α→→β是平凡的</li>
<li>α是一个R的superkey</li>
</ol>
<p>注意：</p>
<p>如果满足4NF则一定满足BCNF</p>
<h2 id="10-Storage-and-File-Structure"><a href="#10-Storage-and-File-Structure" class="headerlink" title="10: Storage and File Structure"></a>10: Storage and File Structure</h2><p>数据库的设计的要求：</p>
<ul>
<li>Data Storage</li>
<li>Application Program Interface (SQL)</li>
<li>Query&#x2F;Insert&#x2F;Delete&#x2F;Update</li>
<li>High Performance (Index, buffer manager, query processing&#x2F; Optimization)</li>
<li>Concurrent Control并发控制</li>
<li>Reliability<strong>可靠性</strong>非常重要</li>
<li>Security安全性</li>
</ul>
<p>Mini SQL Architecture：</p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220426130927090.png">

<h3 id="1-Overview-of-Physical-Storage-Media"><a href="#1-Overview-of-Physical-Storage-Media" class="headerlink" title="1. Overview of Physical Storage Media"></a>1. Overview of Physical Storage Media</h3><h4 id="1-1-分类"><a href="#1-1-分类" class="headerlink" title="1.1 分类"></a>1.1 分类</h4><ul>
<li><p>数据库的物理层面</p>
<p>Files、storage（.mdf，.ldf，.ora，.dbf）</p>
</li>
<li><p>储存媒体分类</p>
<ul>
<li>数据库访问数据的<strong>速度</strong>speed</li>
<li>单位数据的<strong>花销cost</strong></li>
<li><strong>可靠程度Reliability</strong>: <ul>
<li>Data Loss on power failure or system crash</li>
<li>Physical Failure of storage device（RAID）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1-2-Storage-Hierarchy储存层次"><a href="#1-2-Storage-Hierarchy储存层次" class="headerlink" title="1.2 Storage Hierarchy储存层次"></a>1.2 Storage Hierarchy储存层次</h4><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220426134102591.png">

<p>顶层读写块，但是花费大；底层读写速度慢，但是花费小</p>
<ul>
<li>主存储（Primary Storage）：最快的存储结构（cache、main memory），一般情况下关机重启后其中的数据就会没掉（<strong>易失性</strong>）</li>
<li>辅助存储器&#x2F;联机储存器On-line（Secondary Storage）：二级存储器（flash memory、magnetic disk磁盘），一般是与电脑主机联机的，CPU无法直接修改，关机重启后与数据都还在。</li>
<li>三级存储器&#x2F;脱机存储器Off-line（Tertiary Storage）：最底层的存储模块（optical disk、magnetic tapes），如磁带、光盘，比较便宜，并且一般可以脱离主机，需要使用时连接主机即可。</li>
</ul>
<p>速度从快到慢：Cache ，Main-memory ，Flash memory，Magnetic-disk， Optical storage ，Tape storage</p>
<p>前两个是易失性的，后面四个非易失性</p>
<ol>
<li><p>Cache：最快的也是最贵的，不稳定volatile，被电脑系统管理</p>
</li>
<li><p>Main Memory：很快（10-100ns），由于太贵了而导致太小了，有易失性</p>
</li>
<li><p>Flash Memory快闪存储器：读很快与main memory一致，但是写很慢，非易失性。写慢，删除更慢</p>
</li>
<li><p>Magnetic-disk：慢而便宜，非易失性，容量一般很大，速度&gt;10毫秒</p>
</li>
<li><p>Optical Storage：光盘，只能读，难以改</p>
</li>
<li><p>Magnetic Tape：磁带</p>
<p><img src="https://img-blog.csdnimg.cn/20200701115259523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VtbWFfTG92ZQ==,size_16,color_FFFFFF,t_70" alt="img"></p>
</li>
</ol>
<h3 id="2-Magnetic-Disk磁盘"><a href="#2-Magnetic-Disk磁盘" class="headerlink" title="2. Magnetic Disk磁盘"></a>2. Magnetic Disk磁盘</h3><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220426135821091.png">

<ul>
<li><p>读写头</p>
<p>Disk arm 需要移动到到正确的Track上，这一段是<strong>寻道时间</strong>即找到数据所在Track的时间。</p>
</li>
<li><p>磁道Track</p>
<p>存数据的地方，一圈就是一个磁道，光盘会旋转从而找数据</p>
</li>
</ul>
<h4 id="2-1-Disk的性能衡量"><a href="#2-1-Disk的性能衡量" class="headerlink" title="2.1 Disk的性能衡量"></a>2.1 Disk的性能衡量</h4><ul>
<li><p>Access time：</p>
<p>Seek time 寻道时间+Rotational latency 旋转等待时间</p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220426140158045.png">
</li>
<li><p>Data-transfer rate数据传输速率：</p>
<p>从磁盘检索数据或将数据存储到磁盘的速率。</p>
</li>
<li><p>Example</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IBM Deskstar 14GPX</span><br><span class="line">3.5INCH，7200R/min</span><br><span class="line">容量14.4G，含5张双面盘片，每张约3.35G</span><br><span class="line">平均寻道时间9.1ms</span><br><span class="line">相邻磁道寻道时间2.2ms</span><br><span class="line">最大寻道时间 15.5ms</span><br><span class="line">平均旋转等待时间 4.17ms</span><br><span class="line">数据传输速率 13Mb/s</span><br></pre></td></tr></table></figure>

<p>磁盘的存取时间&gt;10ms而内存的存取时间≈10ns，相差100万倍！</p>
</li>
<li><p>Mean time to failure 平均故障时间（MTTF）</p>
<p>体现可靠性，即寿命，一般为3-5年，数据会出错。</p>
<p>数据在磁盘上，也可能损坏的。</p>
</li>
</ul>
<h4 id="2-2-Block"><a href="#2-2-Block" class="headerlink" title="2.2 Block"></a>2.2 Block</h4><p><strong>数据库存储或者读取数据的最小单位</strong></p>
<p><strong>读数据是读取一个包含这个数据的一个Block而非只读这一个数据</strong></p>
<ul>
<li><p>数据以块的形式在磁盘和主存之间传输</p>
</li>
<li><p>大小范围从512字节到几千字节</p>
<ul>
<li>更小的块：从磁盘传输更多的数据</li>
<li>更大的块：更多的空间浪费，因为部分填充的块</li>
<li>目前典型的块大小从4千字节到16千字节不等</li>
</ul>
</li>
</ul>
<h4 id="2-3-Disk-arm-scheduling-algorithm磁盘臂调度算法"><a href="#2-3-Disk-arm-scheduling-algorithm磁盘臂调度算法" class="headerlink" title="2.3 Disk-arm-scheduling algorithm磁盘臂调度算法"></a>2.3 Disk-arm-scheduling algorithm磁盘臂调度算法</h4><p><strong>电梯算法:</strong></p>
<ul>
<li>移动磁盘臂朝一个方向(从外到内追踪,反之亦然),处理下一个请求在那个方向,直到没有更多的请求在那个方向,然后反方向,重复。适用于运动方向一个维度的算法，尽量少的改变运动方向，知道所有的请求都要其改变方向</li>
<li>Nonvolatile write buffers（非易失性写缓冲区）<ul>
<li>通过立即将块写入非易失性RAM缓冲区来加速磁盘写操作</li>
<li>非易失性RAM:电池备份的RAM或闪存即使停电，数据也是安全的，并且在断电后仍可写入磁盘</li>
<li>当磁盘没有其他请求或请求等待一段时间后，控制器就会对磁盘进行写操作需要在继续之前安全地存储数据的</li>
<li>数据库操作可以在不等待数据写入磁盘的情况下继续进行，然后可以重新排序写入操作，以最小化磁盘臂移动</li>
</ul>
</li>
</ul>
<h3 id="3-RAID"><a href="#3-RAID" class="headerlink" title="3. RAID"></a><strong>3. RAID</strong></h3><h4 id="3-1-RAID"><a href="#3-1-RAID" class="headerlink" title="3.1 RAID"></a>3.1 RAID</h4><p>RAID：Redundant Arrays of Independent Disks （独立磁盘冗余阵列）</p>
<ul>
<li><p>磁盘组织技术，<strong>管理大量磁盘</strong>，<strong>提供单个磁盘的视图</strong></p>
<ul>
<li><p>多盘并行使用，容量大，速度快</p>
</li>
<li><p>可靠性高，数据冗余存储，即使硬盘故障也能恢复</p>
</li>
</ul>
</li>
<li><p>从两方面改善系统性能：</p>
<ul>
<li>冗余–可靠性</li>
<li>并行–速度</li>
</ul>
</li>
</ul>
<h4 id="3-2-Reliability"><a href="#3-2-Reliability" class="headerlink" title="3.2 Reliability"></a>3.2 Reliability</h4><ul>
<li><p>为了可靠性，要做出牺牲，即有效数据的容量降低</p>
</li>
<li><p>冗余：有数据的冗余，但是会有更高的可靠性</p>
</li>
<li><p>可以通过查看平均故障时间来衡量可靠性</p>
</li>
</ul>
<p>比特级拆分：按比特作为最小的数据规模</p>
<p>块级拆分：按一个block作为最小的数据规模</p>
<h4 id="3-3-RAID-Levels"><a href="#3-3-RAID-Levels" class="headerlink" title="3.3 RAID Levels"></a>3.3 RAID Levels</h4><ol>
<li>RAID Level 0：<ol>
<li>把所有的数据只存一次，没有数据冗余</li>
<li>优点：便宜，性能比较好</li>
<li>缺点：没有可靠性</li>
<li>适用范围：数据的可靠性无需保证，要求读写速度</li>
</ol>
</li>
<li>RAID Level 1：<ol>
<li>数据完全存在两个地方</li>
<li>优点：可靠性高</li>
<li>缺点：昂贵，最佳的读写性能</li>
</ol>
</li>
</ol>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220426143306991.png">

<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220426143558929.png">

<ol start="3">
<li><p>RAID Levels 2:</p>
<p>Memory-Style error - correct - codes (ECC) with bit striping。</p>
</li>
<li><p>RAID Levels 3:</p>
<ol>
<li>一个奇偶校验位就足以纠正错误，而不仅仅是检测错误，因为我们知道哪个磁盘出现了故障</li>
<li>写入数据时，也需要计算相应的奇偶校验位并写入校验位磁盘要恢复损坏磁盘中的数据，需要从其他磁盘(包括校验位磁盘)上计算<strong>位</strong>的<strong>异或</strong></li>
<li>数据传输速度比单个磁盘快，但每秒I&#x2F;O更少，因为每个磁盘都必须参与每个I&#x2F;O。包含等级2。</li>
<li>只要不坏两块盘就可以恢复</li>
</ol>
</li>
<li><p>RAID Levels 4:</p>
<ol>
<li>Block-Interleaved Parity</li>
<li>使用块级条带化，并在一个单独的磁盘上保留一个校验块，用于与N个其他磁盘相对应的块。</li>
<li>写数据块时，对应的校验位块也必须计算并写入校验盘为了找到一个损坏的块的值，从其他磁盘的相应<strong>块</strong>(包括奇偶校验块)中计算位的<strong>异或</strong>。</li>
</ol>
</li>
<li><p>RAID Levels 5：</p>
<ol>
<li><p>每个硬盘存<strong>有效数据</strong>也存<strong>异或的校验数据</strong></p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220426144107208.png">
</li>
<li><p>并行度比level4更高</p>
</li>
<li><p>这么一来level2，level3，level4基本上全面被level5超越了</p>
</li>
</ol>
</li>
<li><p>RAID Levels 6：</p>
<ol>
<li><p>在level5基础上加上冗余</p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220426144410895.png"></li>
</ol>
</li>
</ol>
<h4 id="3-4-RAID-Level的选择"><a href="#3-4-RAID-Level的选择" class="headerlink" title="3.4 RAID Level的选择"></a>3.4 RAID Level的选择</h4><ul>
<li><p>只有在数据安全性不重要的情况下，才可以使用RAID 0，例如，数据可以从其他来源快速恢复</p>
</li>
<li><p>2和4不会使用，因为被3和5代替</p>
</li>
<li><p>级别3不再使用，因为比特条带化迫使单个块读取访问所有磁盘，浪费磁盘臂的移动，这是块条带化(级别5)避免的</p>
</li>
<li><p>6级很少使用，因为1级和5级为几乎所有应用程序提供了足够的安全性所以竞争只在1到5之间</p>
</li>
<li><p>所以我们一般<strong>使用1或者5</strong>！！！</p>
</li>
</ul>
<h3 id="4-Tertiary-storage光盘和磁带"><a href="#4-Tertiary-storage光盘和磁带" class="headerlink" title="4. Tertiary storage光盘和磁带"></a>4. Tertiary storage光盘和磁带</h3><p>目前比较少使用</p>
<h3 id="5-Storage-Access"><a href="#5-Storage-Access" class="headerlink" title="5. Storage Access"></a>5. Storage Access</h3><ul>
<li><p>数据库文件在逻辑上被划分为称为<strong>块的固定长度的存储单元</strong>。</p>
</li>
<li><p>块是数据库系统中存储分配和数据传输的单元。</p>
</li>
<li><p><strong>缓冲区</strong>:可用来存储磁盘块副本的主存部分。</p>
</li>
<li><p>数据库系统寻求最小化磁盘和内存之间的块传输数量。</p>
<ul>
<li>为了减少磁盘访问的数量:在主存中保留尽可能多的块——Buffer。</li>
<li>但是缓冲区的大小是有限的。怎么办?</li>
</ul>
</li>
<li><p>缓冲区管理器:负责分配缓冲区空间的子系统</p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220426145102242.png">
</li>
<li><p><strong>Page是硬盘中的一个block在内存中的体现</strong>。</p>
</li>
<li><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220426145233644.png"></li>
</ul>
<h4 id="5-1-Buffer-Manager"><a href="#5-1-Buffer-Manager" class="headerlink" title="5.1 Buffer Manager"></a>5.1 Buffer Manager</h4><p>从硬盘中读取数据到内存</p>
<ol>
<li>block已经在buffer中了，则请求程序就会得到该数据块在主存中的地址</li>
<li>block不在buffer中<ol>
<li>buffer没有满，直接放入缓冲区</li>
<li>buffer满了，如果没有空闲空间，为新块腾出空间。要为新的Page分配空间</li>
</ol>
</li>
</ol>
<h5 id="5-1-1-缓冲区丢弃策略"><a href="#5-1-1-缓冲区丢弃策略" class="headerlink" title="5.1.1 缓冲区丢弃策略"></a>5.1.1 缓冲区丢弃策略</h5><ol>
<li><p>LRU：将冷数据丢弃</p>
<ol>
<li>热数据：当前经常被读写的数据</li>
<li>冷数据：很少被读写的数据</li>
</ol>
<p>缺点：刚用的块可能就不用了，此时是可以覆盖的，LRU不是最好的</p>
</li>
<li><p>MRU：将热数据丢弃</p>
<p>与LRU相反，不是绝对最优的策略</p>
</li>
<li><p>Pinned Block：把一些block钉住，无法丢弃出去，如正在被使用的块钉住</p>
</li>
<li><p>Toss-immediate strategy：用了直接丢弃</p>
</li>
<li><p>Forced output of blocks：块的请求者必须unpin，并表明页面是否被修改。</p>
</li>
<li><p>统计正在使用的事务量：某个数据被使用的数量，pin count&#x3D;0的时候丢弃</p>
</li>
</ol>
<h3 id="6-File-Organization"><a href="#6-File-Organization" class="headerlink" title="6. File Organization"></a>6. File Organization</h3><ul>
<li>database由文件构成</li>
<li>文件由一些列record构成</li>
<li>record有一系列的fields</li>
<li>两种record方式：<ol>
<li>定长的record</li>
<li>变长的record</li>
</ol>
</li>
</ul>
<h4 id="6-1-定长的Records"><a href="#6-1-定长的Records" class="headerlink" title="6.1 定长的Records"></a>6.1 定长的Records</h4><p>优点：</p>
<ol>
<li>方法简单</li>
</ol>
<p>缺点：</p>
<ol>
<li>由于定长而浪费空间</li>
</ol>
<p>删除：</p>
<ol>
<li><p>空着这一行，可能对null有要求</p>
</li>
<li><p>把下面行的数据上移一行，移动复杂</p>
</li>
<li><p>最后一行搬到这一行，但是顺序被打乱</p>
</li>
<li><p>空行进行标记，使用一个List来连接空行</p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220426151032243.png">

<p>优点：便于插入，更加高效</p>
</li>
</ol>
<h4 id="6-2-变长的Records"><a href="#6-2-变长的Records" class="headerlink" title="6.2 变长的Records"></a>6.2 变长的Records</h4><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220426151315803.png">

<p>Slotted page header包含:</p>
<ol>
<li>记录条目的数量</li>
<li>块中空闲空间的结束</li>
<li>每个记录的位置和大小</li>
</ol>
<p>页内无碎块，删除时页内移动记录</p>
<h3 id="7-Organization-of-Records-in-Files"><a href="#7-Organization-of-Records-in-Files" class="headerlink" title="7. Organization of Records in Files"></a>7. Organization of Records in Files</h3><ol>
<li><p>Heap file</p>
</li>
<li><p>Sequential file顺序文件</p>
<p>按照一定的顺序排列文件</p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220426151801226.png">
</li>
<li><p>Hashing file散列文件</p>
</li>
<li><p>Clustering file organization聚集文件组织</p>
<p>按不同属性的划分，可以进行聚集，比如</p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220426152337977.png">

<p>可以聚集为：</p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220426152352090.png">

<p>如此一来，查询Comp.Sci.只需要导入某个块，而不是把整个instructor的表的块全部导入而是仅仅导入Comp.sci.下的数据。</p>
<p>为了保证Comp.sci.和Physics这个dept表也能正常查询,我们可以使用链表把这两行连起来。</p>
</li>
</ol>
<h3 id="8-Data-Dictionary-Storage"><a href="#8-Data-Dictionary-Storage" class="headerlink" title="8. Data-Dictionary Storage"></a>8. Data-Dictionary Storage</h3><ul>
<li><p>数据字典是元数据：描述了数据（表）的数据，如</p>
<ul>
<li>关系（表）的信息</li>
<li>用户的信息</li>
<li>统计信息</li>
<li>物理层面信息，数据存在哪里</li>
<li>indices目录的信息</li>
</ul>
</li>
<li><p>也是使用表的方式存储！是一类特殊的表。</p>
</li>
</ul>
<h2 id="11：Indexing-and-Hashing"><a href="#11：Indexing-and-Hashing" class="headerlink" title="11：Indexing and Hashing"></a>11：Indexing and Hashing</h2><h3 id="1-Basic-Concepts"><a href="#1-Basic-Concepts" class="headerlink" title="1. Basic Concepts"></a>1. Basic Concepts</h3><p>索引：对于查找有帮助</p>
<p>包含：Search-Key ， Pointer</p>
<ul>
<li><p>分类：</p>
<ol>
<li><p>顺序索引</p>
<p>根据一定的顺序存储key</p>
</li>
<li><p>散列索引</p>
<p>使用hash函数确定key存放的位置</p>
</li>
</ol>
</li>
<li><p>Access time</p>
<p>查询效率变高</p>
</li>
<li><p>Insertion time</p>
<p>插入时间，写的方面的时间变大</p>
</li>
<li><p>Deletion time</p>
<p>删除时间，写的方面的时间变大</p>
</li>
<li><p>Space overhead</p>
</li>
</ul>
<h3 id="2-Ordered-Indices"><a href="#2-Ordered-Indices" class="headerlink" title="2. Ordered Indices"></a>2. Ordered Indices</h3><ul>
<li><p>在ordered index中，索引的顺序和数据的search key的排列顺序一样</p>
</li>
<li><p>主索引（primary index）</p>
<ul>
<li>索引值的search key和顺序排序数据的search key一致</li>
<li>其他的是<strong>辅助索引</strong></li>
<li>主索引通常是主码，但并非一定是主码</li>
</ul>
</li>
<li><p>稠密索引文件Dense Index Files</p>
<ul>
<li>数据里面出现的每一个search key在索引中都出现了，不要求一一对应，但是要全部出现。</li>
<li><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220507133545940.png"></li>
<li>稠密索引且为主索引</li>
</ul>
</li>
<li><p>稀疏索引文件Sparse Index Files</p>
<ul>
<li><p>索引只包含了部分的search key</p>
</li>
<li><p>稀疏索引的搜索方法：类似于二分查找找区间即可</p>
</li>
<li><p>优点：空间占用少，可以在内存中使用</p>
</li>
<li><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220507133837374.png"></li>
<li><p>稀疏索引且为主索引</p>
</li>
<li><p><strong>Good tradeoff</strong>：</p>
<ul>
<li>稠密索引的速度并没有比稀疏索引快</li>
<li>硬盘读入内存的最小单位为一个block，一个block中可能有多个数据记录，每块中的最小的搜索键值放在索引项中。</li>
<li>我们找数据只要找到数据所在的block，找数据时通过比较就可以找到数据的存放block</li>
</ul>
</li>
<li><p><strong>Sparse index只用于顺序文件</strong>，而dense index可以用于顺序文件和非顺序文件</p>
</li>
</ul>
</li>
<li><p>二级索引&#x2F;辅助索引 Secondary Indices</p>
<ul>
<li>二级索引&#x2F;辅助索引，一般采用稠密索引</li>
<li><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220507134646027.png"></li>
<li>如上表，balance为700的search key，此时我们为了通过这个索引要找到数据，这个二级索引必须要是稠密索引，不然的话会找不到。</li>
</ul>
</li>
<li><p>Multilevel Index</p>
<ul>
<li><p>主索引可能会很大而不能装入内存，因此我们可以建立一个<strong>主索引的稀疏索引</strong>，即索引的索引。</p>
</li>
<li><p>找一个数据先通过外索引（outer index）找到内索引（inner index）即主索引，再查找数据。</p>
</li>
<li><p>如果outer index仍然很大，那可以继续扩展，可以推广到任意多层</p>
</li>
</ul>
</li>
<li><p>Index Update：Deletion</p>
<ul>
<li><p>step1：系统找到一个数据文件，删除record</p>
</li>
<li><p>step2：</p>
<ul>
<li><p>稠密索引：</p>
<ul>
<li>唯一性：直接删除</li>
<li>非唯一：删的是二级索引的第一条，把二级索引的第一条指向后一个，删掉的不是第一个那么不用改变</li>
</ul>
</li>
<li><p>稀疏索引：</p>
<ul>
<li>稀疏索引如果已删除记录的搜索键值没有出现在索引中，则对索引不做任何操作。</li>
<li>否则，如果索引文件中存在该搜索键的索引条目，则通过将该条目替换为数据文件中的下一个搜索键值(按搜索键的顺序)来删除该条目。</li>
<li>如果下一个搜索键值已经有一个索引项，那么该索引项将被删除，而不是被替换。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Index Update：Insertion</p>
<ul>
<li>稠密索引：<ul>
<li>搜索键值没有出现在索引中，则插入一个带有搜索键值的索引条目</li>
<li>否则,如果使用多指针，则添加一个指向新记录的指针(在索引项中)</li>
<li>否则，与索引项无关</li>
</ul>
</li>
<li>稀疏索引：<ul>
<li>(假设每个块都有一个索引条目)如果创建了一个新块，将新块中出现的第一个搜索键值插入索引中。</li>
<li>如果新记录的块中搜索键值最小，则更新索引项。</li>
<li>否则没有变化</li>
</ul>
</li>
</ul>
</li>
<li><p>二级索引的新增与删除</p>
<ul>
<li>必须是主索引，所以是一一对应的，直接根据以上的规则进行修改</li>
</ul>
</li>
</ul>
<h3 id="3-B-树"><a href="#3-B-树" class="headerlink" title="3. B+树"></a>3. B+树</h3><ul>
<li><p>B-tree索引是索引顺序文件的替代方法。</p>
</li>
<li><p>索引顺序文件的缺点</p>
<ul>
<li>随着文件的增长，性能下降，因为创建了许多溢出块。</li>
<li>需要定期重组整个文件。</li>
</ul>
</li>
<li><p>B-tree索引文件的优点</p>
<ul>
<li><p>在面对插入和删除时，使用较小的本地更改自动重新组织自身。</p>
</li>
<li><p>不需要对整个文件进行重组来保持性能。(次要)B-树的缺点:额外的插入和删除开销;空间开销。</p>
</li>
</ul>
</li>
<li><p>B+-tree的优点大于缺点: B*-树被广泛使用</p>
</li>
<li><p>B+树的特点：</p>
<ul>
<li><p>M阶的B+树定义：</p>
<ul>
<li>根节点是叶节点或者根节点有2~M个儿子</li>
<li>根之外的<strong>非叶节点</strong>有$[\frac{M}{2}]$<del>M个儿子，每个叶节点有$[\frac{M}{2}]$</del>M个子节点（NULL）</li>
<li>叶子节点的Key值在$\lceil(n-1)&#x2F;2 \rceil 和n-1$之间<ul>
<li>B+树的儿子指的是节点指向的新节点而非节点内的数据</li>
<li>每个节点的 key数是子节点数-1，画图的时候key分布在指向两个儿子的箭头之间 </li>
<li>key值的确定方法：等于key右边第一个指针对应子节点的最左边的值</li>
</ul>
</li>
<li>所有叶节点的深度相同</li>
<li>B+ Tree of Order 4 也称为2-3-4树，order 3 的称为2-3树</li>
<li><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220507141601574.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>B+树的结点的结构：</p>
<ul>
<li><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220507141935061.png"></li>
<li>由指向孩子的指针和键值组成</li>
<li>键值是按顺序排列的</li>
<li><strong>通常一个节点对应一个Block</strong>，从而确定B+树的阶数</li>
</ul>
</li>
<li><p>B+树的查找</p>
<ul>
<li>N阶B+树，K个key，树高最高为$\lceil log_{\lceil n&#x2F;2\rceil}(K)\rceil$</li>
<li>对查询的效率有很大的提高</li>
</ul>
</li>
<li><p>B+树的插入</p>
<ol>
<li><p>找到这个数据应该所处的叶节点</p>
</li>
<li><p>插入，如果key的个数超过了M-1，那么分裂为2个有$[\frac{M-1}{2}]$的key值的节点，依此向上递归。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Btree Insert ( ElementType X, Btree T )</span><br><span class="line">&#123;</span><br><span class="line">   Search from root to leaf for X and find the proper leaf node;</span><br><span class="line">   Insert X;</span><br><span class="line">   while ( this node has M+1 keys ) &#123;</span><br><span class="line">       split it into 2 nodes with [(M+1)/2] and [(M+1)/2] keys,</span><br><span class="line">respectively;</span><br><span class="line">       if (this node is the root)</span><br><span class="line">           create a new root with two children;</span><br><span class="line">       check its parent;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">//算法的描述：找到合适的位置先插入，如果叶节点的keys数量超过了M，则分裂成两个，然后向上继续合并和拆分</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>B+树的删除操作</p>
<ol>
<li><p>找到这个节点</p>
</li>
<li><p>删去后小于$\lceil\frac{M}{2} \rceil$个子节点（NULL），则Merge一下，Merge完可能太多了再拆分掉，查看父亲的儿子个数继续向上递归。</p>
</li>
<li><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220507145845966.png"></li>
</ol>
</li>
</ul>
<h3 id="4-B树Index-Files"><a href="#4-B树Index-Files" class="headerlink" title="4. B树Index Files"></a>4. B树Index Files</h3><ul>
<li>其他与B+树一样，但是，B+树只有在叶子节点才能查找数据</li>
<li>B树在非叶子节点也可以找，找到一样的Key直接找Value</li>
</ul>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220507151940862.png">

<ul>
<li>B树的查找效率比B+树高</li>
<li>为什么还用B+树：<ul>
<li>b -树指数的优点:<ul>
<li>可能比相应的B+-Tree使用更少的树节点(因为重复)。</li>
<li>有时可能在到达叶节点之前找到搜索键值。</li>
</ul>
</li>
<li>b树索引的缺点:<ul>
<li>在所有搜索键值中，只有一小部分在早期被发现</li>
<li>非叶节点更大，因此减少了扇出</li>
<li>因此，B树通常比相应的B+树有更大的深度</li>
<li>插入和删除比B树更复杂实现比B+树更难。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-Static-Hashing-静态哈希"><a href="#5-Static-Hashing-静态哈希" class="headerlink" title="5. Static Hashing 静态哈希"></a>5. Static Hashing 静态哈希</h3><ul>
<li>桶bucket是包含一条或多条记录的存储单元(桶通常是磁盘块)。</li>
<li>在哈希文件组织中，我们使用哈希函数直接从记录的搜索键值获得记录桶。</li>
<li>哈希函数h是从所有搜索键值K的集合到所有桶地址B的集合的函数。</li>
<li>哈希函数用于定位记录的访问、插入和删除。</li>
<li>具有不同搜索键值的记录可以映射到相同的bucket;因此，必须依次搜索整个桶来定位一条记录。</li>
</ul>
<p>Hash索引，根据属性设计哈希函数，进行计算计算出这个属性对应的数据应该存放的位置bucket。当桶overflow则用指针指向新的位置</p>
<h3 id="6-Write-optimized-Indices"><a href="#6-Write-optimized-Indices" class="headerlink" title="6. Write-optimized Indices"></a>6. Write-optimized Indices</h3><h4 id="LSM树索引"><a href="#LSM树索引" class="headerlink" title="LSM树索引"></a>LSM树索引</h4><ul>
<li><p>面向写的优化的一颗树：只考虑插入和查询</p>
</li>
<li><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220510131906560.png"></li>
<li><p>数据插入时线插入内存中的L0树，当L0树满了，将L0存到磁盘上作为L1，继续输入L0，满了之后L0和L1合成为一个L2存在磁盘，如是反复，就像二进制的加法一样，但是这里的合并要按顺序写入</p>
</li>
<li><p>LSM的优点：</p>
<ul>
<li>插入只需要在内存中完成，很快</li>
<li>Leaves是满的，避免内存浪费</li>
<li>减少IO操作</li>
</ul>
</li>
<li><p>LSM的缺点：</p>
<ul>
<li>查询要查询很多颗树</li>
<li>先查内存、再查Level1、Level2…</li>
<li>多次复制每个级别的完整内容</li>
</ul>
</li>
<li><p>Stepped-merge 索引</p>
<ul>
<li>LSM树的变体，每层有多棵树</li>
<li>与LSM树相比，减少了写开销</li>
<li>但是查询的开销更大<ul>
<li>Bloom过滤器，以避免在大多数树中查找</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Buffer-Tree"><a href="#Buffer-Tree" class="headerlink" title="Buffer Tree"></a>Buffer Tree</h4><ul>
<li>LSM树的替代方案</li>
<li>关键思想:<ul>
<li>B+tree的每个内部节点都有一个缓冲区来存储插入</li>
<li>当缓冲区满时，插入被移动到较低的级别</li>
<li>对于一个大的缓冲区，每当每条记录的I&#x2F;O相应减少时，许多记录都会被移动到较低的级别</li>
</ul>
</li>
<li>好处<ul>
<li>更少的查询开销</li>
<li>可用于任何树索引结构</li>
<li>用于PostgreSQL广义搜索树(GiST)、</li>
</ul>
</li>
<li>索引缺点<ul>
<li>比LSM树有更多的随机I&#x2F;O</li>
</ul>
</li>
</ul>
<h3 id="7-Bitmap-Indices"><a href="#7-Bitmap-Indices" class="headerlink" title="7. Bitmap Indices"></a>7. Bitmap Indices</h3><ul>
<li><p>是用于多值查询的，因为对于域少的属性，查询结果会很多</p>
</li>
<li><p>位图索引是一种特殊类型的索引，用于对多个键进行高效查询关系中的</p>
</li>
<li><p>记录假定从0开始按顺序编号给定一个数字n，检索记录n必须很容易，特别是当记录是固定大小时</p>
</li>
<li><p><strong>适用于具有相对较少的不同值的属性</strong>例如，性别，国家，州，例如收入水平(收入分成少量的水平，如0-9999,10000-19999,20000-50000,50000-无限)</p>
</li>
<li><p>位图就是位的数组</p>
</li>
<li><p>将所有的对象的属性放在一个属性的位图中，如：</p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220510134541387.png">

<ul>
<li>如m的位图中第一个和第三个是男的</li>
<li>L1中的第一位和第三位是收入在L1的<ul>
<li>要多值查询直接可以进行一个操作即可。</li>
<li>如与、或、非</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>注意只适用于取值范围小的情况</strong></p>
</li>
</ul>
<h2 id="12：Query-Processing-查询处理"><a href="#12：Query-Processing-查询处理" class="headerlink" title="12：Query Processing 查询处理"></a>12：Query Processing 查询处理</h2><p><strong>通常来说，查询语句是最重要的。</strong></p>
<ul>
<li>Levels of Memory Hierarchy</li>
<li><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220510140319201.png"></li>
</ul>
<h3 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h3><ol>
<li><p>Parsing and translation</p>
</li>
<li><p>Optimization</p>
</li>
<li><p>Evaluation</p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220510140630699.png"></li>
</ol>
<h4 id="1-1-Paring-and-translation"><a href="#1-1-Paring-and-translation" class="headerlink" title="1.1 Paring and translation"></a>1.1 Paring and translation</h4><p>分析语法、关系，并且进行翻译</p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220510140838063.png">

<h4 id="1-2-Evaluation"><a href="#1-2-Evaluation" class="headerlink" title="1.2 Evaluation"></a>1.2 Evaluation</h4><p>生成查询计划，查询计划是定义了那些算法在哪个步骤中需要使用，操作如何执行实现等。</p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220510140920299.png">

<h4 id="1-3-Optimization"><a href="#1-3-Optimization" class="headerlink" title="1.3 Optimization"></a>1.3 Optimization</h4><h3 id="2-Measures-of-Query-Cost"><a href="#2-Measures-of-Query-Cost" class="headerlink" title="2. Measures of Query Cost"></a>2. Measures of Query Cost</h3><ul>
<li>有许许多多的查询方法，我们要知道这些算法的效率</li>
<li>time Cost &#x3D; <strong>Disk access</strong> + CPU + network communication</li>
<li>在这里我们只讨论Disk access的时间</li>
</ul>
<h4 id="2-1-硬盘的时间"><a href="#2-1-硬盘的时间" class="headerlink" title="2.1 硬盘的时间"></a>2.1 硬盘的时间</h4><ol>
<li>Seek 时间：磁头的寻道时间</li>
<li>传输时间：write和read的时间</li>
</ol>
<p>我们可以将其抽象为：</p>
<ol>
<li>seek的操作的次数</li>
<li>transfer（write、read）的block的个数</li>
</ol>
<p>$t_s-time\ for\ seek$</p>
<p>$t_T-time\ to\ transfer\ one\ block$</p>
<p>b次block transfers和s次的寻找</p>
<ul>
<li>$b<em>t_T+S</em>t_s$</li>
</ul>
<h3 id="3-Selection-Operation"><a href="#3-Selection-Operation" class="headerlink" title="3. Selection Operation"></a>3. Selection Operation</h3><ol>
<li><p>线性搜索：</p>
<p>seek只需要一次，只需要找到第一个block向后找</p>
<p>设有$b_r$块，平均的寻找时间是br&#x2F;2则</p>
<p>$Cost&#x3D;\frac{b_r}{2}\ block transfer+1\ seek$</p>
<p>$Cost&#x3D;\frac{b_r}{2}t_T+t_s$</p>
</li>
<li><p>二分搜索：</p>
<p>根据主键查找，主键是顺序储存的。</p>
<p>$Cost&#x3D;\lceil log_2(b_r)\rceil *block\ transfer+\lceil log_2(b_r)\rceil *seek$</p>
<p>$Cost&#x3D;\lceil log_2(b_r)\rceil(t_s+t_T)$</p>
<p>block transfer的次数$&#x3D;\lceil log_2(b_r)\rceil+\lceil \frac{sc(A,r)}{f_r}\rceil-1$</p>
<p>$sc(A,r)$是满足条件的记录数</p>
<p>$f_r$是每个block的记录数</p>
</li>
</ol>
<h4 id="3-1-树索引"><a href="#3-1-树索引" class="headerlink" title="3.1 树索引"></a>3.1 树索引</h4><ol start="3">
<li><p>A3(primary index，equality on key单个)</p>
<p>在树上找，那就是一次seek一个block（node）</p>
<p>有h+1次的seek和transfer</p>
<p>$Cost&#x3D;(h_i+1)*(t_T+t_S)$</p>
</li>
<li><p>A4(primary key，equality on nonkey有多个结果)</p>
<p>$Cost&#x3D;h_i(t_T+t_S)+t_S+t_T*b$</p>
<p>$b&#x3D;\lceil \frac{sc(A,r)}{f_r}\rceil$</p>
</li>
<li><p>A5(secondary index，equality on nonkey)</p>
<ol>
<li><p>这个search-key是候选码：</p>
<p>找到的有且只有一个，与primary index是一样的</p>
<p>$Cost&#x3D;(h_i+1)*(t_T+t_S)$</p>
</li>
<li><p>不是候选码：</p>
<p>满足结果的记录数有n个，每一个都可能在不同的block中，之多有n个block中</p>
<p>$$Cost&#x3D;(h_i+n)*(t_T+t_S)$$</p>
</li>
</ol>
</li>
</ol>
<h4 id="3-2-范围检索"><a href="#3-2-范围检索" class="headerlink" title="3.2 范围检索"></a>3.2 范围检索</h4><ol start="6">
<li><p>A6(primary key ，comparison)基于主索引的比较</p>
<p>对于要找大于等于V的，找到这个等于V的位置即可，一直向后找，小于等于的就是找到前面的。</p>
</li>
<li><p>A7(secondary index，comparison)基于辅助索引的比较</p>
<p>找到V的位置，查询其叶子节点。</p>
</li>
</ol>
<h4 id="3-3-And的查找"><a href="#3-3-And的查找" class="headerlink" title="3.3 And的查找"></a>3.3 And的查找</h4><ol start="8">
<li><p>A8(conjunctive selection using one index)</p>
<p>只使用一个索引,先用代价最小的索引查一次，再在结果集中继续查询。</p>
</li>
<li><p>A9(conjunctive selection using composite index)</p>
<p>多值查询，果可用，使用适当的复合(多键)索引。</p>
</li>
<li><p>A10(conjunctive selection by intersection of identifiers)</p>
<p>需要带记录指针的索引。对每个条件使用相应的索引，并取所有获得的记录指针集的交集。然后从文件中获取记录如果某些条件没有适当的索引，则在内存中应用test。</p>
</li>
</ol>
<ul>
<li>对于或，用线性扫描也是可以的</li>
<li>对于非，用线性扫描，要预估结果的规模</li>
</ul>
<h3 id="4-Sort"><a href="#4-Sort" class="headerlink" title="4. Sort"></a>4. Sort</h3><p>归并排序，在每一个小的block先排好序，再进行merge合成大的排序</p>
<ul>
<li><p>Example：</p>
<p>24，19，31 | 33，14，16 | 16，21，3 | 2，7，14</p>
<p>先块内排序：</p>
<p>19，24，31 | 14，16，33 | 3，16，21 | 2，7，14</p>
<p>再进行merge:</p>
<p>14，16，19，24，31，33 | 2，3，7，14，16，21</p>
</li>
</ul>
<p>Merge的次数：$\lceil log_{M-1}(b_r&#x2F;M)\rceil$其中M为Block的大小，b为数据的个数</p>
<p>Transfer的次数：$b_r(2\lceil log_{M-1}(b_r&#x2F;M)\rceil+1)$两读一写</p>
<p>seek的次数：每个block要读和写$2\lceil b_r&#x2F;M\rceil$，设buffer size为$b_b$，每次可以取出$b_b$个数据，即为$2\lceil b_r&#x2F;M\rceil+\lceil b_r&#x2F;b_b\rceil(2\lceil log_{M-1}(b_r&#x2F;M)\rceil-1)$</p>
<h3 id="5-Join-Operation"><a href="#5-Join-Operation" class="headerlink" title="5. Join Operation"></a>5. Join Operation</h3><p>Example：customer.n&#x3D;10000, depositor.n&#x3D;5000；customer.b&#x3D;400，depositor.b&#x3D;100</p>
<h4 id="5-1-两个for循环进行连接"><a href="#5-1-两个for循环进行连接" class="headerlink" title="5.1 两个for循环进行连接"></a>5.1 两个for循环进行连接</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for each tuple tr in r do begin</span><br><span class="line">    for each tuple ts in s do begin</span><br><span class="line">    test pair (tr,ts) to see if they satisfy the join condition </span><br><span class="line">    if they do, add tr• tsto the result</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>$n_r*b_s+b_r$为block的transfers</p>
<p>外面的r只需要读br次，内部的s再每一个r的元素中要读bs次，即nr*bs次</p>
<p>$n_r+b_r$为seeks</p>
<h4 id="5-2-四个for循环"><a href="#5-2-四个for循环" class="headerlink" title="5.2 四个for循环"></a>5.2 四个for循环</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for each block Br of r do begin</span><br><span class="line">    for each block Bs of s do begin</span><br><span class="line">        for each tuple tr in Br do begin</span><br><span class="line">            for each tuple ts in Bs do begin</span><br><span class="line">            Check if (tr,ts) satisfy the join condition </span><br><span class="line">            if they do, add tr• ts to the result.</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">   end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>这个算法全面比第一个好。</p>
<p>有$b_r*bs+b+r$的block transfer</p>
<p>有$2*b_r$的seeks</p>
<h4 id="5-3-Indexed-Nested-Loop-Join"><a href="#5-3-Indexed-Nested-Loop-Join" class="headerlink" title="5.3 Indexed Nested-Loop Join"></a>5.3 Indexed Nested-Loop Join</h4><p>有一个表有B+树索引，把一张表的一个block读进来，对于block中的一行，再有B+树索引的表中查找这个值</p>
<p>$Cost&#x3D;b_r(t_T+t_S)+n_r*C$</p>
<p>C是操作的cost</p>
<h4 id="5-4-Sort-Merge-Join"><a href="#5-4-Sort-Merge-Join" class="headerlink" title="5.4 Sort Merge-Join"></a>5.4 Sort Merge-Join</h4><p>首先确保两个排好顺序，这样已经遍历过的就无需回退</p>
<p>那么每一个block只读入了一次</p>
<p>$b_r+b_s$次block transfer</p>
<p>$b_r&#x2F;b_b+b_s&#x2F;b_b$次的seeks</p>
<p>还要加上<strong>排序的代价</strong>。</p>
<h4 id="5-5-Hash-Join"><a href="#5-5-Hash-Join" class="headerlink" title="5.5 Hash Join"></a>5.5 Hash Join</h4><p>设定一个hash函数，r映射到p1，s映射到p2，r要等于s，那么r和s的hash值一定相等。在p1-p2中找可以形成配对的组合</p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220510153658180.png">

<p>两个大表变成许多小表的join，想要join成功只有在同一个partition中才可能相等。即可以把大表的连接做成小表的连接。</p>
<p>block transfer：首先假设r有br块，s有bs块，把r表每一个都读进来计算hash值写回去，即2br，s也一样，2bs，在真正的join中再读进来一次br+bs。在计算出来的hash值中，要都进来一次写出去一次，在后续的join中也是读一次写一次。即为$3(b_r+b_s)+4n_h$。nh是分区的个数。</p>
<p>seek：为了计算hash，读入br&#x2F;bb+bs&#x2F;bb，在真正的join时也是如此，hash值也是每次读写nh个分区的block即为。$2(b_r&#x2F;b_b+b_s&#x2F;b_b)+2n_h$</p>
<h3 id="6-Evaluation-of-Expressions"><a href="#6-Evaluation-of-Expressions" class="headerlink" title="6. Evaluation of Expressions"></a>6. Evaluation of Expressions</h3><h4 id="6-1-Materialization-实体化"><a href="#6-1-Materialization-实体化" class="headerlink" title="6.1 Materialization 实体化"></a>6.1 Materialization 实体化</h4><p>将计算的expression的结果放入磁盘</p>
<p>即一边计算一边写硬盘，除非计算的速度远大于写的速度。</p>
<h4 id="6-2-Pipeline-流水线"><a href="#6-2-Pipeline-流水线" class="headerlink" title="6.2 Pipeline 流水线"></a>6.2 Pipeline 流水线</h4><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220517135358328.png">

<p>(1) </p>
<p>20000&#x2F;25&#x3D;800 block</p>
<p>45000&#x2F;30&#x3D;1500 block</p>
<p>800*1500+800 &#x3D; 1200800次transfer</p>
<p>seek：800*2&#x3D;1600次</p>
<p>(2) </p>
<p>T2取一个tuple，每一个tuple做一次对T1的从顶到叶的查询</p>
<p>T2每一个block都要读进来</p>
<p>45000*(3+1)+1500 transfer</p>
<p>1500 seek</p>
<h2 id="13：Query-Optimization"><a href="#13：Query-Optimization" class="headerlink" title="13：Query Optimization"></a>13：Query Optimization</h2><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><p>查询计划：要制定查询计划，有了查询计划数据库可以直接调用函数进行查询。</p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220517140314914.png">

<ul>
<li>查询计划有说明计算方法，储存方式等</li>
</ul>
<h3 id="2-Transformation-of-Relational-Expressions"><a href="#2-Transformation-of-Relational-Expressions" class="headerlink" title="2. Transformation of Relational Expressions"></a>2. Transformation of Relational Expressions</h3><ul>
<li><p>如果两个关系代数表达式在每个合法数据库实例上生成相同的元组集，则这两个表达式被认为是等价的。</p>
<ul>
<li>元组的顺序无关</li>
<li>我们不关心它们是否在违反完整性约束的数据库上生成不同的结果</li>
</ul>
</li>
<li><p>在SQL中，输入和输出是元组的多集</p>
<ul>
<li>如果关系代数的多集版本中的两个表达式在每个合法数据库实例上生成相同的元组多集，则这两个表达式被认为是等价的。</li>
</ul>
</li>
<li><p>等价规则认为两种形式的表达式是等价的可以用第二种形式替换第一种形式的表达式吗</p>
</li>
</ul>
<h4 id="2-1-等价转化规则"><a href="#2-1-等价转化规则" class="headerlink" title="2.1 等价转化规则"></a>2.1 等价转化规则</h4><ol>
<li><p>$\sigma_{θ_1\andθ_2}(E)&#x3D;\sigma_{θ_1}(\sigma_{θ_2}(E))$</p>
</li>
<li><p>$\sigma_{θ_1}(\sigma_{θ_2}(E))&#x3D;\sigma_{θ_2}(\sigma_{θ_1}(E))$</p>
</li>
<li><p>$\Pi_{L_1}(\Pi_{L_2}…(\Pi_{L_i}(E)))&#x3D;\Pi_{L_1}(E)$</p>
</li>
<li><p>$\sigma_θ(E_1×E_2)&#x3D;E_1\Join _{θ}E_2$</p>
<p>$\sigma _{θ_1}(E_1\Join _{θ_2}E_2)&#x3D;E_1\Join _{θ_1\andθ_2}E_2$</p>
</li>
<li><p>$E_1\Join _{θ}E_2&#x3D;E_2\Join _{θ}E_1$</p>
</li>
<li><p>$E_1\Join _{θ_1}(E_2\Join _{θ_2}E_3)&#x3D;(E_1\Join _{θ_1}E_2)\Join _{θ_2}E_3$</p>
</li>
<li><p>$E_1\Join _{θ_1}(E_2\Join _{θ_2\andθ_3}E_3)&#x3D;(E_1\Join _{θ_1\and θ_3}E_2)\Join _{θ_2}E_3$</p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220517141803044.png">

<p>注意先选再连接比先连接再选要好，因为连接的开销很大。先投影也是这个原理</p>
</li>
<li><p>如果θ0只对E1的属性有要求$\sigma _{θ_0}(E_1\Join <em>{θ}E_2)&#x3D;\sigma</em>{θ_0}(E_1)\Join _{θ}E_2$</p>
</li>
<li><p>θ1只在E1中，θ2只在E2中</p>
<p>$\sigma _{θ_1\andθ_2}(E_1\Join <em>{θ}E_2)&#x3D;\sigma</em>{θ_1}(E_1)\Join <em>{θ}\sigma</em>{θ_2}(E_2)$</p>
</li>
<li><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220517142408516.png">
</li>
<li><p><strong>在查询树中，我们要把选择操作向叶子进行优化，即让选择投影先做，连接后做。</strong></p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220517142558829.png">
</li>
<li><p>在连接方面，如果有$r_1\Join r_2\Join r_3$</p>
<p>如果$r_1\Join r_2$和$r_2\Join r_3$有大小关系已知，优先做结果小的连接。</p>
</li>
</ol>
<h3 id="3-Statistics-for-Cost-Estimation"><a href="#3-Statistics-for-Cost-Estimation" class="headerlink" title="3. Statistics for Cost Estimation"></a>3. Statistics for Cost Estimation</h3><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220517144357005.png">

<h4 id="3-1-Selection-Size-Estimation"><a href="#3-1-Selection-Size-Estimation" class="headerlink" title="3.1 Selection Size Estimation"></a>3.1 Selection Size Estimation</h4><ul>
<li><p>$\sigma_{A&#x3D;V}(r)$</p>
<ul>
<li>$n_r&#x2F;V(A,r)$平均满足selection的records数量</li>
<li>Equality condition on a key attribute：size estimate &#x3D; 1</li>
</ul>
</li>
<li><p>$\sigma_{A≤V}(r)$</p>
<ul>
<li>设c是预估的满足条件的tuples</li>
<li>v&lt;min(A,r)：c&#x3D;0，不用查了查不到</li>
<li>$c&#x3D;n_r\frac{v-min(A,r)}{max(A,r)-min(A,r)}$</li>
</ul>
</li>
<li><p>Complex Selections</p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220517150829635.png"></li>
</ul>
<h4 id="3-2-Estimation-of-the-size-of-joins"><a href="#3-2-Estimation-of-the-size-of-joins" class="headerlink" title="3.2 Estimation of the size of joins"></a>3.2 Estimation of the size of joins</h4><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220517150939610.png">

<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220517150953058.png">

<h3 id="4-Dynamic-Programming-for-Choosing-Evaluation-Plans-动态规划选择评估策略"><a href="#4-Dynamic-Programming-for-Choosing-Evaluation-Plans-动态规划选择评估策略" class="headerlink" title="4. Dynamic Programming for Choosing Evaluation Plans 动态规划选择评估策略"></a>4. Dynamic Programming for Choosing Evaluation Plans 动态规划选择评估策略</h3><p><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220517151514747.png">Left Deep Join Tree：有利于流水线</p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220517151629561.png">

<h2 id="14：Transactions事务"><a href="#14：Transactions事务" class="headerlink" title="14：Transactions事务"></a>14：Transactions事务</h2><h3 id="1-事务的概念"><a href="#1-事务的概念" class="headerlink" title="1. 事务的概念"></a>1. 事务的概念</h3><ul>
<li>并发问题：多用户或者多进程</li>
<li>故障的处理：数据库故障了如何回复数据等</li>
</ul>
<p>事务是一堆的sql语句，但是事务执行完毕后只有两个出口：提交（commit）和回滚（rollback），但是要保证一致性，要符合四个特性ACID</p>
<ol>
<li>Atomicity原子性：sql代码是不可分割的，要么完全执行要么都不执行</li>
<li>Consistency一致性：执行的前后保证结果一致</li>
<li>Isolation隔离性：面向并发的，其他的事务与当前事务无关</li>
<li>Durability持久性：能够长久正常运行</li>
</ol>
<h2 id="2-Transaction-State"><a href="#2-Transaction-State" class="headerlink" title="2. Transaction State"></a>2. Transaction State</h2><ul>
<li><p>Active</p>
<ul>
<li>the initial state; the transaction stays in this state while it is executing</li>
</ul>
</li>
<li><p>Partially committed </p>
<ul>
<li>after the final statement has been executed.（此时要输出的结果数据可能还在内存buffer中）</li>
</ul>
</li>
<li><p>Failed</p>
<ul>
<li>after the discovery that normal execution can no longer proceed.</li>
</ul>
</li>
<li><p>Aborted</p>
<ul>
<li><p>– after the transaction has been rolled back and the database restored to its state prior to the start of the transaction.  Two options after it has been aborted</p>
</li>
<li><p>Restart the transaction</p>
</li>
<li><p>Can be done only if no internal logical error</p>
</li>
<li><p>Kill the transaction</p>
</li>
</ul>
</li>
<li><p>Committed</p>
<ul>
<li>– after successful completion.</li>
</ul>
</li>
</ul>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220524140539016.png">

<h3 id="3-原子性和持久性"><a href="#3-原子性和持久性" class="headerlink" title="3. 原子性和持久性"></a>3. 原子性和持久性</h3><p>影子拷贝</p>
<p>新开一个数据，从老数据那里复制，在这个数据改，改完把指针指向这个新的数据</p>
<h3 id="4-Concurrent-Executions"><a href="#4-Concurrent-Executions" class="headerlink" title="4. Concurrent Executions"></a>4. Concurrent Executions</h3><p>保证并发调度的一致性</p>
<h3 id="5-Serializability"><a href="#5-Serializability" class="headerlink" title="5. Serializability"></a>5. Serializability</h3><p>并发事务的可能互相影响的时间是在硬盘上的时间。</p>
<p>其他在内存里的事务操作都不会影响</p>
<p>即Read和Write操作</p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220524143124749.png">



<h3 id="6-可恢复性"><a href="#6-可恢复性" class="headerlink" title="6. 可恢复性"></a>6. 可恢复性</h3><p>一个事件可能需要回滚，把所有的操作重新恢复</p>
<p>但是可能会有不可恢复的操作出现</p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220524144503664.png">

<ul>
<li><p>不可恢复的调度</p>
<ul>
<li>这种调度是不被允许的</li>
<li>当一个事务受另一个事务的影响，在另一个事务提交之前这个事务不可以提交</li>
</ul>
</li>
<li><p>级联回滚</p>
<ul>
<li>一个事务的回滚影响后面事务的回滚</li>
<li><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220524144911686.png"></li>
</ul>
</li>
</ul>
<h3 id="7-事务的独立性"><a href="#7-事务的独立性" class="headerlink" title="7. 事务的独立性"></a>7. 事务的独立性</h3><p>两个事件之间加箭头：A→B，在AB和B冲突，且A的操作先执行，如果有一个循环则说明不可变成串行化的</p>
<h2 id="Lecture-13：Concurrency-Control"><a href="#Lecture-13：Concurrency-Control" class="headerlink" title="Lecture 13：Concurrency Control"></a>Lecture 13：Concurrency Control</h2><h3 id="1-Lock-Based-Protocols"><a href="#1-Lock-Based-Protocols" class="headerlink" title="1. Lock-Based Protocols"></a>1. Lock-Based Protocols</h3><p>X锁：读写的锁</p>
<p>S锁：只读的锁</p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220524150048034.png">

<h4 id="锁的协议："><a href="#锁的协议：" class="headerlink" title="锁的协议："></a>锁的协议：</h4><ol>
<li>读之前要获得S锁</li>
<li>写之前要获得X锁</li>
<li>可能存在死锁，如图：<ol>
<li><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220524150257327.png"></li>
</ol>
</li>
</ol>
<h4 id="Starvation-饿死"><a href="#Starvation-饿死" class="headerlink" title="Starvation 饿死"></a>Starvation 饿死</h4><p>设T1拿了A的S锁，</p>
<p>T2想要写A，试图申请A的X锁，但是申请不到</p>
<p>T1释放S之前，T3来了要S(A)，一直这样持续下去</p>
<p>T2一直在等待S的释放（饿死）</p>
<h4 id="两阶段加锁协议"><a href="#两阶段加锁协议" class="headerlink" title="两阶段加锁协议"></a>两阶段加锁协议</h4><p>保证了冲突可串行化</p>
<p><strong>在某个点之前只加锁，不释放锁，在这个点后只释放锁，不加锁。</strong></p>
<ol>
<li>Growing Phase</li>
<li>Shrinking Phase</li>
</ol>
<p>证明：</p>
<p>   假设调度有n个事务，T1、T2…Tn，这些事务的加锁都符合两阶段加锁，且LockPoint递增，假设是不可串行化的，变成有向图会有一个循环。设T1→T2→T1，T2拿到锁，T1应该已经释放了，则说明，T1的LP&lt;T2的LP，同理矛盾了</p>
<ul>
<li>能够保证两阶段加锁则一定可以串行化</li>
<li>但是可串行化不一定就保证了两阶段加锁协议</li>
</ul>
<p>优化：</p>
<ol>
<li>阶段一：获得锁，或者S升级为X</li>
<li>阶段二：释放锁，或者将X降级为S</li>
</ol>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220524153203265.png">

<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220524153216776.png">

<h3 id="2-Lock-Table-锁表"><a href="#2-Lock-Table-锁表" class="headerlink" title="2. Lock Table 锁表"></a>2. Lock Table 锁表</h3><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220524153559055.png">

<h3 id="3-Graph-Based-Protocols"><a href="#3-Graph-Based-Protocols" class="headerlink" title="3. Graph-Based Protocols"></a>3. Graph-Based Protocols</h3><ul>
<li><p>Review ：</p>
<ul>
<li>并发调度和一个串行调度的结果是一样的，那么肯定是冲突可串行化的</li>
<li>遵守两阶段加锁协议，一定是冲突可串行化的，反过来不对</li>
</ul>
</li>
<li><p>Tree Protocol</p>
<ul>
<li><p>树加锁，事务的第一次加锁没有限制，只要锁没有被拿即可</p>
</li>
<li><p>解锁可以在任何时候</p>
</li>
<li><p>要获得一个数据Q的锁，必须要Q的父亲的锁</p>
</li>
<li><p>优点：</p>
<ul>
<li>冲突可串行化</li>
<li>避免死锁</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>要拿一些没有必要的锁</li>
<li>并发度不高</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-基于时间戳的协议Timestamp-Based-Protocol"><a href="#4-基于时间戳的协议Timestamp-Based-Protocol" class="headerlink" title="4. 基于时间戳的协议Timestamp-Based Protocol"></a>4. 基于时间戳的协议Timestamp-Based Protocol</h3><p>每一个事务都有一个时间戳TS：定义为开始执行的时间点</p>
<p>每一个被读写的数据有时间戳：</p>
<ol>
<li>写时间戳：最后一个写操作事务的TS</li>
<li>读时间戳：最后一个读操作事务的TS</li>
</ol>
<h4 id="4-1-读Read-Q"><a href="#4-1-读Read-Q" class="headerlink" title="4.1 读Read(Q)"></a>4.1 读Read(Q)</h4><p>当TS(Ti)&lt;&#x3D;W-timestamp(Q)，那么说明Ti事务执行时，有其他事务写Q，那么就拒绝读，Ti回滚</p>
<p>当TS(Ti)&gt;&#x3D;W-timestamp(Q)，那么说明Ti事务执行前，有其他事务写Q，那么不会影响Ti，读操作执行，R-timestamp(Q)&#x3D;max{R-timestamp(Q),TS(Ti)}</p>
<h4 id="4-2-写Write-Q"><a href="#4-2-写Write-Q" class="headerlink" title="4.2 写Write(Q)"></a>4.2 写Write(Q)</h4><p>当TS(Ti)&lt;R-timestamp(Q)，那么说明Ti事务执行时，有其他事务读Q，那么就要读Q之前的值，Ti的写操作要被拒绝，Ti回滚</p>
<p>当TS(Ti)&lt;W-timestamp(Q)，那么说明Ti事务执行时，有其他事务写Q，写操作被拒绝Ti回滚</p>
<p>其他情况，写操作被执行，W-timestamp(Q)&#x3D;TS(Ti)</p>
<h3 id="5-意向锁Intention-Lock-Modes"><a href="#5-意向锁Intention-Lock-Modes" class="headerlink" title="5. 意向锁Intention Lock Modes"></a>5. 意向锁Intention Lock Modes</h3><ul>
<li>IS共享型意向锁：后代至少有一个有S锁，并不知道是哪个</li>
<li>IX排他型意向锁：后代至少一个有X锁</li>
<li>SIX共享排他型意向锁：后代全部被加了S锁，至少一个被加上了X锁<ul>
<li>SIX&#x3D;S+IX</li>
</ul>
</li>
</ul>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220531135157496.png">

<ul>
<li><p>加锁的允许性：</p>
<ul>
<li>可以直接从根开始判断是否可以加锁</li>
<li>加锁矩阵</li>
<li><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220531135404571.png"></li>
<li>只要可能加得上就可以通过，在下面继续判断，如加IS锁时，一个节点是IX锁，那么有可能这个节点的子节点有一个没有锁的就可以加IS锁，就通过了。</li>
</ul>
</li>
<li><p>加锁自上而下</p>
</li>
<li><p>解锁自下而上</p>
</li>
</ul>
<h3 id="6-Deadlock-Handling"><a href="#6-Deadlock-Handling" class="headerlink" title="6. Deadlock Handling"></a>6. Deadlock Handling</h3><p>死锁如何解决？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T1: <span class="built_in">Write</span>(X),<span class="built_in">Write</span>(Y)</span><br><span class="line">T2: <span class="built_in">Write</span>(Y),<span class="built_in">write</span>(X)</span><br></pre></td></tr></table></figure>

<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220531141654000.png">

<p>死锁预防协议确保系统永远不会进入死锁状态。</p>
<p>一些预防策略:</p>
<ul>
<li><p>1)要求每个事务在开始执行之前锁定它的所有数据项(预声明)——保守2PL。(全部或没有被锁定)</p>
<ul>
<li>缺点:并发性差，难以预测</li>
</ul>
</li>
<li><p>2)对所有数据项进行部分排序，要求事务只能按顺序锁定数据项(基于图的协议)。—-因此永远不要形成循环。</p>
</li>
</ul>
<h4 id="6-1-Prevention"><a href="#6-1-Prevention" class="headerlink" title="6.1 Prevention"></a>6.1 Prevention</h4><ul>
<li>Wait-die<ul>
<li>老事务试图拿锁，锁在新事务中，老事务等新事务的锁；新事务试图拿锁，新事务直接die，进行rollback</li>
<li>新事务会变成老事务，事务在获得数据前可能会die几次</li>
</ul>
</li>
<li>Wound-wait<ul>
<li>老事务要锁，锁在新事务时，新事务要rollback，把锁给老事务。新事务可能等老事务的锁。</li>
<li>新事务die的次数更少</li>
</ul>
</li>
</ul>
<h4 id="6-2-死锁的判断"><a href="#6-2-死锁的判断" class="headerlink" title="6.2 死锁的判断"></a>6.2 死锁的判断</h4><h5 id="wait-for-graph"><a href="#wait-for-graph" class="headerlink" title="wait-for graph"></a>wait-for graph</h5><p>Ti→Tj表示Ti在等Tj的锁被释放</p>
<p>如果有有向图中有环，那么有死锁</p>
<h4 id="6-3-Deadlock-Recovery"><a href="#6-3-Deadlock-Recovery" class="headerlink" title="6.3 Deadlock Recovery"></a>6.3 Deadlock Recovery</h4><p>有些事务要rollback，要选择一个事务作为victim：</p>
<p>锁多的or锁少的</p>
<p>Rollback–rollback的方式</p>
<ol>
<li>Total rollback</li>
<li>Partial rollback</li>
</ol>
<h3 id="7-Insert-and-Delete-Operations"><a href="#7-Insert-and-Delete-Operations" class="headerlink" title="7. Insert and Delete Operations"></a>7. Insert and Delete Operations</h3><ul>
<li><p>如果使用两相锁</p>
<ul>
<li>删除元组的事务对要删除的元组有排他锁时，才可以执行删除操作。</li>
<li>向数据库中插入新元组的事务被赋予元组上的x模式锁</li>
</ul>
</li>
<li><p>插入和删除可以导致幻影现象。</p>
<ul>
<li>扫描关系的事务<ul>
<li>(例如，找出Perryridge所有账户的余额总和)以及在关系中插入元组的事务</li>
<li>(例如，在Perryridge开设新帐户)(概念上)冲突，尽管没有访问任何共同的元组。</li>
</ul>
</li>
<li>如果只使用元组锁，可能会导致不可序列化的调度例如，扫描事务不会看到新的帐户，而是读取更新事务写入的其他一些元组</li>
</ul>
</li>
<li><p>扫描关系的事务读取指示关系包含哪些元组的信息，而插入元组的事务更新相同的信息。</p>
<ul>
<li>信息应该被锁定。</li>
</ul>
</li>
<li><p>一个解决办法:</p>
<ul>
<li>将数据项与关系关联，以表示有关关系包含哪些元组的信息。</li>
<li>扫描关系的事务获取数据项中的共享锁。</li>
<li>插入或删除元组的事务会获得数据项上的排他锁。(注意:数据项上的锁不会与单个元组上的锁冲突。)</li>
</ul>
</li>
<li><p>上面的协议为插入&#x2F;删除提供了非常低的并发性。</p>
</li>
<li><p>索引锁定协议提供了更高的并发性，同时通过要求在某些索引桶上加锁来防止幻影现象。</p>
</li>
</ul>
<h4 id="7-1-Index-Locking-Protocol"><a href="#7-1-Index-Locking-Protocol" class="headerlink" title="7.1 Index Locking Protocol"></a>7.1 Index Locking Protocol</h4><h5 id="基于索引的加锁协议"><a href="#基于索引的加锁协议" class="headerlink" title="基于索引的加锁协议"></a>基于索引的加锁协议</h5><p>基于某个属性的索引的加锁（如dept&#x3D;”phy”），在查询、求和（select count(*) from r where dept&#x3D;’phy’）等操作时，对应的数据被锁住，insert和delete在该index上无法进行。</p>
<h2 id="Letuce-14-Recovery-System"><a href="#Letuce-14-Recovery-System" class="headerlink" title="Letuce 14 Recovery System"></a>Letuce 14 Recovery System</h2><h3 id="1-Failure-Classification"><a href="#1-Failure-Classification" class="headerlink" title="1. Failure Classification"></a>1. Failure Classification</h3><ol>
<li><p>Transaction failure</p>
<ol>
<li>Logical errors：overflow…</li>
<li>system errors：deadlock…</li>
</ol>
</li>
<li><p>System Crash</p>
<p>整个数据库系统死了，如停电、操作系统死了等…</p>
<p>重启后数据还在</p>
</li>
<li><p>Disk Failure</p>
<p>硬盘损坏，数据丢失等…</p>
</li>
</ol>
<h4 id="1-1-Recovery-Algorithm"><a href="#1-1-Recovery-Algorithm" class="headerlink" title="1.1 Recovery Algorithm"></a>1.1 Recovery Algorithm</h4><p>确保事务要么提交、要么rollback</p>
<ol>
<li>正常的没出现failure时做一些准备</li>
<li>出现了failure进行恢复，确保原子性、一致性和持久性</li>
</ol>
<h3 id="2-Storage-Structure"><a href="#2-Storage-Structure" class="headerlink" title="2. Storage Structure"></a>2. Storage Structure</h3><ol>
<li>Volatile Storage 易失性<ol>
<li>main memory，cache memory</li>
</ol>
</li>
<li>Nonvolatile Storage 非易失性<ol>
<li>日志要存在这里面</li>
<li>disk、tape、flash memory</li>
</ol>
</li>
</ol>
<h4 id="2-1-Stable-Storage-Implementation"><a href="#2-1-Stable-Storage-Implementation" class="headerlink" title="2.1 Stable-Storage Implementation"></a>2.1 Stable-Storage Implementation</h4><h5 id="Maintain-multiple-copies-of-each-block-on-separate-disks"><a href="#Maintain-multiple-copies-of-each-block-on-separate-disks" class="headerlink" title="Maintain multiple copies of each block on separate disks"></a>Maintain multiple copies of each block on separate disks</h5><p>多存几份数据</p>
<h4 id="2-2-Data-Access"><a href="#2-2-Data-Access" class="headerlink" title="2.2 Data Access"></a>2.2 Data Access</h4><p>Physical Blocks是在硬盘里的</p>
<p>Buffer Blocks 是在main memory里的</p>
<p>有input 和 output 在两个区之间传输block</p>
<p>在事务执行时，Ti有自己独立的工作区，里面的数据是从buffer中复制的，设buffer中数据是X，Ti工作区内为Xi，read(X)是把Xi的值赋值为X，write(X)把X的值写成了Xi，但是output不一定马上执行，这样会很慢，在写入disk可以在buffer满时写入。</p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220531151548281.png">

<h3 id="3-Recovery-and-Atomicity"><a href="#3-Recovery-and-Atomicity" class="headerlink" title="3. Recovery and Atomicity"></a>3. Recovery and Atomicity</h3><h3 id="4-基于日志的恢复协议log-based-recovery-mechanisms"><a href="#4-基于日志的恢复协议log-based-recovery-mechanisms" class="headerlink" title="4. 基于日志的恢复协议log-based recovery mechanisms"></a>4. 基于日志的恢复协议log-based recovery mechanisms</h3><p>log只事务的开始、记录写回的东西、事务的提交</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Ti,start&gt;<span class="regexp">//</span>T1开始了</span><br><span class="line">&lt;Ti,X,V1,V2&gt;<span class="regexp">//</span>T1把X从V1改到V2</span><br><span class="line">&lt;Ti,commit&gt;<span class="regexp">//</span>T1提交了</span><br></pre></td></tr></table></figure>

<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220531153600226.png">

<p>只有commit之后的值需要改，否则不需要修改硬盘的值。</p>
<p>直接修改数据库立即修改方案允许在事务提交之前，将未提交的事务更新到缓冲区或磁盘本身</p>
<p>我们假设日志记录是直接输出到稳定存储(稍后将看到如何在某种程度上延迟日志记录输出)</p>
<p>可以在事务提交之前或之后的任何时候将更新的块输出到稳定存储块的输出顺序可以与它们的写入顺序不同。</p>
<h4 id="4-1-恢复算法"><a href="#4-1-恢复算法" class="headerlink" title="4.1 恢复算法"></a>4.1 恢复算法</h4><ol>
<li><p>undo</p>
<p>把没有提交的事务回滚，有start，但是没有commit或abort</p>
</li>
<li><p>redo</p>
<p>把修改重新做，有start，有commit或abort，为什么要redo？因为我们不知道commit后有没有写到磁盘上，我们就再修改一次。</p>
</li>
</ol>
<h5 id="4-1-1-CheckPoint"><a href="#4-1-1-CheckPoint" class="headerlink" title="4.1.1 CheckPoint"></a>4.1.1 CheckPoint</h5><p>检查点的引入，我们不清楚什么时候写到硬盘上，因此</p>
<ol>
<li>我们的搜索过程太耗时</li>
<li>大多数的重做事务已经写入硬盘了，但是还是要重做，使得恢复时间变长</li>
</ol>
<p>检查点的机制</p>
<p>   在检查点操作过程中不允许执行任何更新，在执行检查点的过程中所有的缓存全部写到硬盘上。执行过程：</p>
<ul>
<li>将位于主存的所有日志记录输出到稳定储存器；</li>
<li>所有修改过的缓冲块输出到硬盘。</li>
<li>在日志中加入<checkpoint l>的日志记录，L是活跃状态的事务列表。</checkpoint></li>
</ul>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220607133237102.png">

<h5 id="4-1-2-恢复处理"><a href="#4-1-2-恢复处理" class="headerlink" title="4.1.2 恢复处理"></a>4.1.2 恢复处理</h5><p>要找到哪些事务被正常提交了，哪些没有被提交。</p>
<p>正常提交：redo</p>
<p>没有提交：undo</p>
<h5 id="第一步：找list"><a href="#第一步：找list" class="headerlink" title="第一步：找list"></a>第一步：找list</h5><ol>
<li>初始化undolist和redolist</li>
<li>从break掉的地方开始往回找，到checkpoint</li>
<li>某些日志commit了就把T放入redolist</li>
<li>某个日志start了，但是不在redolist，加入undolist</li>
<li>某个日志abort了，加入undolist</li>
<li>所有的Ti不在redolist中就放入undolist中</li>
<li>现在我们得到了undolist和redolist</li>
</ol>
<h5 id="第二步：进行undo"><a href="#第二步：进行undo" class="headerlink" title="第二步：进行undo"></a>第二步：进行undo</h5><ol>
<li>回倒，回滚</li>
<li>直到undolist中事务的start，不是到checkpoint就可以了</li>
</ol>
<h5 id="第三步：进行redo"><a href="#第三步：进行redo" class="headerlink" title="第三步：进行redo"></a>第三步：进行redo</h5><ol>
<li>从checkpoint开始redo，因为checkpoint已经写在硬盘上了</li>
</ol>
<h4 id="4-2-Buffer-Management-—Log-Record-Buffering"><a href="#4-2-Buffer-Management-—Log-Record-Buffering" class="headerlink" title="4.2 Buffer Management —Log Record Buffering"></a>4.2 Buffer Management —Log Record Buffering</h4><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220607134623926.png">

<p>日志数据更重要。</p>
<p>只有Ti commit这条日志写到硬盘上，Ti才算提交了。</p>
<p>先写日志规则。</p>
<h5 id="No-Force-Policy"><a href="#No-Force-Policy" class="headerlink" title="No-Force Policy"></a>No-Force Policy</h5><p>Force Policy：commit的时候同时写到硬盘上，花费很大</p>
<p>Steal Policy：恢复算法支持窃取策略，也就是说，包含未提交事务更新的块可以被写入磁盘，甚至在事务提交之前</p>
<p>当有未提交更新的块被输出到磁盘时，带更新撤销信息的日志记录会先输出到稳定存储的日志中(提前写日志)</p>
<p>当一个块输出到磁盘时，它不应该有任何更新正在进行。可以保证如下。</p>
<ol>
<li>在写入数据项之前，事务获取包含该数据项的块上的独占锁</li>
<li>一旦写操作完成，锁就可以被释放。</li>
<li>这种保持时间较短的锁称为锁存。</li>
</ol>
<p>将一个块输出到磁盘</p>
<ol>
<li>首先获得一个专属的门闩</li>
<li>确保块上没有正在进行的更新</li>
<li>然后执行日志刷新</li>
<li>然后将块输出到磁盘</li>
<li>最后松开木块上的门闩</li>
</ol>
<p>数据库缓冲区也可以实现</p>
<ol>
<li>在为数据库预留的实际主内存区域中，或者在虚拟内存中</li>
</ol>
<p>在保留的主内存中实现缓冲区有缺点:</p>
<ol>
<li>内存事先在数据库缓冲区和应用程序之间进行分区，限制了灵活性。</li>
<li>需求可能会改变，尽管操作系统在任何时候都最清楚应该如何划分内存，但它不能改变内存的分区。</li>
</ol>
<h3 id="5-Advanced-Recovery-Techniques"><a href="#5-Advanced-Recovery-Techniques" class="headerlink" title="5. Advanced Recovery Techniques"></a>5. Advanced Recovery Techniques</h3><h5 id="支持高并发锁定技术"><a href="#支持高并发锁定技术" class="headerlink" title="支持高并发锁定技术"></a>支持高并发锁定技术</h5><p>例如用于B +树并发控制</p>
<h6 id="像B-tree插入和删除这样的操作会提前释放锁。"><a href="#像B-tree插入和删除这样的操作会提前释放锁。" class="headerlink" title="像B*-tree插入和删除这样的操作会提前释放锁。"></a>像B*-tree插入和删除这样的操作会提前释放锁。</h6><p>它们不能通过恢复旧值(物理撤销)来撤销，因为一旦一个锁被释放，其他事务可能已经更新了B+树。</p>
<p>相反,插入(分别地。删除)通过执行删除(对应的。插入操作(称为逻辑撤消)。</p>
<h6 id="对于此类操作，需要在undo日志记录中记录需要执行的undo操作"><a href="#对于此类操作，需要在undo日志记录中记录需要执行的undo操作" class="headerlink" title="对于此类操作，需要在undo日志记录中记录需要执行的undo操作"></a>对于此类操作，需要在undo日志记录中记录需要执行的undo操作</h6><p>与物理撤消日志记录相反，称为逻辑撤消日志记录。</p>
<h6 id="即使对于这样的操作，重做信息也会被物理地记录下来-即，每次写入的新值"><a href="#即使对于这样的操作，重做信息也会被物理地记录下来-即，每次写入的新值" class="headerlink" title="即使对于这样的操作，重做信息也会被物理地记录下来(即，每次写入的新值)"></a>即使对于这样的操作，重做信息也会被物理地记录下来(即，每次写入的新值)</h6><p>逻辑重做非常复杂，因为磁盘上的数据库状态可能不是“操作一致”的。</p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220607140505401.png">

<p>逻辑日志记录更改情况，比物理日志更好，可以实现交互。恢复时执行且执行一次。</p>
<h5 id="Fuzzy-CheckPoint"><a href="#Fuzzy-CheckPoint" class="headerlink" title="Fuzzy CheckPoint"></a>Fuzzy CheckPoint</h5><p>模糊检查点：</p>
<ul>
<li>由于普通的检查点会呆在那里写硬盘，所以要避免这个问题。在没有请求的时候写入，即加入一个可选择的写入时间。</li>
<li>还是有一堆checkpoint，把要做的事情记录下来，但是不是真的干，等到数据库有空的时候再做，在last checkpoint上加一个指针，指向最后干完的checkpoint。</li>
</ul>
<h3 id="6-ARIES"><a href="#6-ARIES" class="headerlink" title="6. ARIES"></a>6. ARIES</h3><ol>
<li>每条日志有个编号LSN</li>
<li>是一个逻辑日志</li>
<li>维护一个Dirty Page，只关注内存和硬盘不同的block</li>
<li>Fuzzy checkpoint只管制dirty page，不要求dirty page再checkpoint立即写入</li>
</ol>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220607143045708.png">

<h4 id="6-1-PageLSN"><a href="#6-1-PageLSN" class="headerlink" title="6.1 PageLSN"></a>6.1 PageLSN</h4><p>PageLSN是一个page的最后一次的log的LSN。</p>
<p>要修改一个Page</p>
<ol>
<li>拿一把Xlock</li>
<li>update the page</li>
<li>把PageLSN更新</li>
<li>unlock</li>
</ol>
<h4 id="6-2-Dirty-Page-Table"><a href="#6-2-Dirty-Page-Table" class="headerlink" title="6.2 Dirty Page Table"></a>6.2 Dirty Page Table</h4><img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220607143223201.png">

<p>RecLSN最早的没写进硬盘的LSN</p>
<img src="/Learning/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220607143620363.png">


        <hr>
        <!-- Pager -->
        <ul class="pager">
          
          <li class="previous">
            <a href="/Learning/OOP笔记/" data-toggle="tooltip" data-placement="top" title="OOP笔记">&larr; Previous Post</a>
          </li>
          
          
        </ul>

        
        <!-- tip start -->
        <!-- tip -->
<!-- tip start -->
<div class="tip">
  <p>
    
      如果您喜欢此博客或发现它对您有用，则欢迎对此发表评论。 也欢迎您共享此博客，以便更多人可以参与。 如果博客中使用的图像侵犯了您的版权，请与作者联系以将其删除。 谢谢 ！
    
  </p>
</div>
<!-- tip end -->

        <!-- tip end -->
        

        
        <!-- Sharing Srtart -->
        <!-- Social Social Share Post -->
<!-- Docs:https://github.com/overtrue/share.js -->

<div class="social-share" data-initialized="true" data-disabled="tencent ,douban ,qzone ,linkedin ,facebook ,google ,diandian" data-wechat-qrcode-helper="" align="center">
  <ul class="list-inline text-center social-share-ul">
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon icon-twitter">
        <i class="fa fa-twitter fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a class="social-share-icon icon-wechat">
        <i class="fa fa-weixin fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon icon-weibo">
        <i class="fa fa-weibo fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon icon-qq">
        <i class="fa fa-qq fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon" href="mailto:?subject=数据库系统笔记&body=Hi,I found this website and thought you might like it http://Hualingz.cn/Learning/数据库系统笔记/">
        <i class="fa fa-envelope fa-1x" aria-hidden="true"></i>
      </a>
    </li>
  </ul>
</div>

<!-- css & js -->
<!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css"> -->
<script defer="defer" async="true" src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>

        <!-- Sharing End -->
        
        <hr>

        <!-- comments start -->
        <!-- 1. gitalk comment -->

  <!-- gitalk start -->
  <!-- Docs:https://github.com/gitalk/gitalk/blob/master/readme-cn.md -->

  <div id="gitalk-container"></div>

  
    <!-- <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.js"></script> -->
    <script src="/js/comment/gitalk.js"></script>
  

  <script>
    var gitalk = new Gitalk({
      clientID: '',
      clientSecret: '',
      repo: '',
      owner: '',
      admin: '',
      id: 'Sat Jun 25 2022 23:32:17 GMT+0800', // Ensure uniqueness and length less than 50
      distractionFreeMode: false, // Facebook-like distraction free mode
      perPage: 10,
      pagerDirection: 'last',
      createIssueManually: false,
      language: 'en',
      proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token'
    });
    gitalk.render('gitalk-container');

    var gtFolded = () => {
      setTimeout(function () {
        let markdownBody = document.getElementsByClassName("markdown-body");
        let list = Array.from(markdownBody);
        list.forEach(item => {
          if (item.clientHeight > 250) {
            item.classList.add('gt-comment-body-folded');
            item.style.maxHeight = '250px';
            item.title = 'Click to Expand';
            item.onclick = function () {
              item.classList.remove('gt-comment-body-folded');
              item.style.maxHeight = '';
              item.title = '';
              item.onclick = null;
            };
          }
        })
      }, 800);
    }
  </script>

  <!-- gitalk end -->


<!-- 2. gitment comment -->


<!-- 3. disqus comment -->


        <!-- comments end -->
        <hr>

      </div>

      <!-- Catalog: Tabe of Content -->
      <!-- Table of Contents -->

    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">目录</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-Entity-Sets"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">1. Entity Sets</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-1-Entity-Sets%E5%AE%9E%E4%BD%93%E9%9B%86%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-nav-number">1.0.1.</span> <span class="toc-nav-text">1.1 Entity Sets实体集的定义</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-2-Attributes%E5%B1%9E%E6%80%A7"><span class="toc-nav-number">1.0.2.</span> <span class="toc-nav-text">1.2 Attributes属性</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-Relationship-Sets"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">2.  Relationship Sets</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-1-%E5%85%B3%E7%B3%BB%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-nav-number">2.0.1.</span> <span class="toc-nav-text">2.1 关系的表示</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#2-1-1-%E9%9B%86%E5%90%88%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-nav-number">2.0.1.1.</span> <span class="toc-nav-text">2.1.1 集合的表示</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#2-1-2-table%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-nav-number">2.0.1.2.</span> <span class="toc-nav-text">2.1.2 table中的表示</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-2-Degree%E5%85%B3%E7%B3%BB%E9%9B%86%E7%9A%84%E5%BA%A6"><span class="toc-nav-number">2.0.2.</span> <span class="toc-nav-text">2.2 Degree关系集的度</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-3-Mapping-Cardinalities%E6%98%A0%E5%B0%84%E5%9F%BA%E6%95%B0"><span class="toc-nav-number">2.0.3.</span> <span class="toc-nav-text">2.3 Mapping Cardinalities映射基数</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-Keys"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">3. Keys</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-1-%E5%AE%9E%E4%BD%93%E9%9B%86%E7%9A%84keys"><span class="toc-nav-number">3.0.1.</span> <span class="toc-nav-text">3.1 实体集的keys</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-2-%E5%85%B3%E7%B3%BB%E9%9B%86%E7%9A%84keys"><span class="toc-nav-number">3.0.2.</span> <span class="toc-nav-text">3.2 关系集的keys</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-E-R-Diagrams"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">4. E-R Diagrams</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-2-%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B1%9E%E6%80%A7%E8%A1%A8%E8%BE%BE"><span class="toc-nav-number">4.0.1.</span> <span class="toc-nav-text">4.2 不同类型的属性表达</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-3-%E5%85%B3%E7%B3%BB%E9%9B%86%E7%9A%84%E5%B1%9E%E6%80%A7%E7%9A%84%E8%A1%A8%E8%BE%BE"><span class="toc-nav-number">4.0.2.</span> <span class="toc-nav-text">4.3 关系集的属性的表达</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-4-%E8%87%AA%E5%85%B3%E7%B3%BB%E5%92%8CRole%E7%9A%84%E8%A1%A8%E8%BE%BE"><span class="toc-nav-number">4.0.3.</span> <span class="toc-nav-text">4.4 自关系和Role的表达</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-5-%E6%98%A0%E5%B0%84%E5%9F%BA%E6%95%B0%E7%9A%84%E8%A1%A8%E8%BE%BE"><span class="toc-nav-number">4.0.4.</span> <span class="toc-nav-text">4.5 映射基数的表达</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-6-%E5%85%A8%E5%8F%82%E4%B8%8E%E4%B8%8E%E9%83%A8%E5%88%86%E5%8F%82%E4%B8%8E"><span class="toc-nav-number">4.0.5.</span> <span class="toc-nav-text">4.6 全参与与部分参与</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-7-%E5%85%B3%E7%B3%BB%E7%BA%A6%E6%9D%9F%E7%9A%84%E6%9B%BF%E4%BB%A3%E4%BF%A1%E5%8F%B7"><span class="toc-nav-number">4.0.6.</span> <span class="toc-nav-text">4.7 关系约束的替代信号</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-8-%E5%A4%9A%E5%85%83%E5%85%B3%E7%B3%BB"><span class="toc-nav-number">4.0.7.</span> <span class="toc-nav-text">4.8 多元关系</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#5-Weak-Entity-Sets"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">5. Weak Entity Sets</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#6-Extended-E-R-Features"><span class="toc-nav-number">6.</span> <span class="toc-nav-text">6. Extended E-R Features</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#6-1-Specialization-%E7%89%B9%E6%AE%8A%E5%8C%96%E3%80%81%E5%85%B7%E4%BD%93%E5%8C%96"><span class="toc-nav-number">6.0.1.</span> <span class="toc-nav-text">6.1 Specialization(特殊化、具体化)</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#6-2-Generalization-%E6%B3%9B%E5%8C%96%E3%80%81%E6%99%AE%E9%81%8D%E5%8C%96"><span class="toc-nav-number">6.0.2.</span> <span class="toc-nav-text">6.2 Generalization(泛化、普遍化)</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#6-3-Specialization%E5%92%8CGeneralization%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E5%BC%8F"><span class="toc-nav-number">6.0.3.</span> <span class="toc-nav-text">6.3 Specialization和Generalization的设计方式</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#6-4-Aggregation%E8%81%9A%E5%90%88"><span class="toc-nav-number">6.0.4.</span> <span class="toc-nav-text">6.4 Aggregation聚合</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#6-5-ER%E5%9B%BE%E7%9A%84%E6%95%B4%E7%90%86"><span class="toc-nav-number">6.0.5.</span> <span class="toc-nav-text">6.5 ER图的整理</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#7-Design-of-an-E-R-Database-Schema"><span class="toc-nav-number">7.</span> <span class="toc-nav-text">7. Design of an E-R Database Schema</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#8-Reduction-of-an-E-R-Schema-to-Tables"><span class="toc-nav-number">8.</span> <span class="toc-nav-text">8. Reduction of an E-R Schema to Tables</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#8-1-%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95"><span class="toc-nav-number">8.0.1.</span> <span class="toc-nav-text">8.1 表示方法</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#8-2-%E8%A1%A8%E7%9A%84%E5%86%97%E4%BD%99%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-nav-number">8.0.2.</span> <span class="toc-nav-text">8.2 表的冗余的处理</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#8-3-Specialization%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-nav-number">8.0.3.</span> <span class="toc-nav-text">8.3 Specialization的表示</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#9-Relational-Database-Design"><span class="toc-nav-number">9.</span> <span class="toc-nav-text">9: Relational Database Design</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-First-Normal-Form"><span class="toc-nav-number">9.1.</span> <span class="toc-nav-text">1. First Normal Form</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-Pitfalls-in-Relational-Database-Design"><span class="toc-nav-number">9.2.</span> <span class="toc-nav-text">2. Pitfalls in Relational Database Design</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-1-%E9%94%99%E8%AF%AF%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-nav-number">9.2.1.</span> <span class="toc-nav-text">2.1 错误的设计</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-2-%E5%88%86%E8%A7%A3"><span class="toc-nav-number">9.2.2.</span> <span class="toc-nav-text">2.2 分解</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-Functional-Dependencies"><span class="toc-nav-number">9.3.</span> <span class="toc-nav-text">3. Functional Dependencies</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-1-%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E6%80%A7%E5%92%8Ckey%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-nav-number">9.3.1.</span> <span class="toc-nav-text">3.1 函数依赖性和key的关系</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-2-%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E6%80%A7%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-nav-number">9.3.2.</span> <span class="toc-nav-text">3.2 函数依赖性的应用</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#3-2-1-%E5%B9%B3%E5%87%A1%E5%92%8C%E9%9D%9E%E5%B9%B3%E5%87%A1%E7%9A%84%E4%BE%9D%E8%B5%96%E6%80%A7%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-nav-number">9.3.2.1.</span> <span class="toc-nav-text">3.2.1 平凡和非平凡的依赖性的定义</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#3-2-2-%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E6%80%A7%E7%9A%84%E9%97%AD%E5%8C%85"><span class="toc-nav-number">9.3.2.2.</span> <span class="toc-nav-text">3.2.2 函数依赖性的闭包</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#3-2-3-%E5%A6%82%E4%BD%95%E6%89%BE%E9%97%AD%E5%8C%85%EF%BC%9F"><span class="toc-nav-number">9.3.2.3.</span> <span class="toc-nav-text">3.2.3 如何找闭包？</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#3-2-4-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%ADa%E6%98%AF%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AAsuperkey%EF%BC%9F"><span class="toc-nav-number">9.3.2.4.</span> <span class="toc-nav-text">3.2.4 如何判断a是不是一个superkey？</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#3-2-5-%E7%94%BB%E5%9B%BE%E6%89%BE%E9%97%AD%E5%8C%85%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-nav-number">9.3.2.5.</span> <span class="toc-nav-text">3.2.5 画图找闭包的方法</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-3-%E5%B1%9E%E6%80%A7%E9%97%AD%E5%8C%85%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-nav-number">9.3.3.</span> <span class="toc-nav-text">3.3 属性闭包的总结</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-4-Canonical-Cover%E6%AD%A3%E5%88%99%E8%A6%86%E7%9B%96"><span class="toc-nav-number">9.3.4.</span> <span class="toc-nav-text">3.4 Canonical Cover正则覆盖</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-Decomposition"><span class="toc-nav-number">9.4.</span> <span class="toc-nav-text">4. Decomposition</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-1-%E5%88%86%E8%A7%A3%E7%9A%84%E8%A6%81%E7%82%B9"><span class="toc-nav-number">9.4.1.</span> <span class="toc-nav-text">4.1 分解的要点</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#4-1-1-%E6%97%A0%E6%8D%9F%E5%88%86%E8%A7%A3%E7%9A%84%E8%A6%81%E7%82%B9"><span class="toc-nav-number">9.4.1.1.</span> <span class="toc-nav-text">4.1.1 无损分解的要点</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#4-1-2-%E4%BE%9D%E8%B5%96%E4%BF%9D%E6%8C%81"><span class="toc-nav-number">9.4.1.2.</span> <span class="toc-nav-text">4.1.2 依赖保持</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-Boyce-Codd-Normal-Form"><span class="toc-nav-number">9.5.</span> <span class="toc-nav-text">5. Boyce-Codd Normal Form</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#5-1-%E8%A1%A8%E7%9A%84BCNF%E7%9A%84%E9%AA%8C%E8%AF%81"><span class="toc-nav-number">9.5.1.</span> <span class="toc-nav-text">5.1 表的BCNF的验证</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#5-2-%E5%A6%82%E4%BD%95%E5%88%86%E8%A7%A3%E4%B8%BABC%E8%8C%83%E5%BC%8F"><span class="toc-nav-number">9.5.2.</span> <span class="toc-nav-text">5.2 如何分解为BC范式</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#5-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E4%B8%8D%E7%94%A8BCNF%EF%BC%9F"><span class="toc-nav-number">9.5.3.</span> <span class="toc-nav-text">5.2 为什么有时不用BCNF？</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-Third-Normal-Form"><span class="toc-nav-number">9.6.</span> <span class="toc-nav-text">6. Third Normal Form</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#6-1-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F"><span class="toc-nav-number">9.6.1.</span> <span class="toc-nav-text">6.1 如何构建第三范式</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#7-Multivalued-Dependencies"><span class="toc-nav-number">9.7.</span> <span class="toc-nav-text">7. Multivalued Dependencies</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#7-1-%E5%A4%9A%E5%80%BC%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BBMVDs"><span class="toc-nav-number">9.7.1.</span> <span class="toc-nav-text">7.1 多值依赖关系MVDs</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#8-Fourth-Normal-Form"><span class="toc-nav-number">9.8.</span> <span class="toc-nav-text">8. Fourth Normal Form</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#10-Storage-and-File-Structure"><span class="toc-nav-number">10.</span> <span class="toc-nav-text">10: Storage and File Structure</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-Overview-of-Physical-Storage-Media"><span class="toc-nav-number">10.1.</span> <span class="toc-nav-text">1. Overview of Physical Storage Media</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-1-%E5%88%86%E7%B1%BB"><span class="toc-nav-number">10.1.1.</span> <span class="toc-nav-text">1.1 分类</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-2-Storage-Hierarchy%E5%82%A8%E5%AD%98%E5%B1%82%E6%AC%A1"><span class="toc-nav-number">10.1.2.</span> <span class="toc-nav-text">1.2 Storage Hierarchy储存层次</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-Magnetic-Disk%E7%A3%81%E7%9B%98"><span class="toc-nav-number">10.2.</span> <span class="toc-nav-text">2. Magnetic Disk磁盘</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-1-Disk%E7%9A%84%E6%80%A7%E8%83%BD%E8%A1%A1%E9%87%8F"><span class="toc-nav-number">10.2.1.</span> <span class="toc-nav-text">2.1 Disk的性能衡量</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-2-Block"><span class="toc-nav-number">10.2.2.</span> <span class="toc-nav-text">2.2 Block</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-3-Disk-arm-scheduling-algorithm%E7%A3%81%E7%9B%98%E8%87%82%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-nav-number">10.2.3.</span> <span class="toc-nav-text">2.3 Disk-arm-scheduling algorithm磁盘臂调度算法</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-RAID"><span class="toc-nav-number">10.3.</span> <span class="toc-nav-text">3. RAID</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-1-RAID"><span class="toc-nav-number">10.3.1.</span> <span class="toc-nav-text">3.1 RAID</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-2-Reliability"><span class="toc-nav-number">10.3.2.</span> <span class="toc-nav-text">3.2 Reliability</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-3-RAID-Levels"><span class="toc-nav-number">10.3.3.</span> <span class="toc-nav-text">3.3 RAID Levels</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-4-RAID-Level%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-nav-number">10.3.4.</span> <span class="toc-nav-text">3.4 RAID Level的选择</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-Tertiary-storage%E5%85%89%E7%9B%98%E5%92%8C%E7%A3%81%E5%B8%A6"><span class="toc-nav-number">10.4.</span> <span class="toc-nav-text">4. Tertiary storage光盘和磁带</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-Storage-Access"><span class="toc-nav-number">10.5.</span> <span class="toc-nav-text">5. Storage Access</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#5-1-Buffer-Manager"><span class="toc-nav-number">10.5.1.</span> <span class="toc-nav-text">5.1 Buffer Manager</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#5-1-1-%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%A2%E5%BC%83%E7%AD%96%E7%95%A5"><span class="toc-nav-number">10.5.1.1.</span> <span class="toc-nav-text">5.1.1 缓冲区丢弃策略</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-File-Organization"><span class="toc-nav-number">10.6.</span> <span class="toc-nav-text">6. File Organization</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#6-1-%E5%AE%9A%E9%95%BF%E7%9A%84Records"><span class="toc-nav-number">10.6.1.</span> <span class="toc-nav-text">6.1 定长的Records</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#6-2-%E5%8F%98%E9%95%BF%E7%9A%84Records"><span class="toc-nav-number">10.6.2.</span> <span class="toc-nav-text">6.2 变长的Records</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#7-Organization-of-Records-in-Files"><span class="toc-nav-number">10.7.</span> <span class="toc-nav-text">7. Organization of Records in Files</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#8-Data-Dictionary-Storage"><span class="toc-nav-number">10.8.</span> <span class="toc-nav-text">8. Data-Dictionary Storage</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#11%EF%BC%9AIndexing-and-Hashing"><span class="toc-nav-number">11.</span> <span class="toc-nav-text">11：Indexing and Hashing</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-Basic-Concepts"><span class="toc-nav-number">11.1.</span> <span class="toc-nav-text">1. Basic Concepts</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-Ordered-Indices"><span class="toc-nav-number">11.2.</span> <span class="toc-nav-text">2. Ordered Indices</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-B-%E6%A0%91"><span class="toc-nav-number">11.3.</span> <span class="toc-nav-text">3. B+树</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-B%E6%A0%91Index-Files"><span class="toc-nav-number">11.4.</span> <span class="toc-nav-text">4. B树Index Files</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-Static-Hashing-%E9%9D%99%E6%80%81%E5%93%88%E5%B8%8C"><span class="toc-nav-number">11.5.</span> <span class="toc-nav-text">5. Static Hashing 静态哈希</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-Write-optimized-Indices"><span class="toc-nav-number">11.6.</span> <span class="toc-nav-text">6. Write-optimized Indices</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#LSM%E6%A0%91%E7%B4%A2%E5%BC%95"><span class="toc-nav-number">11.6.1.</span> <span class="toc-nav-text">LSM树索引</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Buffer-Tree"><span class="toc-nav-number">11.6.2.</span> <span class="toc-nav-text">Buffer Tree</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#7-Bitmap-Indices"><span class="toc-nav-number">11.7.</span> <span class="toc-nav-text">7. Bitmap Indices</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#12%EF%BC%9AQuery-Processing-%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86"><span class="toc-nav-number">12.</span> <span class="toc-nav-text">12：Query Processing 查询处理</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-Overview"><span class="toc-nav-number">12.1.</span> <span class="toc-nav-text">1. Overview</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-1-Paring-and-translation"><span class="toc-nav-number">12.1.1.</span> <span class="toc-nav-text">1.1 Paring and translation</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-2-Evaluation"><span class="toc-nav-number">12.1.2.</span> <span class="toc-nav-text">1.2 Evaluation</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-3-Optimization"><span class="toc-nav-number">12.1.3.</span> <span class="toc-nav-text">1.3 Optimization</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-Measures-of-Query-Cost"><span class="toc-nav-number">12.2.</span> <span class="toc-nav-text">2. Measures of Query Cost</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-1-%E7%A1%AC%E7%9B%98%E7%9A%84%E6%97%B6%E9%97%B4"><span class="toc-nav-number">12.2.1.</span> <span class="toc-nav-text">2.1 硬盘的时间</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-Selection-Operation"><span class="toc-nav-number">12.3.</span> <span class="toc-nav-text">3. Selection Operation</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-1-%E6%A0%91%E7%B4%A2%E5%BC%95"><span class="toc-nav-number">12.3.1.</span> <span class="toc-nav-text">3.1 树索引</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-2-%E8%8C%83%E5%9B%B4%E6%A3%80%E7%B4%A2"><span class="toc-nav-number">12.3.2.</span> <span class="toc-nav-text">3.2 范围检索</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-3-And%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-nav-number">12.3.3.</span> <span class="toc-nav-text">3.3 And的查找</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-Sort"><span class="toc-nav-number">12.4.</span> <span class="toc-nav-text">4. Sort</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-Join-Operation"><span class="toc-nav-number">12.5.</span> <span class="toc-nav-text">5. Join Operation</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#5-1-%E4%B8%A4%E4%B8%AAfor%E5%BE%AA%E7%8E%AF%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5"><span class="toc-nav-number">12.5.1.</span> <span class="toc-nav-text">5.1 两个for循环进行连接</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#5-2-%E5%9B%9B%E4%B8%AAfor%E5%BE%AA%E7%8E%AF"><span class="toc-nav-number">12.5.2.</span> <span class="toc-nav-text">5.2 四个for循环</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#5-3-Indexed-Nested-Loop-Join"><span class="toc-nav-number">12.5.3.</span> <span class="toc-nav-text">5.3 Indexed Nested-Loop Join</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#5-4-Sort-Merge-Join"><span class="toc-nav-number">12.5.4.</span> <span class="toc-nav-text">5.4 Sort Merge-Join</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#5-5-Hash-Join"><span class="toc-nav-number">12.5.5.</span> <span class="toc-nav-text">5.5 Hash Join</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-Evaluation-of-Expressions"><span class="toc-nav-number">12.6.</span> <span class="toc-nav-text">6. Evaluation of Expressions</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#6-1-Materialization-%E5%AE%9E%E4%BD%93%E5%8C%96"><span class="toc-nav-number">12.6.1.</span> <span class="toc-nav-text">6.1 Materialization 实体化</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#6-2-Pipeline-%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-nav-number">12.6.2.</span> <span class="toc-nav-text">6.2 Pipeline 流水线</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Example"><span class="toc-nav-number">12.6.3.</span> <span class="toc-nav-text">Example</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#13%EF%BC%9AQuery-Optimization"><span class="toc-nav-number">13.</span> <span class="toc-nav-text">13：Query Optimization</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-Introduction"><span class="toc-nav-number">13.1.</span> <span class="toc-nav-text">1. Introduction</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-Transformation-of-Relational-Expressions"><span class="toc-nav-number">13.2.</span> <span class="toc-nav-text">2. Transformation of Relational Expressions</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-1-%E7%AD%89%E4%BB%B7%E8%BD%AC%E5%8C%96%E8%A7%84%E5%88%99"><span class="toc-nav-number">13.2.1.</span> <span class="toc-nav-text">2.1 等价转化规则</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-Statistics-for-Cost-Estimation"><span class="toc-nav-number">13.3.</span> <span class="toc-nav-text">3. Statistics for Cost Estimation</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-1-Selection-Size-Estimation"><span class="toc-nav-number">13.3.1.</span> <span class="toc-nav-text">3.1 Selection Size Estimation</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-2-Estimation-of-the-size-of-joins"><span class="toc-nav-number">13.3.2.</span> <span class="toc-nav-text">3.2 Estimation of the size of joins</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-Dynamic-Programming-for-Choosing-Evaluation-Plans-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%80%89%E6%8B%A9%E8%AF%84%E4%BC%B0%E7%AD%96%E7%95%A5"><span class="toc-nav-number">13.4.</span> <span class="toc-nav-text">4. Dynamic Programming for Choosing Evaluation Plans 动态规划选择评估策略</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#14%EF%BC%9ATransactions%E4%BA%8B%E5%8A%A1"><span class="toc-nav-number">14.</span> <span class="toc-nav-text">14：Transactions事务</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-nav-number">14.1.</span> <span class="toc-nav-text">1. 事务的概念</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-Transaction-State"><span class="toc-nav-number">15.</span> <span class="toc-nav-text">2. Transaction State</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E6%8C%81%E4%B9%85%E6%80%A7"><span class="toc-nav-number">15.1.</span> <span class="toc-nav-text">3. 原子性和持久性</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-Concurrent-Executions"><span class="toc-nav-number">15.2.</span> <span class="toc-nav-text">4. Concurrent Executions</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-Serializability"><span class="toc-nav-number">15.3.</span> <span class="toc-nav-text">5. Serializability</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-%E5%8F%AF%E6%81%A2%E5%A4%8D%E6%80%A7"><span class="toc-nav-number">15.4.</span> <span class="toc-nav-text">6. 可恢复性</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#7-%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%8B%AC%E7%AB%8B%E6%80%A7"><span class="toc-nav-number">15.5.</span> <span class="toc-nav-text">7. 事务的独立性</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Lecture-13%EF%BC%9AConcurrency-Control"><span class="toc-nav-number">16.</span> <span class="toc-nav-text">Lecture 13：Concurrency Control</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-Lock-Based-Protocols"><span class="toc-nav-number">16.1.</span> <span class="toc-nav-text">1. Lock-Based Protocols</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E9%94%81%E7%9A%84%E5%8D%8F%E8%AE%AE%EF%BC%9A"><span class="toc-nav-number">16.1.1.</span> <span class="toc-nav-text">锁的协议：</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Starvation-%E9%A5%BF%E6%AD%BB"><span class="toc-nav-number">16.1.2.</span> <span class="toc-nav-text">Starvation 饿死</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E5%8A%A0%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="toc-nav-number">16.1.3.</span> <span class="toc-nav-text">两阶段加锁协议</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-Lock-Table-%E9%94%81%E8%A1%A8"><span class="toc-nav-number">16.2.</span> <span class="toc-nav-text">2. Lock Table 锁表</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-Graph-Based-Protocols"><span class="toc-nav-number">16.3.</span> <span class="toc-nav-text">3. Graph-Based Protocols</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E6%88%B3%E7%9A%84%E5%8D%8F%E8%AE%AETimestamp-Based-Protocol"><span class="toc-nav-number">16.4.</span> <span class="toc-nav-text">4. 基于时间戳的协议Timestamp-Based Protocol</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-1-%E8%AF%BBRead-Q"><span class="toc-nav-number">16.4.1.</span> <span class="toc-nav-text">4.1 读Read(Q)</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-2-%E5%86%99Write-Q"><span class="toc-nav-number">16.4.2.</span> <span class="toc-nav-text">4.2 写Write(Q)</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-%E6%84%8F%E5%90%91%E9%94%81Intention-Lock-Modes"><span class="toc-nav-number">16.5.</span> <span class="toc-nav-text">5. 意向锁Intention Lock Modes</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-Deadlock-Handling"><span class="toc-nav-number">16.6.</span> <span class="toc-nav-text">6. Deadlock Handling</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#6-1-Prevention"><span class="toc-nav-number">16.6.1.</span> <span class="toc-nav-text">6.1 Prevention</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#6-2-%E6%AD%BB%E9%94%81%E7%9A%84%E5%88%A4%E6%96%AD"><span class="toc-nav-number">16.6.2.</span> <span class="toc-nav-text">6.2 死锁的判断</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#wait-for-graph"><span class="toc-nav-number">16.6.2.1.</span> <span class="toc-nav-text">wait-for graph</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#6-3-Deadlock-Recovery"><span class="toc-nav-number">16.6.3.</span> <span class="toc-nav-text">6.3 Deadlock Recovery</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#7-Insert-and-Delete-Operations"><span class="toc-nav-number">16.7.</span> <span class="toc-nav-text">7. Insert and Delete Operations</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#7-1-Index-Locking-Protocol"><span class="toc-nav-number">16.7.1.</span> <span class="toc-nav-text">7.1 Index Locking Protocol</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#%E5%9F%BA%E4%BA%8E%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8A%A0%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="toc-nav-number">16.7.1.1.</span> <span class="toc-nav-text">基于索引的加锁协议</span></a></li></ol></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Letuce-14-Recovery-System"><span class="toc-nav-number">17.</span> <span class="toc-nav-text">Letuce 14 Recovery System</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-Failure-Classification"><span class="toc-nav-number">17.1.</span> <span class="toc-nav-text">1. Failure Classification</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-1-Recovery-Algorithm"><span class="toc-nav-number">17.1.1.</span> <span class="toc-nav-text">1.1 Recovery Algorithm</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-Storage-Structure"><span class="toc-nav-number">17.2.</span> <span class="toc-nav-text">2. Storage Structure</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-1-Stable-Storage-Implementation"><span class="toc-nav-number">17.2.1.</span> <span class="toc-nav-text">2.1 Stable-Storage Implementation</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#Maintain-multiple-copies-of-each-block-on-separate-disks"><span class="toc-nav-number">17.2.1.1.</span> <span class="toc-nav-text">Maintain multiple copies of each block on separate disks</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-2-Data-Access"><span class="toc-nav-number">17.2.2.</span> <span class="toc-nav-text">2.2 Data Access</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-Recovery-and-Atomicity"><span class="toc-nav-number">17.3.</span> <span class="toc-nav-text">3. Recovery and Atomicity</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-%E5%9F%BA%E4%BA%8E%E6%97%A5%E5%BF%97%E7%9A%84%E6%81%A2%E5%A4%8D%E5%8D%8F%E8%AE%AElog-based-recovery-mechanisms"><span class="toc-nav-number">17.4.</span> <span class="toc-nav-text">4. 基于日志的恢复协议log-based recovery mechanisms</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-1-%E6%81%A2%E5%A4%8D%E7%AE%97%E6%B3%95"><span class="toc-nav-number">17.4.1.</span> <span class="toc-nav-text">4.1 恢复算法</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#4-1-1-CheckPoint"><span class="toc-nav-number">17.4.1.1.</span> <span class="toc-nav-text">4.1.1 CheckPoint</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#4-1-2-%E6%81%A2%E5%A4%8D%E5%A4%84%E7%90%86"><span class="toc-nav-number">17.4.1.2.</span> <span class="toc-nav-text">4.1.2 恢复处理</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E6%89%BElist"><span class="toc-nav-number">17.4.1.3.</span> <span class="toc-nav-text">第一步：找list</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E8%BF%9B%E8%A1%8Cundo"><span class="toc-nav-number">17.4.1.4.</span> <span class="toc-nav-text">第二步：进行undo</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E8%BF%9B%E8%A1%8Credo"><span class="toc-nav-number">17.4.1.5.</span> <span class="toc-nav-text">第三步：进行redo</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-2-Buffer-Management-%E2%80%94Log-Record-Buffering"><span class="toc-nav-number">17.4.2.</span> <span class="toc-nav-text">4.2 Buffer Management —Log Record Buffering</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#No-Force-Policy"><span class="toc-nav-number">17.4.2.1.</span> <span class="toc-nav-text">No-Force Policy</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-Advanced-Recovery-Techniques"><span class="toc-nav-number">17.5.</span> <span class="toc-nav-text">5. Advanced Recovery Techniques</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#%E6%94%AF%E6%8C%81%E9%AB%98%E5%B9%B6%E5%8F%91%E9%94%81%E5%AE%9A%E6%8A%80%E6%9C%AF"><span class="toc-nav-number">17.5.0.1.</span> <span class="toc-nav-text">支持高并发锁定技术</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#%E5%83%8FB-tree%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E8%BF%99%E6%A0%B7%E7%9A%84%E6%93%8D%E4%BD%9C%E4%BC%9A%E6%8F%90%E5%89%8D%E9%87%8A%E6%94%BE%E9%94%81%E3%80%82"><span class="toc-nav-number">17.5.0.1.1.</span> <span class="toc-nav-text">像B*-tree插入和删除这样的操作会提前释放锁。</span></a></li><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#%E5%AF%B9%E4%BA%8E%E6%AD%A4%E7%B1%BB%E6%93%8D%E4%BD%9C%EF%BC%8C%E9%9C%80%E8%A6%81%E5%9C%A8undo%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E4%B8%AD%E8%AE%B0%E5%BD%95%E9%9C%80%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84undo%E6%93%8D%E4%BD%9C"><span class="toc-nav-number">17.5.0.1.2.</span> <span class="toc-nav-text">对于此类操作，需要在undo日志记录中记录需要执行的undo操作</span></a></li><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#%E5%8D%B3%E4%BD%BF%E5%AF%B9%E4%BA%8E%E8%BF%99%E6%A0%B7%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%8C%E9%87%8D%E5%81%9A%E4%BF%A1%E6%81%AF%E4%B9%9F%E4%BC%9A%E8%A2%AB%E7%89%A9%E7%90%86%E5%9C%B0%E8%AE%B0%E5%BD%95%E4%B8%8B%E6%9D%A5-%E5%8D%B3%EF%BC%8C%E6%AF%8F%E6%AC%A1%E5%86%99%E5%85%A5%E7%9A%84%E6%96%B0%E5%80%BC"><span class="toc-nav-number">17.5.0.1.3.</span> <span class="toc-nav-text">即使对于这样的操作，重做信息也会被物理地记录下来(即，每次写入的新值)</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#Fuzzy-CheckPoint"><span class="toc-nav-number">17.5.0.2.</span> <span class="toc-nav-text">Fuzzy CheckPoint</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-ARIES"><span class="toc-nav-number">17.6.</span> <span class="toc-nav-text">6. ARIES</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#6-1-PageLSN"><span class="toc-nav-number">17.6.1.</span> <span class="toc-nav-text">6.1 PageLSN</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#6-2-Dirty-Page-Table"><span class="toc-nav-number">17.6.2.</span> <span class="toc-nav-text">6.2 Dirty Page Table</span></a></li></ol></li></ol></li></ol>
        
        </div>
      </aside>
    



      <!-- Sidebar Container -->
      <div class="
                col-lg-8 col-lg-offset-1
                col-md-10 col-md-offset-1
                sidebar-container">

        <!-- Featured Tags -->
        
        <section>
          <!-- no hr -->
          <h5>
            <a href="/tags/">特色标签</a>
          </h5>
          <div class="tags">
            
            <a class="tag" href="/tags/#数据库" title="数据库">数据库</a>
            
            <a class="tag" href="/tags/#浙江大学" title="浙江大学">浙江大学</a>
            
          </div>
        </section>
        

        <!-- Friends Blog -->
        
        <hr>
        <h5>链友</h5>
        <ul class="list-inline">

          
        </ul>
        
      </div>
    </div>
  </div>
</article>



<!-- anchorjs start -->
<!-- async load function -->
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script type="text/javascript">
  // async load function
  function async (u, c) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) {
      o.addEventListener('load', function(e) {
        c(null, e);
      }, false);
    }
    s.parentNode.insertBefore(o, s);
  };
</script>
<script type="text/javascript">
  //anchor-js, Doc:http://bryanbraun.github.io/anchorjs/
  async ("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js", function() {
    anchors.options = {
      visible: 'hover',
      placement: 'left',
      // icon: 'ℬ'
      icon: '❡'
    };
    anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
  });
</script>
<style>
  /* place left on bigger screen */
  @media all and (min-width: 800px) {
    .anchorjs-link {
      position: absolute;
      left: -0.75em;
      font-size: 1.1em;
      margin-top: -0.1em;
    }
  }
</style>

<!-- anchorjs end -->



		<!-- Footer (contains ThemeColor、viewer) -->
		<!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center">
          

          
            <li>
              <a target="_blank" href="https://github.com/Hualeez">
                <span class="fa-stack fa-lg">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
          

          

          

          

          

          

          

        </ul>
        <p class="copyright text-muted">
          Copyright &copy;
          Hualingz
          2023
          <br>
          Theme by
          <a target="_blank" rel="noopener" href="http://beantech.org">BeanTech</a>
          <span style="display: inline-block; margin: 0 5px;">
            <i class="fa fa-heart"></i>
          </span>
          re-Ported by
          <a target="_blank" rel="noopener" href="https://v-vincen.life/">Live My Life</a>
          |
          <iframe style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0" width="91px" height="20px" src="https://ghbtns.com/github-btn.html?user=V-Vincen&repo=V-Vincen.github.io&type=star&count=true"></iframe>
        </p>
      </div>
    </div>
  </div>
</footer>

<a id="rocket" href="#top" class=""></a>


  <!-- jQuery -->
  <script type="text/javascript" src="/js/jquery.min.js"></script>
  <!-- Bootstrap Core JavaScript -->
  <script type="text/javascript" src="/js/bootstrap.min.js"></script>
  <!-- Custom Theme JavaScript -->
  <script type="text/javascript" src="/js/hux-blog.min.js"></script>
  <!-- catalog -->
  <script async="true" type="text/javascript" src="/js/catalog.js"></script>
  <!-- totop(rocket) -->
  <script async="true" type="text/javascript" src="/js/totop.js"></script>

  
    <!-- Busuanzi JavaScript -->
    <script async="async" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <!-- Scroll start -->
    <script async="async" type="text/javascript" src="/js/scroll.js"></script>
    <!-- Scroll end -->
  

  
    <!-- LangSelect start -->
    <script type="text/javascript" src="/js/langselect.js"></script>
    <!-- LangSelect end -->
  

  
    <!-- Mouseclick -->
    <script type="text/javascript" src="/js/mouseclick.js" content='The first step is as good as half over...,Laugh and grow fat...,Man proposes God disposes...,When all else is lost the future still remains...,Wasting time is robbing oneself...,Sharp tools make good work...,Cease to struggle and you cease to live...,A friend in need is a friend indeed...,Faith can move mountains...' color='#9933CC,#339933,#66CCCC,#FF99CC,#CCCCFF,#6666CC,#663399,#66CC99,#FF0033'></script>
  

  
    <!-- ribbon -->
    <script type="text/javascript" src="/js/ribbonDynamic.js"></script>
  

  






  <!-- viewer start -->
  <!-- viewer start (Picture preview) -->
  
    <script async="async" type="text/javascript" src="/js/viewer/viewer.min.js"></script>
    <script async="async" type="text/javascript" src="/js/viewer/pic-viewer.js"></script>
  

  <!-- viewer end -->


<script>
  // async load function
  function async (u, c) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) {
      o.addEventListener('load', function (e) {
        c(null, e);
      }, false);
    }
    s.parentNode.insertBefore(o, s);
  }

  // fastClick.js
  async ("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function () {
    var $nav = document.querySelector("nav");
    if ($nav)
      FastClick.attach($nav);
    }
  )
</script>

<!-- Because of the native support for backtick-style fenced code blocks right within the Markdown is landed in Github Pages, From V1.6, There is no need for Highlight.js, so Huxblog drops it officially. -
https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0 - https://help.github.com/articles/creating-and-highlighting-code-blocks/ -->
<!-- <script> async ("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function () { hljs.initHighlightingOnLoad(); }) </script> <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet"> -->

<!-- jquery.tagcloud.js -->
<!-- <script> // only load tagcloud.js in tag.html if ($('#tag_cloud').length !== 0) { async ("http://Hualingz.cn/js/jquery.tagcloud.js", function () { $.fn.tagcloud.defaults = { // size: { start: 1, end: 1, unit: 'em' }, color: {
start: '#bbbbee', end: '#0085a1' } }; $('#tag_cloud a').tagcloud(); }) } </script> -->


		<!-- Search -->
		
		<div class="popup search-popup local-search-popup">
  <span class="popup-btn-close">
    ESC
  </span>
  <div class="container">
    <div class="row">
      <!-- <div class="col-md-9 col-md-offset-1"> -->
      <div class="col-lg-9 col-lg-offset-1 col-md-10 col-md-offset-1 local-search-content">

        <div class="local-search-header clearfix">

          <div class="local-search-input-wrapper">
            <span class="search-icon">
              <i class="fa fa-search fa-lg" style="margin: 25px 10px 25px 20px;"></i>
            </span>
            <input autocomplete="off" placeholder="搜索..." type="text" id="local-search-input">
          </div>
        </div>
        <div id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>


  
    <script src="/js/ziploader.js"></script>
  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.json";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    // monitor main search box;
    var onPopupClose = function (e) {
      $('.popup').fadeOut(300);
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $('.popup').fadeIn(300);
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }
    // get search zip version
    $.get('/searchVersion.json?t=' + (+new Date()), function (res) {
      if (localStorage.getItem('searchVersion') !== res) {
        localStorage.setItem('searchVersion', res);
        initSearchJson();
      }
    });

    function initSearchJson() {
      initLoad(['/search.flv'], {
        loadOptions: {
          success: function (obj) {
            localStorage.setItem('searchJson', obj['search.json'])
          },
          error: function (e) {
            return console.log(e)
          }
        },
        returnOptions: {
          'json': TYPE_TEXT
        },
        mimeOptions: {
          'json': 'application/json'
        }
      })
    }
    // search function;
    var searchFunc = function (search_id, content_id) {
      'use strict';
      isfetched = true;
      var datas = JSON.parse(localStorage.getItem('searchJson'));
      // console.log(search_id)
      var input = document.getElementById(search_id);
      var resultContent = document.getElementById(content_id);
      var inputEventFunction = function () {
        var searchText = input.value.trim().toLowerCase();
        var keywords = searchText.split(/[\s\-]+/);
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        var resultItems = [];
        if (searchText.length > 0) {
          // perform local searching
          datas.forEach(function (data) {
            var isMatch = false;
            var hitCount = 0;
            var searchTextCount = 0;
            var title = data.title
              ? data.title.trim()
              : '';
            var titleInLowerCase = title.toLowerCase();
            var content = data.content
              ? data.content.trim().replace(/<[^>]+>/g, "")
              : '';
            var contentInLowerCase = content.toLowerCase();
            var articleUrl = decodeURIComponent(data.url);

            var date = data.date;
            var dateTime = date.replace(/T/, " ").replace(/.000Z/, "");
            var imgUrl = data.header_img;
            


            var indexOfTitle = [];
            var indexOfContent = [];
            // only match articles with not empty titles
            keywords.forEach(function (keyword) {
              function getIndexByWord(word, text, caseSensitive) {
                var wordLen = word.length;
                if (wordLen === 0) {
                  return [];
                }
                var startPosition = 0,
                  position = [],
                  index = [];
                if (!caseSensitive) {
                  text = text.toLowerCase();
                  word = word.toLowerCase();
                }
                while ((position = text.indexOf(word, startPosition)) > -1) {
                  index.push({position: position, word: word});
                  startPosition = position + wordLen;
                }
                return index;
              }
              indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
              indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
            });
            if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
              isMatch = true;
              hitCount = indexOfTitle.length + indexOfContent.length;
            }
            // show search results
            if (isMatch) {
              // sort index by position of keyword
              [indexOfTitle, indexOfContent].forEach(function (index) {
                index.sort(function (itemLeft, itemRight) {
                  if (itemRight.position !== itemLeft.position) {
                    return itemRight.position - itemLeft.position;
                  } else {
                    return itemLeft.word.length - itemRight.word.length;
                  }
                });
              });
              // merge hits into slices
              function mergeIntoSlice(text, start, end, index) {
                var item = index[index.length - 1];
                var position = item.position;
                var word = item.word;
                var hits = [];
                var searchTextCountInSlice = 0;
                while (position + word.length <= end && index.length != 0) {
                  if (word === searchText) {
                    searchTextCountInSlice++;
                  }
                  hits.push({position: position, length: word.length});
                  var wordEnd = position + word.length;
                  // move to next position of hit
                  index.pop();
                  while (index.length != 0) {
                    item = index[index.length - 1];
                    position = item.position;
                    word = item.word;
                    if (wordEnd > position) {
                      index.pop();
                    } else {
                      break;
                    }
                  }
                }
                searchTextCount += searchTextCountInSlice;
                return {hits: hits, start: start, end: end, searchTextCount: searchTextCountInSlice};
              }
              var slicesOfTitle = [];
              if (indexOfTitle.length != 0) {
                slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
              }
              var slicesOfContent = [];
              while (indexOfContent.length != 0) {
                var item = indexOfContent[indexOfContent.length - 1];
                var position = item.position;
                var word = item.word;
                // cut out 100 characters
                var start = position - 20;
                var end = position + 80;
                if (start < 0) {
                  start = 0;
                }
                if (end < position + word.length) {
                  end = position + word.length;
                }
                if (end > content.length) {
                  end = content.length;
                }
                slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
              }
              // sort slices in content by search text's count and hits' count
              slicesOfContent.sort(function (sliceLeft, sliceRight) {
                if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                  return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                  return sliceRight.hits.length - sliceLeft.hits.length;
                } else {
                  return sliceLeft.start - sliceRight.start;
                }
              });
              // select top N slices in content
              var upperBound = parseInt('1');
              if (upperBound >= 0) {
                slicesOfContent = slicesOfContent.slice(0, upperBound);
              }
              // highlight title and content
              function highlightKeyword(text, slice) {
                var result = '';
                var prevEnd = slice.start;
                slice.hits.forEach(function (hit) {
                  result += text.substring(prevEnd, hit.position);
                  var end = hit.position + hit.length;
                  result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                  prevEnd = end;
                });
                result += text.substring(prevEnd, slice.end);
                return result;
              }
              var resultItem = '';

              // if (slicesOfTitle.length != 0) {   resultItem += "<li><a target='_blank' href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>"; } else {   resultItem += "<li><a target='_blank' href='" +
              // articleUrl + "' class='search-result-title'>" + title + "</a>"; } slicesOfContent.forEach(function (slice) {   resultItem += "<a target='_blank' href='" + articleUrl + "'><p class=\"search-result\">" + highlightKeyword(content, slice) +
              // "...</p></a>"; }); resultItem += "</li>";

              if (slicesOfTitle.length != 0) {
                resultItem += "<a target='_blank' href='" + articleUrl + "' class='search-result'><div class='search-result-left'><div class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</div><time class='search-result-date'>" + dateTime + "</time>";
              } else {
                resultItem += "<a target='_blank' href='" + articleUrl + "' class='search-result'><div class='search-result-left'><div class='search-result-title'>" + title + "</div><time class='search-result-date'>" + dateTime + "</time>";
              }
              slicesOfContent.forEach(function (slice) {
                resultItem += "<p class=\"search-result-content\">" + highlightKeyword(content, slice) + "...</p>";
              });
              resultItem += "</div><div class='search-result-right'><img class='media-image' src='" + imgUrl + "' width='64px' height='48px'></img></div></a>";

              resultItems.push({item: resultItem, searchTextCount: searchTextCount, hitCount: hitCount, id: resultItems.length});
            }
          })
        };

        if (keywords.length === 1 && keywords[0] === "") {
          resultContent.innerHTML = '<div id="no-result"></div>'
        } else if (resultItems.length === 0) {
          resultContent.innerHTML = '<div id="no-result"></div>'
        } else {
          resultItems.sort(function (resultLeft, resultRight) {
            if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
              return resultRight.searchTextCount - resultLeft.searchTextCount;
            } else if (resultLeft.hitCount !== resultRight.hitCount) {
              return resultRight.hitCount - resultLeft.hitCount;
            } else {
              return resultRight.id - resultLeft.id;
            }
          });
          var searchResultList = '<div class=\"search-result-list\">';
          resultItems.forEach(function (result) {
            searchResultList += result.item;
          })
          searchResultList += "</div>";
          resultContent.innerHTML = searchResultList;
        }
      }
      if ('auto' === 'auto') {
        input.addEventListener('input', inputEventFunction);
      } else {
        $('.search-icon').click(inputEventFunction);
        input.addEventListener('keypress', function (event) {
          if (event.keyCode === 13) {
            inputEventFunction();
          }
        });
      }
      // remove loading animation
      $('body').css('overflow', '');
      proceedsearch();
    }
    // handle and trigger popup window;
    $('.popup-trigger').click(function (e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc('local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });
    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function (e) {
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 && $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });

    document.addEventListener('mouseup', (e) => {
      var _con = document.querySelector(".local-search-content");
      if (_con) {
        if (!_con.contains(e.target)) {
          onPopupClose();
        }
      }
    });
  </script>


		
	<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
