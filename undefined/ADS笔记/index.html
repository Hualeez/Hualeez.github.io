<!DOCTYPE html>
<html lang="en">

<!-- Head tag (contains Google-Analytics、Baidu-Tongji)-->
<head>
  <!-- Google Analytics -->
  
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-xxxxxx-xx"></script>
    <script type="text/javascript">
      window.dataLayer = window.dataLayer || [];

      function gtag() {
        dataLayer.push(arguments);
      }
      gtag('js', new Date());

      gtag('config', 'UA-xxxxxx-xx');
    </script>
  

  <!-- Baidu Tongji -->
  
    <script type="text/javascript">
      // Originial
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  <!-- Baidu Push -->
  
    <script>
      (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
      })();
    </script>
  

  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>

  <meta name="google-site-verification" content="lxDfCplOZbIzjhG34NuQBgu2gdyRlAtMB4utP5AgEBc"/>
  <meta name="baidu-site-verification" content="PpzM9WxOJU"/>

  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="description" content="这里是Hualingz，一个乐观主义者"/>
  <meta name="keyword" content="Hualingz,hualeez,hualingz,cyc"/>
  <link rel="shortcut icon" href="/img/avatar/fin_32.png"/>

  <!-- Place this tag in your head or just before your close body tag. -->
  <script async="async" defer="defer" src="https://buttons.github.io/buttons.js"></script>

  
    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css"/>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/beantech.min.css"/>

    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css"/>
    <link rel="stylesheet" href="/css/widget.css"/>
    <link rel="stylesheet" href="/css/rocket.css"/>
    <link rel="stylesheet" href="/css/signature.css"/>
    <link rel="stylesheet" href="/css/catalog.css"/>
    <link rel="stylesheet" href="/css/livemylife.css"/>

    
      <!-- wave start -->
      <link rel="stylesheet" href="/css/wave.css"/>
      <!-- wave end -->
    

    
      <!-- top start (article top hot config) -->
      <link rel="stylesheet" href="/css/top.css"/>
      <!-- top end -->
    

    
      <!-- ThemeColor start -->
      <link rel="stylesheet" href="/css/scroll.css"/>
      <!-- ThemeColor end -->
    

    
      <!-- viewer start (Picture preview) -->
      <link rel="stylesheet" href="/css/viewer.min.css"/>
      <!-- viewer end -->
    

    
      <!-- Search start -->
      <link rel="stylesheet" href="/css/search.css"/>
      <!-- Search end -->
    

    
      <!-- ThemeColor start -->
      <link rel="stylesheet" href="/css/themecolor.css"/>
      <!-- ThemeColor end -->
    

    

    
      <!-- gitalk start -->
      <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"> -->
      <link rel="stylesheet" href="/css/gitalk.css"/>
      <!-- gitalk end -->
    
  

  <!-- Custom Fonts -->
  <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
  <!-- Hux change font-awesome CDN to qiniu -->
  <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" type="text/css">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

  <!-- Hux Delete, sad but pending in China <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'> <link
  href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/ css'> -->

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]> <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script> <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script> <![endif]-->

  <!-- ga & ba script hoook -->
  <link rel="canonical" href="http://Hualingz.cn/undefined/ADS笔记/">
  <title>
    
      ADS笔记 - Hualingz_Channel
    
  </title>
<meta name="generator" content="Hexo 5.4.2"></head>


<!-- hack iOS CSS :active style -->

	<body ontouchstart="" class="body--light body--dark">


		<!-- ThemeColor -->
		
		<!-- ThemeColor -->
<style type="text/css">
  .body--light {
    --light-mode: none;
    --dark-mode: block;
  }
  .body--dark {
    --light-mode: block;
    --dark-mode: none;
  }
  i.mdui-icon.material-icons.light-mode {
    display: var(--light-mode);
  }
  i.mdui-icon.material-icons.dark-mode {
    display: var(--dark-mode);
  }
</style>
<div class="toggle" onclick="document.body.classList.toggle('body--dark')">
  <i class="mdui-icon material-icons light-mode"></i>
  <i class="mdui-icon material-icons dark-mode"></i>
</div>
<script>
  //getCookieValue
  function getCookieValue(a) {
    var b = document.cookie.match('(^|[^;]+)\\s*' + a + '\\s*=\\s*([^;]+)');
    return b
      ? b.pop()
      : '';
  }
  let themeMode = 'dark';
  if (getCookieValue('sb-color-mode') && (getCookieValue('sb-color-mode') !== themeMode)) {
    let dbody = document.body.classList;
    themeMode === 'dark' ? dbody.remove('body--dark') : dbody.add('body--dark');
  }

  //setCookieValue
  var toggleBtn = document.querySelector(".toggle");
  toggleBtn.addEventListener("click", function () {
    var e = document.body.classList.contains("body--dark");
    var cookieString = e
      ? "dark"
      : "light";
    var exp = new Date();
    exp.setTime(exp.getTime() + 3 * 24 * 60 * 60 * 1000); //3天过期
    document.cookie = "sb-color-mode=" + cookieString + ";expires=" + exp.toGMTString() + ";path=/";
  });
</script>

		

		<!-- Gitter -->
		
		<!-- Gitter -->
<!-- Docs:https://gitter.im/?utm_source=left-menu-logo -->
<script>
  ((window.gitter = {}).chat = {}).options = {
    room: 'your-community/your-room'
  };
</script>
<script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script>

		

		<!-- Navigation (contains search)-->
		<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header page-scroll">
      <button type="button" class="navbar-toggle">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">Hualingz_Channel</a>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <!-- Known Issue, found by Hux: <nav>'s height woule be hold on by its content. so, when navbar scale out, the <nav> will cover tags. also mask any touch event of tags, unfortunately. -->
    <div id="huxblog_navbar">
      <div class="navbar-collapse">
        <ul class="nav navbar-nav navbar-right">
          <li>
            <a href="/">首页</a>
          </li>

          
          
          
          
          <li>
            <a href="/about/">
              
              关于
              
              
            </a>
          </li>
          
          
          
          
          
          <li>
            <a href="/categories/">
              
              分类
              
              
            </a>
          </li>
          
          
          
          <li>
            <a href="/tags/">
              
              标签
              
              
            </a>
          </li>
          
          

          
          <li>
            <a class="popup-trigger">
              <span class="search-icon"></span>搜索</a>
          </li>
          

          <!-- LangSelect -->
          
          
          
          
          
        </ul>
      </div>
    </div>
    <!-- /.navbar-collapse -->
  </div>
  <!-- /.container -->
</nav>
<!-- progress -->
<div id="progress">
  <div class="line" style="width: 0%;"></div>
</div>

<script>
  // Drop Bootstarp low-performance Navbar Use customize navbar with high-quality material design animation in high-perf jank-free CSS3 implementation
  var $body = document.body;
  var $toggle = document.querySelector('.navbar-toggle');
  var $navbar = document.querySelector('#huxblog_navbar');
  var $collapse = document.querySelector('.navbar-collapse');

  $toggle.addEventListener('click', handleMagic)

  function handleMagic(e) {
    if ($navbar.className.indexOf('in') > 0) {
      // CLOSE
      $navbar.className = " ";
      // wait until animation end.
      setTimeout(function() {
        // prevent frequently toggle
        if ($navbar.className.indexOf('in') < 0) {
          $collapse.style.height = "0px"
        }
      }, 400)
    } else {
      // OPEN
      $collapse.style.height = "auto"
      $navbar.className += " in";
    }
  }
</script>


		<!-- Post Header (contains intro-header、signature、wordcount、busuanzi、waveoverlay) -->
		<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->

  <style type="text/css">
    .body--light {
      /* intro-header */
      --intro-header-background-image-url-home: url('/img/header_img/newhome_bg.jpg');
      --intro-header-background-image-url-post: url('');
      --intro-header-background-image-url-page: url('/img/header_img/archive_bg2.jpg');
    }
    .body--dark {
      --intro-header-background-image-url-home: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url('/img/header_img/newhome_bg.jpg');
      --intro-header-background-image-url-post: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url('');
      --intro-header-background-image-url-page: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url('/img/header_img/archive_bg2.jpg');
    }

    header.intro-header {
       /*post*/
        background-image: var(--intro-header-background-image-url-post);
        /* background-image: url(''); */
      
    }

    
      #signature {/*signature*/
        background-image: url('/img/signature/vincent-white.png');
      }
    
  </style>





<header class="intro-header">
  <!-- Signature -->
  <div id="signature">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
          
          <div class="post-heading">
            <div class="tags">
              
              <a class="tag" href="/tags/#高级数据结构" title="高级数据结构">高级数据结构</a>
              
            </div>
            <h1>ADS笔记</h1>
            <h2 class="subheading">Hualingz</h2>
            <span class="meta">
              Posted by Hualingz on
              2022-06-26
            </span>


            
            <!-- WordCount start -->
            <div class="blank_box"></div>
            <span class="meta">
              Estimated Reading Time <span class="post-count">54</span> Minutes
            </span>
            <div class="blank_box"></div>
            <span class="meta">
              Words <span class="post-count">12.6k</span> In Total
            </span>
            <div class="blank_box"></div>
            <!-- WordCount end -->
            
            
            <!-- 不蒜子统计 start -->
            <span class="meta" id="busuanzi_container_page_pv">
              Viewed <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span> Times
            </span>
            <!-- 不蒜子统计 end -->
            


          </div>
          
        </div>
      </div>
    </div>
  </div>

  
  <!-- waveoverlay start -->
  <div class="preview-overlay">
    <svg class="preview-waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
      <defs>
        <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path>
      </defs>
      <g class="preview-parallax">
        <use xlink:href="#gentle-wave" x="48" y="0" fill=var(--gentle-wave1)></use>
        <use xlink:href="#gentle-wave" x="48" y="3" fill=var(--gentle-wave2)></use>
        <use xlink:href="#gentle-wave" x="48" y="5" fill=var(--gentle-wave3)></use>
        <use xlink:href="#gentle-wave" x="48" y="7" fill=var(--gentle-wave)></use>
      </g>
    </svg>
  </div>
  <!-- waveoverlay end -->
  

</header>



		<!-- Main Content (Post contains
	Pager、
	tip、
	socialshare、
	gitalk、gitment、disqus-comment、
	Catalog、
	Sidebar、
	Featured-Tags、
	Friends Blog、
	anchorjs、
	) -->
		<!-- Modify by Yu-Hsuan Yen -->
<!-- Post Content -->
<article>
  <div class="container">
    <div class="row">
      <!-- Post Container -->
      <div class="col-lg-8 col-lg-offset-1 col-md-10 col-md-offset-1 post-container">

        <h1>ADS</h1>
<h2 id="1-Advanced-Data-Structure">1.Advanced Data Structure</h2>
<h3 id="1-1-Tree">1.1 Tree</h3>
<h4 id="1-1-1-AVL-Tree">1.1.1  AVL Tree</h4>
<ul>
<li>
<p>目标：加快<strong>搜索速度</strong></p>
</li>
<li>
<p>定义：</p>
<ul>
<li>空的树是height balanced的（左右子树的高度差绝对值不超过1）</li>
<li>左右子树的高度差为-1、0、1
<ul>
<li>高度height：空树height=-1，单节点为0</li>
</ul>
</li>
<li>平衡因子：$BF(Node)=H_{L}-H_{R}$
<ul>
<li>因此平衡树的平衡因子为-1，0，1</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>树的旋转</strong>Rotation</p>
<ul>
<li>
<p>当高度差打破平衡使用旋转，旋转是不改变大小顺序关系的，旋转有LL、RR、LR、RL四种方式，基本是左右旋的组合使用</p>
</li>
<li>
<p>右旋Right Rotation</p>
</li>
<li>
<p>左旋Left Rotation</p>
<img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220222161616843.png">
</li>
<li>
<p>LL型旋转</p>
<p>插入的节点在不平衡点的左节点的左子树中，此时是LL型，对不平衡点使用一次右旋</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(isLL)&#123;RightRotation(WrongNode);&#125;</span><br></pre></td></tr></table></figure>
<img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220222162055599.png">
</li>
<li>
<p>RR型旋转</p>
<p>插入的节点在不平衡点的右节点的右子树中，此时是RR型，对不平衡点使用一次左旋</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(isRR)&#123;LeftRotation(WrongNode);&#125;</span><br></pre></td></tr></table></figure>
<img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220222162156069.png">
</li>
<li>
<p>LR型旋转</p>
<p>插入的节点在不平衡点的左节点的右子树中，此时是LR型，先对WrongNode-&gt;Left进行一次左旋，再对WrongNode进行一次右旋</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(isLR)&#123;</span><br><span class="line">  LeftRotation(WrongNode-&gt;Left);</span><br><span class="line">  RightRotation(WrongNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220222162426230.png">
</li>
<li>
<p>RL型旋转</p>
<p>插入的节点在不平衡点的右节点的左子树中，此时是LR型，先对WrongNode-&gt;Right进行一次右旋，再对WrongNode进行一次左旋</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(isRL)&#123;</span><br><span class="line">  RightRotation(WrongNode-&gt;Right);</span><br><span class="line">  LeftRotation(WrongNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220222162656516.png">
</li>
<li>
<p>对于高度为h的树，最少节点个数为$n_{h}$，$n_{k}$的递推关系式为</p>
<p>$n_{h}=n_{h-1}+n_{h-2}+1$</p>
<p>$(n_{h}+1)=(n_{h-1}+1)+(n_{h-2}+1)$</p>
<p>注意到斐波那契数列的递推式</p>
<p>$F_{n}=F_{n-1}+F_{n-2}$</p>
<p>修改一下初项，即可得到</p>
<p>$n_{h}=F_{h+2}-1$</p>
<p>$F_i=\frac{1}{\sqrt{5}\ }(\frac{1+\sqrt{5}\ }{2})^i$</p>
<p>则$h→O(lnN)$</p>
</li>
</ul>
</li>
</ul>
<h4 id="1-1-2-Splay-Tree">1.1.2 Splay Tree</h4>
<ul>
<li>
<p>目标：从空树开始，任何M次连续操作一共最多消耗$O(MlogN)$的时间</p>
<ul>
<li>必须从<strong>空树</strong>开始</li>
<li>具体做法：在树中，每次有节点被访问到，就旋转节点到树根</li>
</ul>
</li>
<li>
<p>旋转方法：</p>
<ul>
<li>
<p>如果父节点是Root，直接父子旋转</p>
</li>
<li>
<p>如果父节点不是Root</p>
<ul>
<li>
<p>Zig-Zag(之字形)</p>
<img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220222164258772.png">
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(isZig_Zag)&#123;</span><br><span class="line">  LeftRotation(P);</span><br><span class="line">  RightRotation(G);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Zig-Zig(线形)</p>
<img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220222164307643.png">
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(isZig_Zig)&#123;</span><br><span class="line">  RightRotation(G);</span><br><span class="line">  RightRotation(P);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>按照上述规则将X节点转到Root节点即可</p>
</li>
</ul>
</li>
<li>
<p>删除方法：</p>
<ul>
<li>Find(X)，此时X到了Root的位置</li>
<li>删除根节点，得到左右子树</li>
<li>FindMax($T_{L}$)作为根节点，将右子树接上</li>
</ul>
</li>
</ul>
<h4 id="【补充】代价计算">【补充】代价计算</h4>
<ol>
<li>
<p>Worst Case 最差情况的计算</p>
</li>
<li>
<p>Amortized case 均摊代价：与数据分布无关，即对一个序列的所有操作取平均，均摊分析的结果可能是最坏情况也可能是平均情况。</p>
</li>
<li>
<p>average case 平均代价：简单地把每一个操偶做的单独代价加起来取平均。</p>
</li>
</ol>
<ul>
<li>比如a，b，c操作要1，2，3分钟，那么平均代价就是2，但是对于序列操作abcc，均摊代价是2.25。</li>
<li>Worst case &gt;= Amortized case &gt;=average case</li>
</ul>
<h4 id="【补充】均摊代价的分析">【补充】均摊代价的分析</h4>
<ol>
<li>
<p>聚集分析法</p>
<p>证明对所有的n，由n个操作所构成的序列的总时间在最坏情况下的T(N),每一个操作的代价就是$\frac{T(N)}{N}$,比如栈的操作push、pop、mutipop，sizeof(S)&lt;=n，那么总的时间最大为O(n),则均摊代价为O(1)。</p>
</li>
<li>
<p>记账法</p>
<p>amortized cost 为$\overline{c_i}$</p>
<p>actual cost 为${c_i}$</p>
<p>credit 为amortized cost-actual cost,</p>
<p>credit可以pay for later operations</p>
<p><strong>要保证credit&gt;=0!!!</strong></p>
<p>O(n)=$\sum{\overline{c_i}\ }≥\sum c_i$</p>
<p>$T_{amortized}=O(n)/n$</p>
<p>如栈操作中,T(n)=<strong>push+pop</strong>(实际代价)&lt;=<strong>2push</strong>(amortized cost)&lt;=2n=O(n)</p>
<p>这里我们把push的代价设置为了2,实际是1,pop的代价是0实际是1</p>
</li>
<li>
<p>势能法</p>
<p>$\overline{c_i}-c_i=Credit_i=\Phi(D_i)-\Phi(D_{i-1})$</p>
<p>$\sum{\overline{c_i}\ }=\sum (c_i+\Phi(D_i)-\Phi(D_{i-1}))=(\sum c_i)+\Phi(D_n)-\Phi(D_{0})$</p>
<p>这里的$\Phi(D_i)$为势能函数,$D_i$是i次操作后的某种状态</p>
<p>要保证,在D0时势能最小</p>
<p>如栈操作中,我们设置势能函数为栈的size那么首先D0时为0</p>
<p>由于push的数量大于等于pop,那么$\Phi(D_i)≥0$</p>
<p>那么$\sum{\overline{c_i}\ }=O(n)≥\sum c_i$</p>
</li>
</ol>
<h4 id="1-1-3-红黑树">1.1.3 红黑树</h4>
<ul>
<li>
<p>定义：</p>
<ul>
<li>红黑树是一种BST，节点具有颜色红色（0）或者黑色（1）</li>
<li>红黑树的<strong>根节点是黑色</strong></li>
<li>叶节点为黑色，叶节点为NULL时，把NULL也视作黑色的节点</li>
<li><strong>红节点</strong>的两个儿子一定是<strong>黑节点</strong></li>
<li>对于每一个节点，从该节点出发到后代的叶节点的简单路径包含的黑节点数量相同</li>
</ul>
</li>
<li>
<p>黑高（Black Height of Node x）</p>
<ul>
<li>bh(x)表示从x到叶节点的路径中的黑节点个数，不含节点自身</li>
<li>性质：
<ul>
<li>N个节点，高度最多为$2ln(N+1)$</li>
<li>sizeof(x)≥$2^{bh(x)}-1$(可以归纳证明)</li>
<li>$bh(Tree)≥\frac{h(Tree)}{2}$</li>
</ul>
</li>
</ul>
</li>
<li>
<p>红黑树的操作：</p>
<ul>
<li>
<p>插入：</p>
<ul>
<li>
<p>将节点染<strong>红</strong>插入BST，可能破坏性质2、4</p>
</li>
<li>
<p>判断旋转方式：</p>
<ul>
<li>
<p>case1：叔节点为红色</p>
<p>则将父节点和叔节点变为黑色，祖父节点变为红色，祖父继续视作插入点向上<strong>迭代</strong></p>
<img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220306152514551.png">
</li>
<li>
<p>case2：叔节点为黑色</p>
<p>将插入节点转为远侄子，再转为case1，如图</p>
<img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220306153350630.png">
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>删除</p>
<ul>
<li>删除的节点是叶节点：直接让其父节点指向NULL</li>
<li>删除的节点度数为1：用孩子代替这个节点</li>
<li>删除的节点度数为2：用最大左儿子或者最小右儿子代替</li>
<li>当删除节点为<strong>红色</strong>，性质不会被破坏，若删除的节点是黑色，则性质会被破坏</li>
</ul>
</li>
<li>
<p>删除的具体操作</p>
<ul>
<li>
<p>设v是要删除的节点，u是替代v的节点，u可能是NULL，是NULL的话，当作黑色处理。</p>
</li>
<li>
<p>删除操作总纲：<br>
执行标准的 BST 的删除操作<br>
简单情况：u 或者 v 是红色<br>
复杂情况：u 和 v 都是黑色结点。引入双黑节点</p>
<img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220306154137686.png">
<img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220306154147277.png">
</li>
<li>
<p>双黑节点的删除情况</p>
<p>我们用数值表示颜色，更好理解，0为红色，-1、1为黑色，2为双黑</p>
<ul>
<li>
<p>case1:兄弟节点s为红色</p>
<p>​    <img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220307101356333.png"></p>
<ul>
<li>
<p>s与p交换颜色，且把s转上来</p>
<img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220306160530213.png">
<img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220306160549053.png">
</li>
<li>
<p>到case2</p>
<img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220306160700854.png">
</li>
</ul>
</li>
<li>
<p>case2:兄弟节点s为黑色，侄子(s的儿子)均为黑</p>
 <img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220307102333741.png">
<ul>
<li>
<p>u和s颜色减1，p的颜色加1</p>
<img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220306161716094.png">
</li>
<li>
<p>如果p加完1是黑色则结束了</p>
</li>
<li>
<p>如果p加完1是双黑<img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220306161733293.png"> alt=“image-20220306161733293” style=“zoom:60%;” /&gt;</p>
</li>
</ul>
</li>
<li>
<p>case3:兄弟节点s为黑色，侄子至少一个红色</p>
<ul>
<li>
<p>u和s的父亲p节点，s的红孩子设为r，则查看p、s、r的关系，若有两个红孩子，优先查看LL、RR型：</p>
</li>
<li>
<p>LL： s的颜色变成p的颜色，r的颜色变成s的颜色</p>
<img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220307104556066.png">
<p>​     旋转p节点</p>
<img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220307104700943.png">
      p设置为黑色，双黑变成单黑
<img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220307104851729.png">
</li>
<li>
<p>当为LR、RL型时，转化为LL、RR型：</p>
<p>s变为红色，r变为黑色，旋转s，变成LL、RR型</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1-1-4-B-树">1.1.4 B+树</h4>
<ul>
<li>
<p>M阶的B+树定义：</p>
<ul>
<li>根节点是叶节点或者根节点有2~M个儿子</li>
<li>根之外的<strong>非叶节点</strong>有$[\frac{M}{2}]$~M个儿子，每个叶节点有$[\frac{M}{2}]$~M个元素//这里与数据库里的不同
<ul>
<li>B+树的儿子指的是节点指向的新节点而非节点内的数据</li>
<li>每个节点的 key数是子节点数-1，画图的时候key分布在指向两个儿子的箭头之间</li>
<li>key值的确定方法：等于key右边第一个指针对应子节点的最左边的值</li>
</ul>
</li>
<li>所有叶节点的深度相同</li>
<li>B+ Tree of Order 4 也称为2-3-4树，order 3 的称为2-3树</li>
</ul>
</li>
<li>
<p>B+树的插入算法</p>
<ul>
<li>
<p>对于order M， 有N个元素的B+树而言$T=O(\frac{M}{logM}logN)$</p>
</li>
<li>
<p>B+树的深度Depth(M,N)=$O([log_{M/2}N])$, 找到插入位置的事件复杂度是log N</p>
</li>
<li>
<p>对于order3的B+树而言，非叶节点的索引个数在有三个儿子时需要两个，否则只需要一个索引</p>
</li>
<li>
<pre><code class="language-cpp">Btree Insert ( ElementType X, Btree T )
&#123;
  Search from root to leaf for X and find the proper leaf node;
  Insert X;
  while ( this node has M+1 keys ) &#123;
    split it into 2 nodes with [(M+1)/2] and [(M+1)/2] keys,
respectively;
    if (this node is the root)
      create a new root with two children;
    check its parent;
  &#125;
&#125;
//算法的描述：找到合适的位置先插入，如果叶节点的keys数量超过了M，则分裂成两个，然后向上继续合并和拆分
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- Deletion <span class="keyword">is</span> <span class="keyword">similar</span> <span class="keyword">to</span> insertion <span class="keyword">except</span> that the root <span class="keyword">is</span> removed <span class="keyword">when</span> it loses two</span><br><span class="line">  children 删除和插入的做法相似，不过当一个根节点失去两个儿子时就要删除</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### <span class="number">1.2</span>  Invert File <span class="keyword">Index</span></span><br><span class="line"></span><br><span class="line">- 文档关联矩阵 Term-Document incidence Matrix</span><br><span class="line">  - a matrix <span class="keyword">of</span> appearance <span class="keyword">of</span> <span class="keyword">each</span> word <span class="keyword">in</span> <span class="keyword">each</span> doc。</span><br><span class="line">  - 某个单词在某篇中出现，则矩阵对应位置上为<span class="number">1</span>，否则为<span class="number">0</span>，若干篇文章的出现情况可以都得到若干个二进制字符串</span><br><span class="line">    - 只关注单词的出现与否，不关注频率</span><br><span class="line">    - 矩阵比较稀疏</span><br><span class="line">  - **用逻辑运算可以考察多个单词在doc中出现的情况**</span><br><span class="line">- 倒排文件索引 Invert File <span class="keyword">Index</span></span><br><span class="line">  - 一种在文章中定位单词的方法。</span><br><span class="line">  - **看词在哪些文章中出现了**</span><br><span class="line">  - 索引方法：</span><br><span class="line">    <span class="number">1.</span> 单词<span class="comment">--&lt;次数；出现单词的doc编号&gt;</span></span><br><span class="line">    <span class="number">2.</span> 单词<span class="comment">--&lt;次数；(doc号；位置1；位置2；…)，…&lt;img src = &quot;ADS笔记\image-20220328193119874.png&quot;&gt; alt=&quot;image-20220328193119874&quot; style=&quot;zoom:67%;&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line">- 索引生成器：</span><br><span class="line"></span><br><span class="line">```pseudocode</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">read</span> a document D)&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="keyword">read</span> a term T <span class="keyword">in</span> D)&#123;</span><br><span class="line">    <span class="keyword">if</span>(Find(<span class="keyword">Dictionary</span>,T)==<span class="keyword">false</span>)</span><br><span class="line">      <span class="keyword">Insert</span>(T);</span><br><span class="line">    <span class="keyword">Get</span> T<span class="string">&#x27;s position list;</span></span><br><span class="line"><span class="string">    Insert a node to T&#x27;</span>s posting list</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">write</span> the inverted <span class="keyword">index</span> <span class="keyword">to</span> disk</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
<li>
<p>读取的简单处理</p>
<ol>
<li>碰到一个单词的多种形态要统一，如过去式、将来时、现在式</li>
<li>频率高但是无实际意义的单词无需统计，如a、the</li>
</ol>
</li>
<li>
<p>当储存空间不足时的措施</p>
<ol>
<li>采用多块内存储存</li>
<li>分布式索引：
<ul>
<li>按单词的首字母划分</li>
<li>按文档的编号划分（更好，抗风险）</li>
</ul>
</li>
<li>动态索引：
<ul>
<li>不常用的索引会删除</li>
<li>索引由main index+auxiliary index组成</li>
</ul>
</li>
</ol>
</li>
<li>
<p>阈值Thresholding</p>
<ul>
<li>document：直接检索前面X个按权重排序的文档
<ul>
<li>对于布尔查询无效</li>
<li>会遗漏重要文档，因为有截断</li>
</ul>
</li>
<li>query：把带查询的terms按照出现的频率排序</li>
</ul>
</li>
<li>
<p>搜索引擎的评价：</p>
<ol>
<li>索引创建多快 how fast does it index</li>
<li>搜索有多快 how fast does it search</li>
<li>查询语言的表现 Expressiveness of query language</li>
</ol>
</li>
<li>
<p>Data Retrieval Performance</p>
<ul>
<li>Response time</li>
<li>Index Space</li>
</ul>
</li>
<li>
<p>Information Retrieval Performance</p>
<ul>
<li>How relevant is the answer set？</li>
</ul>
</li>
<li>
<p>Relevance measurement</p>
<ul>
<li>
<p>准确率precision</p>
<p>$P=\frac{R_R}{R_R+I_R}$</p>
</li>
<li>
<p>召回率 recall</p>
<p>$R=\frac<img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220328194318411.png"> alt=“image-20220328194318411” style=“zoom:67%;” /&gt;</p>
</li>
</ul>
</li>
<li>
<p>【习题】While accessing a term, hashing is faster than search trees.</p>
</li>
<li>
<p>答：True，因为hash表是直接使用hash函数定位的时间是常数的，而使用搜索树则是O(logn)的。但是hash表的储存不灵活有缺点。</p>
</li>
<li>
<p>【习题】In distributed indexing, document-partitioned strategy is to store on each node all the documents that contain the terms in a certain range.</p>
</li>
<li>
<p>答：False，因为分布式索引的方式是按文档序号排序的，如果按包含的terms分类，在储存故障时，关于这个terms的文档全没了，不抗风险。</p>
</li>
<li>
<p>【习题】When evaluating the performance of data retrieval, it is important to measure the relevancy of the answer set.</p>
</li>
<li>
<p>答：False，这个说的是data retrieval，错。Information retrieval才需要measure the relevancy of the answer set。</p>
</li>
<li>
<p>【习题】Precision is more important than recall when evaluating the explosive detection in airport security.</p>
</li>
<li>
<p>答：False，在机场安全的危险品探测中应该是Recall率更重要。</p>
</li>
<li></li>
</ul>
<h3 id="1-3-Heap">1.3 Heap</h3>
<h4 id="1-3-1-Leftist-Heap-左倾堆">1.3.1 Leftist Heap 左倾堆</h4>
<ul>
<li>
<p>NPL(X)–NULL Path Length</p>
<ul>
<li>对任意一个节点X，通往一个<strong>没有两个子节点</strong>(<strong>外节点</strong>)的最短路径长度，<strong>空节点的NPL值为-1</strong>，外节点的NPL为0；</li>
<li>计算方法：$NPL(X)=min {NPL©|c\ is\ a\ child\ of\ X}+1$</li>
</ul>
</li>
<li>
<p>左倾堆的性质：</p>
<ol>
<li>
<p>对每一个节点，左儿子的NPL不小于右儿子的NPL值，整体看起来向左倾斜</p>
</li>
<li>
<p>左倾堆的本质是一种不平衡的二叉树，它的数据结构定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line"> ElementType Element;</span><br><span class="line"> PriorityQueue Left;</span><br><span class="line"> PriorityQueue Right;</span><br><span class="line"> <span class="type">int</span> Npl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对于一个右路径有 $r$ 个节点的左倾堆，至少一共有个$2^r-1$节点【归纳证明】</p>
</li>
<li>
<p>有N个节点的左倾树，右路径最多$\lfloor log(N+1) \rfloor$个节点，启发我们在右路经上进行操作</p>
</li>
</ol>
</li>
<li>
<p>左倾堆的合并</p>
<ol>
<li>
<p>递归方法：</p>
<p>每次合并比较左倾堆的根节点大小，大的合并在小的上面，并且根据NPL交换左右</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue Merge(PriorityQueue H1,PriorityQueue H2)&#123;</span><br><span class="line"> if(H1==NULL) return H2;</span><br><span class="line"> if(H2==NULL) return H1;</span><br><span class="line"> if(H1-&gt;Element&lt;H2-&gt;Element) return Merge1(H1,H2);</span><br><span class="line"> else return Merge1(H2,H1);</span><br><span class="line">&#125;</span><br><span class="line">PriorityQueue Merge1(PriorityQueue H1,PriorityQueue H2)&#123;</span><br><span class="line"> if(H1-&gt;Left == NULL)//single node</span><br><span class="line">   H1-&gt;Left = H2;//H1-&gt;Right is already NULL</span><br><span class="line"> else&#123;</span><br><span class="line">   H1-&gt;Right = Merge(H1-&gt;Right,H2);</span><br><span class="line">   if(H1-&gt;Left-&gt;Npl&lt;H1-&gt;Right-&gt;Npl)</span><br><span class="line">     SwapChildren(H1);</span><br><span class="line">   H1-&gt;Npl = H1-&gt;Right-&gt;Npl + 1;</span><br><span class="line"> &#125;</span><br><span class="line"> return H1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>迭代方法</p>
<p>对所有的右路径上的节点排序，且不改变左儿子</p>
<p>根据NPL交换左右。</p>
</li>
</ol>
</li>
<li>
<p>左倾堆的删除</p>
<ol>
<li>删除最小的，即根节点</li>
<li>合并两颗剩下的子树</li>
<li>$T_p=O(logN)$</li>
</ol>
</li>
</ul>
<h4 id="1-3-2-Skew-Heap斜堆">1.3.2 Skew Heap斜堆</h4>
<ul>
<li>目的：从空触发，M次操作的总时间为$O(MlogN)$</li>
<li>无NPL的限制，合并后左右子树一定交换！</li>
<li>插入：为特殊的合并。</li>
<li>合并：每一次Merge完都要交换左右子树</li>
<li>删除：删除根节点之后Merge两颗子树】</li>
<li>斜堆的摊还分析
<ul>
<li>将操作后的根节点作为$D_i$</li>
<li>势能函数的选取：number of heavy nodes</li>
<li><strong>heavy nodes</strong>：if the number of descendants of p’s right subtree is at least half of the number of descendants of p, and light otherwise.如果p的右子树的后代数至少是p的后代数的一半，否则为轻。</li>
<li>The only nodes whose heavy/light status can change are nodes that are initially on the right path</li>
</ul>
</li>
</ul>
<h3 id="1-4-二项队列">1.4 二项队列</h3>
<ul>
<li>
<p>优先队列的一种，是二项树构成的森林</p>
</li>
<li>
<p>二项树：</p>
<ul>
<li>
<p>$B_k$表示高度为k的二项树</p>
</li>
<li>
<p>一个$B_k$的根节点有n个孩子分别为$B_0,B_1,…B_{n-1}$</p>
</li>
<li>
<p>$B_k$也可以看作一个$B_{n-1}$接到另一个$B_{n-1}$的根上构成。</p>
</li>
<li>
<p>高度为0时元素只有1个</p>
</li>
<li>
<p>也要满足大小关系，即根最小</p>
<img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220621175908842.png">
</li>
</ul>
</li>
<li>
<p>性质：</p>
<ul>
<li>二项树$B_k$有$2^k$个节点在d深层有$C_k^d$个节点</li>
<li>在二项队列中每种二项树只能出现一次</li>
<li>任意size的二项队列用二项树唯一表示(二进制唯一)</li>
</ul>
</li>
<li>
<p>FindMin( )</p>
<ul>
<li>最小值都在二项树的根,因此遍历这个根即可,至多有$\lceil logN \rceil$个根,因此$T_p=O(logN)$</li>
<li>也可以专门维护一个最小值节点</li>
</ul>
</li>
<li>
<p>Merge( )</p>
<ul>
<li>类似于二进制加法,有两个阶数一样的二项树就合并为更大的,合并的时候判断根,大的接在小的上面</li>
<li>$T=O(logN)$</li>
</ul>
</li>
<li>
<p>Insert( )</p>
<ul>
<li>特殊情况的Merge</li>
<li>时间开销最好为O(1),最差为O(logN),即一直需要合并的时候</li>
<li>设最小的不存在的Bi,$T_p=Const(i+1)$</li>
<li>$T_{amorized}=O(1)$</li>
</ul>
</li>
<li>
<p>DeleteMin(H)</p>
<ul>
<li>先找到这个最小值在哪个Bk中 //O(logN)</li>
<li>在$H$中删除$B_k$得到$H’$ //O(1)</li>
<li>将$B_k$的根删掉,$B_k$变成了$B_{k-1},…,B_1,B_0$记为$H’'$ //O(logN)</li>
<li>合并$H’,H’'$ //O(logN)</li>
</ul>
</li>
<li>
<p>【讨论】怎么保证删掉一个根节点后找到它的子树们</p>
</li>
<li>
<p>答：使用左儿子右兄弟的方法。Root的左边就是儿子儿子的右边就是另外的儿子。</p>
</li>
<li>
<p>【讨论】使用左儿子右兄弟的方式，子树的高度的排序是怎么样的？</p>
</li>
<li>
<p>答：<strong>从大到小</strong>的排序，便于合并，只需要改变根节点的儿子即可保证O(1)，从小到大则需要不断扫描。</p>
</li>
</ul>
<h2 id="2-Algorithms">2. Algorithms</h2>
<h3 id="2-1-BackTracking">2.1 BackTracking</h3>
<ul>
<li>回溯法：相当于枚举所有的可能解，但是这个枚举加上了一定的剪枝</li>
<li>缺点：十分复杂，耗时长</li>
</ul>
<h4 id="2-1-1-Basic-Idea">2.1.1 Basic Idea</h4>
<p>生成解，已经生成了前i个解$(x_1,x_2,…,x_i)$,$x_k∈S_k(解空间)$</p>
<p>要添加新元素$x_{i+1}^{(1)}∈X_{i+1}(第i个解集)$</p>
<p>检查是否满足要求,若满足要求则生成解$(x_1,x_2,…,x_i,x_{i+1})$</p>
<p>若不满足则找另一个$x_{i+1}$,若所有的$x_{i+1}$都不满足条件,那么进行回溯</p>
<p>解变为$(x_1,x_2,…,x_{i-1})$并且标记当前的$x_i$为无效解换下一个$x_i$,以此类推</p>
<h4 id="2-1-2-八皇后问题">2.1.2 八皇后问题</h4>
<ul>
<li>
<p>【描述】在棋盘中找到八个位置放置皇后，使得它们都不同行且不同列，也不能同时位于对角线上</p>
</li>
<li>
<p>【Solution】一般使用DFS算法实现。</p>
</li>
</ul>
<h4 id="2-1-3-加油站问题">2.1.3 加油站问题</h4>
<ul>
<li>【描述】在一条直线上找到n个地方建立加油站，已知它们两两之间的距离，求出所有加油站的位置，假定第一个加油站的坐标是0</li>
<li>【Solution】
<ol>
<li>通过n(n-1)/2个距离算出n</li>
<li>0和最大距离说明都都有加油站</li>
<li>从D集合中找最大的进行构建,找了就从D中删除距离,失败的话就回到上一种情况.
<ul>
<li>每次检验分成靠左边和靠右边两个情况</li>
</ul>
</li>
</ol>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Reconstruct</span> <span class="params">( DistType X[ ], DistSet D, <span class="type">int</span> N, <span class="type">int</span> left, <span class="type">int</span> right</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* X[1]...X[left-1] and X[right+1]...X[N] are solved */</span></span><br><span class="line">  <span class="type">bool</span> Found = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">Is_Empty</span>( D ) )</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">/* solved */</span></span><br><span class="line">  D_max = <span class="built_in">Find_Max</span>( D );</span><br><span class="line">  <span class="comment">/* option 1：X[right] = D_max */</span></span><br><span class="line">  <span class="comment">/* check if |D_max-X[i]| in D is true for all X[i]’s that have been solved */</span></span><br><span class="line">  OK = <span class="built_in">Check</span>( D_max, N, left, right ); <span class="comment">/* pruning */</span></span><br><span class="line">  <span class="keyword">if</span> ( OK ) &#123; <span class="comment">/* add X[right] and update D */</span></span><br><span class="line">    X[right] = D_max;</span><br><span class="line">    <span class="keyword">for</span> ( i=<span class="number">1</span>; i&lt;left; i++ ) <span class="built_in">Delete</span>( |X[right]-X[i]|, D);</span><br><span class="line">    <span class="keyword">for</span> ( i=right+<span class="number">1</span>; i&lt;=N; i++ ) <span class="built_in">Delete</span>( |X[right]-X[i]|, D);</span><br><span class="line">    Found = <span class="built_in">Reconstruct</span> ( X, D, N, left, right<span class="number">-1</span> );</span><br><span class="line">    <span class="keyword">if</span> ( !Found ) &#123; <span class="comment">/* if does not work, undo */</span></span><br><span class="line">      <span class="keyword">for</span> ( i=<span class="number">1</span>; i&lt;left; i++ ) <span class="built_in">Insert</span>( |X[right]-X[i]|, D);</span><br><span class="line">      <span class="keyword">for</span> ( i=right+<span class="number">1</span>; i&lt;=N; i++ ) <span class="built_in">Insert</span>( |X[right]-X[i]|, D);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* finish checking option 1 */</span></span><br><span class="line">  <span class="keyword">if</span> ( !Found ) &#123; <span class="comment">/* if option 1 does not work */</span></span><br><span class="line">    <span class="comment">/* option 2: X[left] = X[N]-D_max */</span></span><br><span class="line">    OK = <span class="built_in">Check</span>( X[N]-D_max, N, left, right );</span><br><span class="line">  <span class="keyword">if</span> ( OK ) &#123;</span><br><span class="line">    X[left] = X[N] – D_max;</span><br><span class="line">    <span class="keyword">for</span> ( i=<span class="number">1</span>; i&lt;left; i++ ) <span class="built_in">Delete</span>( |X[left]-X[i]|, D);</span><br><span class="line">    <span class="keyword">for</span> ( i=right+<span class="number">1</span>; i&lt;=N; i++ ) <span class="built_in">Delete</span>( |X[left]-X[i]|, D);</span><br><span class="line">    Found = <span class="built_in">Reconstruct</span> (X, D, N, left+<span class="number">1</span>, right );</span><br><span class="line">    <span class="keyword">if</span> ( !Found ) &#123;</span><br><span class="line">      <span class="keyword">for</span> ( i=<span class="number">1</span>; i&lt;left; i++ ) <span class="built_in">Insert</span>( |X[left]-X[i]|, D);</span><br><span class="line">      <span class="keyword">for</span> ( i=right+<span class="number">1</span>; i&lt;=N; i++ ) <span class="built_in">Insert</span>( |X[left]-X[i]|,D);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* finish checking option 2 */</span></span><br><span class="line">  &#125; <span class="comment">/* finish checking all the options */</span></span><br><span class="line">  <span class="keyword">return</span> Found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-3-回溯算法的模板">2.1.3 回溯算法的模板</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Backtracking</span> <span class="params">( <span class="type">int</span> i )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">bool</span> Found = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> ( i &gt; N )</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//返回N维的解</span></span><br><span class="line">  <span class="keyword">for</span> ( each xi in Si ) &#123;</span><br><span class="line">        <span class="comment">//检验加入了xi后满不满足条件</span></span><br><span class="line">    OK = <span class="built_in">Check</span>((x1, …, xi) , R );</span><br><span class="line">    <span class="keyword">if</span> ( OK ) &#123;<span class="comment">//满足</span></span><br><span class="line">      Count xi in;<span class="comment">//加入解集</span></span><br><span class="line">      Found = <span class="built_in">Backtracking</span>( i+<span class="number">1</span> );<span class="comment">//找下一个解</span></span><br><span class="line">      <span class="keyword">if</span> (!Found )<span class="comment">//没找到</span></span><br><span class="line">      <span class="built_in">Undo</span>( i ); <span class="comment">//undo,回到i-1维解集,算下一个xi</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( Found ) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">//全找完了也没找到返回false</span></span><br><span class="line">  <span class="keyword">return</span> Found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>回溯选择的方式:应该选择<strong>从少到多</strong>的回溯方式,可以在<strong>剪枝的情况下排除更多的情况</strong></li>
</ul>
<h4 id="2-1-4-Tic-Tac-Toe">2.1.4 Tic-Tac-Toe</h4>
<ul>
<li>AI下棋问题:需要推算出所有可能的情况并且选择当前胜率最高的情况往下走</li>
<li>MinMax Strategy问题:
<ul>
<li>人需要最小化当前情况P的可能赢的情况，而AI要将它最大化</li>
<li>goodness函数$f§=W_{AI}-W_{Human}$，W是当前情况下某一方可能赢的所有结果，不需要考虑另一方后面会怎么下，只要计算自己在当前局势下的任何可以赢的方法.</li>
</ul>
</li>
</ul>
<h4 id="2-1-5-剪枝">2.1.5 剪枝</h4>
<ul>
<li>
<p>规则:每次在max里向下取最大的，在min里向下取最小的，并且上面的值是由下一层的取出来得到的，对于不会影响上一层取值的点就可以进行剪枝</p>
<ul>
<li>
<p>α prun<img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220621203726485.png"> alt=“image-20220621203726485” style=“zoom:33%;” /&gt;</p>
</li>
<li>
<p>β pr<img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220621203738307.png"> alt=“image-20220621203738307” style=“zoom:33%;” /&gt;</p>
</li>
</ul>
</li>
<li>
<p>可以把Nsize的game tree限制为搜索${O(\sqrt N)}$个节点</p>
</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">What makes the time complexity analysis of a backtracking algorithm very difficult is that the number of solutions that do satisfy the restriction is hard to estimate.（True）</span><br><span class="line"></span><br><span class="line">What makes the time complexity analysis of a backtracking algorithm very difficult is that the sizes of solution spaces may vary.（False）</span><br></pre></td></tr></table></figure>
<h3 id="2-2-Conquer-分治法">2.2 Conquer 分治法</h3>
<ul>
<li>
<p>Divide:把问题分成几个子问题</p>
</li>
<li>
<p>Conquer:子问题继续迭代解决</p>
</li>
<li>
<p>Combine:将子问题的解合并为原本问题的解</p>
<p>能用分治法解决的问题:1. 最大子序列问题(每次分两半,找左右找链接后是否为最大O(NlogN) 2. 树遍历 3. 归并,快排</p>
</li>
</ul>
<h4 id="2-2-1-Closest-Points-Problem">2.2.1 Closest Points Problem</h4>
<ul>
<li>对于N个点，最次的方法就是搜索N(N-1)/2次求出最短距离</li>
<li>分治法思路:
<ul>
<li>首先将平面分为两个区域则问题分成三个子问题:右侧最近点对、左侧最近点对、异侧最近点对。
<ul>
<li>要按照x或者y坐标排序后分治</li>
</ul>
</li>
<li>$T(N)=3T(N/3)+f(N)$总的时间复杂度为$O(NlogN)$</li>
</ul>
</li>
</ul>
<h4 id="2-2-4-基本的迭代">2.2.4 基本的迭代</h4>
<p>$T(N)=aT(N/b)+f(N)$</p>
<ol>
<li>
<p>Substitution Method</p>
<ul>
<li>就是猜加证明</li>
</ul>
</li>
<li>
<p>Recursion tree Method</p>
<ul>
<li>f(N)就是合并的代价</li>
<li>画出树来,底层叶节点个数就是总的真实的计算的花费时间</li>
<li>树高与合并有关,树高h则合并h次<img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220621212225851.png"> alt=“image-20220621212225851” style=“zoom:70%;” /&gt;</li>
</ul>
</li>
<li>
<p>Master Method</p>
<ul>
<li>
<p>公式法对于$T(N)=aT(N/b)+f(N)$</p>
<ol>
<li>$f(N)=O(N^{log_ba-\epsilon})$上界则$T(N)=Θ(N^{log_ba})$//确界</li>
<li>$f(N)=Θ(N^{log_ba})$确界则$T(N)=Θ(N^{log_ba}logN)$</li>
<li>$f(N)=Ω(N^{log_ba+\epsilon})$下界并且$af(N/b)&lt;cf(N)$对某个c&lt;1和所有足够大的N成立,则$T(N)=Θ(f(N))$</li>
</ol>
</li>
<li>
<p>总结起来就是三种情况,$N^{log_ba}$的渐进上界,等价和渐进下界</p>
</li>
</ul>
</li>
</ol>
<ul>
<li>
<p>总结的公式:</p>
<ul>
<li>对于$T(N)=aT(N/b)+Θ(N^klog^pN)$</li>
</ul>
</li>
</ul>
<p>$$<br>
T(N)=\left{<br>
\begin{matrix}<br>
O(N^{log_ba})---------ifa&gt;b^k\<br>
O(N^k{log^{p+1}N})-------ifa=b^k\<br>
O(N^k{log^{p}N})--------ifa&lt;b^k\<br>
\end{matrix}<br>
\right.<br>
$$</p>
<h3 id="2-3-Dynamic-Programming-动态规划">2.3 Dynamic Programming 动态规划</h3>
<ul>
<li>
<p>只解决一次子问题，并且适应储存空间记录子问题的结果而不是像递归一样每一次都要重新算。</p>
</li>
<li>
<p>【例题】Ordering Matrix Multiplications：给出n个矩阵相乘，要找到一种排列方式使得矩阵相乘的开销最小：</p>
<ul>
<li>
<p>传统的算法：计算每一种排列：</p>
<ul>
<li>令$b_n$=计算n个矩阵相乘的顺序数.</li>
<li>$M_{ij}=M_i·M_{i+1}…·M_j$,则$b_n=\sum_{i=1}^{n-1}b_ib_{n-i}$</li>
<li>$b_n=O(\frac{4^n}{n\sqrt n})$</li>
</ul>
</li>
<li>
<p>动态规划:</p>
<ul>
<li>设$m_{ij}$是计算$M_i·M_{i+1}…·M_j$的最小时间开销,那么设$M_i$是$r_{i-1}*r_i$的尺寸</li>
</ul>
</li>
</ul>
</li>
<li>
<p>$$<br>
m_{ij}=\left{<br>
\begin{matrix}<br>
0-----if\ i=j\<br>
min_{i≤l＜j}{m_{i,l}+m_{l+1,j}+r_{i-1}r_lr_j}—if\ j＞i<br>
\end{matrix}<br>
\right.<br>
$$</p>
</li>
<li></li>
<li>
<p>那么动态规划问题中我们要计算的就是$m_{1,n}$</p>
<ul>
<li>
<img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220623142348979.png">
</li>
</ul>
</li>
<li>
<p>【例题】Optimal Binary Search Tree：给出N个words，$w_i$与他们的搜索权重$p_i$,将这些words安排到搜索树上,求最小的搜索时间$T(N)=\sum_{i=1}^Np_i(1+d_i)$,单个节点深度为0。</p>
</li>
<li>
<p>答：</p>
<ul>
<li>$T_{ij}=OBST\ of\ w_i,w_{i+1},…,w_j$</li>
<li>$c_{ij}=cost\ of\ T_{ij}$</li>
<li>$r_{ij}=root\ of\ T_{ij}$</li>
<li>$w_{ij}=weight\ of\ T_{ij}=\sum p_k$</li>
<li>由于对于$T_{ij}$可以选出一个根节点,那么这个的cost是左树的cost(这里应该是$w_{ij}$+$c_{ij}$)和右树的cost加上搜索根节点的cost</li>
<li>则$c_{ij}=p_k+cost(L)+cost®+weight(L)+weight®$</li>
<li>$c_{ij}=p_k+c_{i,k-1}+c_{k+1,j}+w_{i,k-1},w_{k+1,j}$</li>
<li>$c_{ij}=w_{ij}+c_{i,k-1}+c_{k+1,j}$</li>
<li>$c_{ij}=min_{i＜l≤j}{w_{ij}+c_{i,k-1}+c_{k+1,j}}$</li>
</ul>
<img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220623173525510.png">
</li>
<li>
<p>【例题】最短路径问题：所有的$v_i,v_j$点对都有一个距离,找出某两点的最短距离</p>
</li>
<li>
<p>答:</p>
<ul>
<li>【方法一】单源最短路径的dijkstra算法</li>
<li>【方法二】动态规划</li>
<li>我们设$D^k[i][j]$为从i点出发经过<strong>前k个点作为中转节点</strong>的一部分到达j点的最短路径</li>
<li>那我们所求的就是$D^{N-1}[i][j]$</li>
<li>则首先定义$D^{-1}[i][j]$为i直接到j的路径</li>
<li>状态转移?</li>
<li>从i到j且以k个点为中转的方法:
<ul>
<li>i→k点→j,<strong>即经过k点</strong></li>
<li>i→前k-1个点→j,<strong>即不经过k点</strong>那么可以简化为k-1点为中转站</li>
</ul>
</li>
<li>则$D^k[i][j]=min{D^{k-1}[i][j],D^{k-1}[i][k]+D^{k-1}[k][j]}$</li>
<li>
<img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220623175126008.png">
</li>
</ul>
</li>
<li>
<p>如何设计DP算法?</p>
<ul>
<li>刻画一个最优解【设最优解状态】</li>
<li>递归地定义最优值【状态转移方程】</li>
<li>按某种顺序计算这些值</li>
<li>重构求解策略</li>
</ul>
</li>
<li>
<p>【例题】流水线问题,两条流水线之间可以互相传递</p>
</li>
<li>
<img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220623175938809.png">
</li>
<li>
<p>答:</p>
<ul>
<li>
<p>设$s(t_{i_0},t_{i_1})$为第i个阶段的上下流水线所需的最小时间</p>
</li>
<li>
<p>则$s(t_{\ {i+1}<em>0},t</em>{\ {i+1}_1})$中</p>
<ul>
<li>$t_{\ {i+1}<em>0}=min{t</em>{i_0}+t_{0,i+1},t_{i_1}+t_{1-&gt;0,i+1}}$</li>
<li>$t_{\ {i+1}<em>1}=min{t</em>{i_1}+t_{1,i+1},t_{i_0}+t_{0-&gt;1,i+1}}$</li>
</ul>
</li>
<li>
<pre><code class="language-cpp">f[0][0]=0; L[0][0]=0;
f[1][0]=0; L[1][0]=0;
for(stage=1; stage&lt;=n; stage++)&#123;
  for(line=0; line&lt;=1; line++)&#123;
    f_stay = f[ line][stage-1] + t_process[ line][stage-1];
    f_move = f[1-line][stage-1] + t_transit[1-line][stage-1];
    if (f_stay&lt;f_move)&#123;
      f[line][stage] = f_stay;
      L[line][stage] = line;
    &#125;
    else &#123;
      f[line][stage] = f_move;
      L[line][stage] = 1-line;
    &#125;
  &#125;
&#125;
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- 【注意】**若状态之间存在依赖关系，那么不能使用动态规划**</span><br><span class="line"></span><br><span class="line">- 【例题】切杆问题：有一根长为L的杆子，有价格表，代表杆子长度从<span class="number">1</span>到L的价格，求最大的收益？</span><br><span class="line"></span><br><span class="line">- 答：</span><br><span class="line"></span><br><span class="line">  - 设长度为n的杆子的最大收益为<span class="symbol">$</span>R_n<span class="symbol">$</span></span><br><span class="line">  - 那么对于<span class="symbol">$</span>R_n<span class="symbol">$</span>,收益最大有两种情况:单条长度为n最大收益,把n分为了i和n-i把这两种长度的最大收益相加</span><br><span class="line">  - <span class="symbol">$</span>R_n=<span class="built_in">max</span>\&#123;P_n,max_&#123;<span class="number">1</span>≤i＜N&#125;\&#123;R_i+R_&#123;n-i&#125;\&#125;\&#125;<span class="symbol">$</span></span><br><span class="line"></span><br><span class="line">- 【例题】<span class="number">01</span>背包问题：N个物品重量<span class="symbol">$</span>w[<span class="number">1</span>],w[<span class="number">2</span>],...,w[n]<span class="symbol">$</span>,价值为<span class="symbol">$</span>p[<span class="number">1</span>],p[<span class="number">2</span>],..,p[n]<span class="symbol">$</span>现有背包最大载重量为W,求最大能够装下多少价值的物品,物品不能切分</span><br><span class="line"></span><br><span class="line">- 答:</span><br><span class="line"></span><br><span class="line">  - 设<span class="symbol">$</span>dp[i][j]<span class="symbol">$</span>表示前i件物品装进j载重的背包的最大价值</span><br><span class="line">  - 有两种情况:第i件物品装不进来,那么一定是<span class="symbol">$</span>dp[i][j]=dp[i<span class="number">-1</span>][j]<span class="symbol">$</span></span><br><span class="line">  - 否则就是装的进来,要比较一下两种情况,一是装进去二是不装进去</span><br><span class="line">  - <span class="symbol">$</span>dp[i][j]=<span class="built_in">max</span>\&#123;dp[i<span class="number">-1</span>][j],p[i]+dp[i<span class="number">-1</span>][j-w[i]]\&#125;<span class="symbol">$</span></span><br><span class="line"></span><br><span class="line">### <span class="number">2.4</span> Greedy Algorithm 贪心算法</span><br><span class="line"></span><br><span class="line">- 定义:每一步做最优的决策即**局部最优**,策略是不变的,决策出来的解直接**作为最终解的一部分**,不进行回溯,但是**不一定是全局最优解**</span><br><span class="line"></span><br><span class="line">- 【例题】Activity Select Problem：</span><br><span class="line"></span><br><span class="line">  - 给出一系列的课<span class="symbol">$</span>a_1,a_2,..,a_n<span class="symbol">$</span>,每一个课都有时间(<span class="symbol">$</span>s_i,f_i<span class="symbol">$</span>)</span><br><span class="line">  - 选最大兼容子课</span><br><span class="line">    - 贪心:最早开始,时间最短,交点最少(冲突最少)都是错的</span><br><span class="line">    - 正确的贪心:最早结束,即让资源尽快<span class="keyword">free</span></span><br><span class="line"></span><br><span class="line">- Greedy Strategy设计</span><br><span class="line"></span><br><span class="line">  - 指定贪心策略产生子问题</span><br><span class="line">  - 保证贪心选择正确,最优解中有贪心解</span><br><span class="line">  - 最优子结构</span><br><span class="line"></span><br><span class="line">- 【例题】哈夫曼编码:给出一些字符，我们要对字符产生唯一的编码且要保证可以解码，如a，u，x，z，我们可以分别普通编码为<span class="number">00</span>，<span class="number">01</span>，<span class="number">10</span>，<span class="number">11</span>，为了能够解码，我们需要保证一个字符编码不能成为其他字符编码的前缀。因此我们其实可以使用更加简洁的哈夫曼编码：a=<span class="number">0</span>，u=<span class="number">110</span>，x=<span class="number">10</span>，z=<span class="number">111</span>。给出n个字符，以及他们的出现频率我们要使得编码长度最小，求出哈夫曼编码</span><br><span class="line"></span><br><span class="line">- 答：</span><br><span class="line"></span><br><span class="line">  ```cpp</span><br><span class="line">  void Huffman ( PriorityQueue  heap[ ],  int  C )</span><br><span class="line">  &#123;   consider the C characters as C single node <span class="keyword">binary</span> trees,</span><br><span class="line">       <span class="keyword">and</span> initialize them into a <span class="built_in">min</span> heap;</span><br><span class="line">       <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt; C; i++ ) &#123; </span><br><span class="line">          create a new node;</span><br><span class="line">          <span class="comment">/* be greedy here */</span></span><br><span class="line">          delete root from <span class="built_in">min</span> heap <span class="keyword">and</span> attach it to left_child of node;</span><br><span class="line">          delete root from <span class="built_in">min</span> heap <span class="keyword">and</span> attach it to right_child of node;</span><br><span class="line">           <span class="comment">//先用heap选两个频率最小的合成一个节点，节点频率为两个之和</span></span><br><span class="line">          weight of node = <span class="keyword">sum</span> of weights of its children;</span><br><span class="line">          <span class="comment">/* weight of a tree = sum of the frequencies of its leaves */</span></span><br><span class="line">           <span class="comment">//放回堆里继续选择</span></span><br><span class="line">          insert node into <span class="built_in">min</span> heap;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="2-5-NP-Completeness-NP完全性">2.5 NP-Completeness NP完全性</h3>
<ul>
<li>用于判定一个问题的难/易：说的是yes or no problem
<ul>
<li>Euler回路判断问题：所有边访问一遍，那么条件为无向图的所有点度为偶数O(N)，属于NP因为能在多项时间内验证解，也是P的能在多项式时间内给出解。</li>
<li>Hamilton回路问题：包含每一个节点，不存在多项式时间内的解法。</li>
<li>单源最短路径无权重：存在多项式时间的解法</li>
<li>停机问题：编译器不能发现所有的无限循环</li>
</ul>
</li>
<li>图灵机 Turing Machine
<ul>
<li>组成：无限的Memory和扫描头
<ul>
<li>scanner 上有若干head，每一个扫描头一次只能指向一个state，并且一次只能左右移动一格</li>
</ul>
</li>
<li>可以执行的操作：
<ul>
<li>change the finite control state 改变</li>
<li>erase the symbol in the unit currently pointed by head and write a new symbol in清除并写入</li>
<li>Head moves on unit to left or right or stays at its current position 左右移动或保持不动</li>
</ul>
</li>
<li>确定性图灵机：对于给定的输入每一步的执行都是唯一的</li>
<li>不确定性图灵机：对于给定的输入可以自由选择执行的下一步且会选择正确的solution，即能够在<strong>多项时间内解决NP问题</strong></li>
</ul>
</li>
<li>P problem
<ul>
<li>在多项式时间内可解的问题</li>
<li>P问题指可以在多项式时间内求解的问题，例如：时间复杂度为O(nlog(n))的快速排序和堆排序，的算法是指数时间算法。</li>
</ul>
</li>
<li>NP problem
<ul>
<li>不一定在多项式时间内可以给出一个正确解但是给了你一个解之后可以在多项式时间内判断这个解是否正确。</li>
<li>如Hamilton回路是NP问题，因为验证一条路是否恰好经过了每一个顶点可在多项式时间内完成，但是找出一个Hamilton回路却要穷举所有可能性，不能直接求解</li>
<li><strong>不是所有的</strong>decidable problem都是NP问题</li>
</ul>
</li>
<li>【P和NP的关系】<strong>人类还未解决的问题是</strong>：是否所有的NP问题都是P类问题
<ul>
<li>$P\sub NP$</li>
<li><strong>即P问题一定是NP问题</strong></li>
</ul>
</li>
<li>【约化/归约/Reduce】
<ul>
<li>概念：如果能找到这样一个变化法则，对任意一个程序A的输入，都能按这个法则变换成程序B的输入，使两程序的输出相同，那么我们说，问题A可约化为问题B，即可以用问题B的解法解决问题A，或者说，问题A可以“变成”问题B。 如：一元一次方程可以“归约”为一元二次方程。这里说的一般是<strong>多项式时间内的归约</strong>，即把A变成B需要多项式时间，<strong>但是B的解决不一定是多项式时间的</strong></li>
<li>性质：传递性，A可以约化为B，B可以约化为C，那么C可以约化为A</li>
<li>意义：把A归约为B，<strong>B的时间复杂度高于或者等于A的时间复杂度</strong>。也就是说，问题A不比问题B难。</li>
<li>要求：多项式时间内的归约</li>
</ul>
</li>
<li>NP-Complete Problem
<ul>
<li>一个NPC问题满足以下两个条件：
<ul>
<li><strong>一个NPC问题可以从任何NP问题通过多项式规约得到</strong></li>
<li>
<img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220623222233446.png">
</li>
<li><strong>问题本身是NP问题</strong></li>
<li>NPC问题可以互相归约</li>
</ul>
</li>
<li>所以显然NP完全问题具有如下性质：它可以在多项式时间内求解，当且仅当所有的其他的NP完全问题也可以在多项式时间内求解。这样一来,只要我们找到一个NPC问题的多项式解，所有的NP问题都可以多项式时间内约化成这个NPC问题，再用多项式时间解决，这样NP就等于P了</li>
</ul>
</li>
<li>NP-Hard Problem
<ul>
<li>一个NPH问题满足以下条件：
<ul>
<li><strong>可以由任何NP问题通过多项式归约得到</strong></li>
</ul>
</li>
<li>可以不是NP问题，这说明NPH问题的范围比NPC问题更广</li>
<li>一个问题是NPC问题那么一定是NPH问题</li>
</ul>
</li>
</ul>
<img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220623225121568.png">
<h3 id="2-6-Approximation-近似算法">2.6 Approximation 近似算法</h3>
<ul>
<li>近似比
<ul>
<li>对于任何规模的n输入,C算法的cost,C*为优化后的cost,那么1≤max{$\frac{C}{C^{\ *}\ },\frac{C^{\ *}\ }{C}$}≤ρ(n)</li>
<li>如果一个算法的近似率达到了ρ(n)则该算法可以被称为一个ρ(n)-近似算法</li>
</ul>
</li>
<li>approximation scheme:除了n以外还收一个参数epsilon影响</li>
<li>PTAS： polynomial-time approximation scheme 关于n成多项式复杂度的算法(对于特定的epsilon)</li>
<li>FPTAS：fully polynomial-time approximation scheme 关于n和 都成多项式复杂度的算法</li>
</ul>
<p>【例题】集装箱问题</p>
<ul>
<li>
<p>NextFit：</p>
<ul>
<li>策略：当前箱子放不下就放到新的箱子里去</li>
<li>性质：如果最优的方法需要M个箱子那么next fit方法使用的箱子不会超过2M-1，可以用反证法证明，最重要的条件是<strong>相邻两个箱子内的和肯定大于1</strong>，否则就会放在一个箱子里</li>
</ul>
</li>
<li>
<p>FirstFit：</p>
<ul>
<li>策略：从头找箱子，找第一个能放下item的箱子</li>
<li>性质：
<ul>
<li>可以用O(NlogN)的时间复杂度来实现这个算法</li>
<li>如果最优的方法需要M个箱子那么next fit方法使用的箱子不会超过<strong>1.7M</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<p>BestFit：</p>
<ul>
<li>策略：找到放下这个物品后剩余空间最小的箱子</li>
<li>性质：
<ul>
<li>可以用O(NlogN)的时间复杂度来实现这个算法</li>
<li>如果最优的方法需要M个箱子那么next fit方法使用的箱子不会超过<strong>1.7M</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<p>三种算法都是Online算法，Online算法所需要的箱子数不会少于最优解的5/3倍</p>
</li>
<li>
<p>OffLine Algorithm</p>
<ul>
<li>在开始装箱之前先检查一次所有的箱子并按照非递增的顺序排序，然后使用First Fit算法，这种情况下需要的箱子的个数不会超过(11M+6)/9 简单的贪心方法会给出一些比较好的结果</li>
</ul>
</li>
<li>
<p>【例题】Knapsack Problme 背包问题</p>
<ul>
<li>将N个物品装入容量为M的背包里，每个物品有自己的重量Wi和收益Pi，最终目标是要让收益最大化(近似比2)</li>
<li>$p_{max}≤p_{opt}(最优解)≤p_{frac}(物品可以切分的情况)$</li>
<li>$p_{max}≤p_{Greedy}$</li>
<li>$p_{opt}≤p_{frac}=p_{Greedy}+p_{cut}≤p_{Greedy}+p_{max}$</li>
<li>$\frac{p_{opt}\ }{p_{Greedy}\ }≤1+\frac{p_{max}\ }{p_{Greedy}\ }≤2$</li>
</ul>
</li>
<li>
<p>【例题】K-center problem</p>
<ul>
<li>
<p>在给定的N个点的平面中选择K个点(不一定是已有的点)作为中心作圆覆盖所有的点，要求使得这些圆中的最大半径(distance)取得最小值</p>
</li>
<li>
<p>贪心1：</p>
<ul>
<li>假设所有的center都在点上（将候选集从无穷降下来）</li>
<li>设最优解为C，半径为r(C*)，那么由于贪心解中心点离其他被覆盖的点距离至多为r，要使得这个r在最优解C*上也正确，则需要r=2r(C*)</li>
<li>近似比为2</li>
<li>O($N^2logN$)</li>
</ul>
</li>
<li>
<pre><code class="language-cpp">//知道最优解的情况
Centers  Greedy-2r ( Sites S[ ], int n, int K, double r )
&#123;   Sites  S’[ ] = S[ ]; /* S’ is the set of the remaining sites */
    Centers  C[ ] = 空集;
    while ( S’[ ] != 空集 ) &#123;
        Select any s from S’ and add it to C;
        Delete all s’ from S’ that are at dist(s’, s) ≤ 2r;
    &#125; /* end-while */
    if ( |C| ≤ K ) return C;
    else ERROR(No set of K centers with covering radius at most r);
&#125;

<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 贪心<span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">  - 二分法找r，<span class="meta">$0</span>&lt;r&lt;r_&#123;max&#125;$</span><br><span class="line">  - O($N^<span class="number">2</span>logN$)</span><br><span class="line">  - 每次随机选择点改为中心点，找离这个中心点最远的点si，把si改为中心点</span><br><span class="line">  - 近似比为<span class="number">2</span></span><br><span class="line"></span><br><span class="line">- ```cpp</span><br><span class="line">  Centers  Greedy-Kcenter ( Sites S[ ], <span class="type">int</span> n, <span class="type">int</span> K )</span><br><span class="line">  &#123;   Centers  C[ ] = 空集;</span><br><span class="line">      <span class="keyword">Select</span> <span class="keyword">any</span> s <span class="keyword">from</span> S <span class="keyword">and</span> <span class="keyword">add</span> it <span class="keyword">to</span> C;</span><br><span class="line">      <span class="keyword">while</span> ( |C| &lt; K ) &#123;</span><br><span class="line">          <span class="keyword">Select</span> s <span class="keyword">from</span> S <span class="keyword">with</span> maximum dist(s, C);</span><br><span class="line">          <span class="keyword">Add</span> s it <span class="keyword">to</span> C;</span><br><span class="line">      &#125; <span class="comment">/* end-while */</span></span><br><span class="line">      <span class="keyword">return</span> C;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
<li>
<p>除非P=NP，否则没有ρ-近似比解法对任何的ρ成立。</p>
</li>
<li>
<img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220624084833309.png">
</li>
</ul>
<h3 id="2-7-Local-Search-局部搜索">2.7 Local Search 局部搜索</h3>
<ul>
<li>
<p>和贪心算法有区别，贪心算法不是局部搜索的特例</p>
</li>
<li>
<p>局部搜索的框架</p>
<ul>
<li>
<p>Local：局部最优是一个领域内的最佳解决方案</p>
<ul>
<li>邻域Neighborhoods和邻域最优解：设S为目前的解，S~S’记为邻域，S‘为邻域最优的解，邻居是对目前解S的小小的改动</li>
<li>N(S)：为邻域</li>
</ul>
</li>
<li>
<p>Search：从邻域的一个点触发找到局部最优解，哪个点？</p>
<ul>
<li>Grandient Descent：梯度下降法，找梯度下降最快的方向优化</li>
</ul>
</li>
<li>
<pre><code class="language-cpp">SolutionType Gradient_descent()
&#123;   Start from a feasible solution S ∈ FS ;
    MinCost = cost(S);
    while (1) &#123;
        S’ = Search( N(S) ); /* find the best S’ in N(S) */
        CurrentCost = cost(S’);
        if ( CurrentCost &lt; MinCost ) &#123;
            MinCost = CurrentCost;    S = S’;
        &#125;
        //如果邻域内有更好的解则替换
        else  break;
        //否则说明当前为最优的
    &#125;
    return S;
&#125;
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">-</span> 【例题】VCP问题顶点覆盖：给出无向图G=(V,E),找到最小的V的子集S,使得每一条边的至少一个顶点在S中.</span><br><span class="line"></span><br><span class="line"><span class="bullet">  -</span> 局部搜索算法1:</span><br><span class="line"></span><br><span class="line"><span class="bullet">    1.</span> 先找一个<span class="strong">**起点(可行解)**</span>我们选择所有点作为S</span><br><span class="line"><span class="bullet">    2.</span> cost(S)=|S|</span><br><span class="line"><span class="bullet">    3.</span> S~S&#x27;邻域:删除一个点成为邻居</span><br><span class="line"><span class="bullet">    4.</span> 这种方法对特殊点有要求(不好)</span><br><span class="line"></span><br><span class="line"><span class="bullet">  -</span> 优化方案1:</span><br><span class="line"></span><br><span class="line"><span class="bullet">    -</span> 在邻域中随机找S&#x27;</span><br><span class="line"><span class="bullet">    -</span> 如果邻居更差那么有几率($e^&#123;-\frac&#123;\Delta cost&#125;&#123;kT&#125;\ &#125;$)使用更差的解替换当前的解</span><br><span class="line"><span class="bullet">    -</span> <span class="strong">**可能使用更差的解**</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">  -</span> <span class="code">```cpp</span></span><br><span class="line"><span class="code">    SolutionType Metropolis()</span></span><br><span class="line"><span class="code">    &#123;   Define constants k and T;</span></span><br><span class="line"><span class="code">        Start from a feasible solution S  FS ;</span></span><br><span class="line"><span class="code">        MinCost = cost(S);</span></span><br><span class="line"><span class="code">        while (1) &#123;</span></span><br><span class="line"><span class="code">            S’ = Randomly chosen from N(S); </span></span><br><span class="line"><span class="code">            CurrentCost = cost(S’);</span></span><br><span class="line"><span class="code">            if ( CurrentCost &lt; MinCost ) &#123;</span></span><br><span class="line"><span class="code">                MinCost = CurrentCost; S = S’;</span></span><br><span class="line"><span class="code">            &#125;</span></span><br><span class="line"><span class="code">            else &#123;</span></span><br><span class="line"><span class="code">                With a probability,let S = S’;</span></span><br><span class="line"><span class="code">                else break;</span></span><br><span class="line"><span class="code">            &#125;</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">        return S;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li>
<p>优化方案2:</p>
<ul>
<li>使用模拟退火</li>
<li>定义温度T:T越大更多使用乱序,替换概率大</li>
<li>T在不断下降</li>
</ul>
</li>
</ul>
</li>
<li>
<p>【例题】Hopfield Neural Networks</p>
<ul>
<li>
<p>图G=(V,E),每一条边有整数的边权w（正负都有）,如果$w_e&lt;0,e=(u,v)$,则u和v想要有<strong>同样的状态</strong>(要么都是+1,有么都是-1),如果$w_e&gt;0$,则u和v想要不同的状态(一个正一个负).</p>
<p>如果$w_e·s_u·s_v$&lt;0则说这个边e为好边,否则为坏边</p>
<p>如果一个节点的所有边中:*<em>好边边权和≥坏边边权和</em><img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220624092001137.png"> alt=“image-20220624092001137” style=“zoom:33%;” /&gt;</p>
<p>当所有的节点都被满足,则记为<code>稳定态</code></p>
</li>
<li>
<p>Local Search解法:</p>
<ul>
<li>起点:<strong>全部同色</strong></li>
<li>while(!stable(S))不稳定</li>
<li>u=GetUnsatisfied(S)将S中的不满足的节点拿出</li>
<li>$s_u=-s_u$</li>
</ul>
</li>
<li>
<pre><code class="language-cpp">ConfigType State_flipping()
&#123;
    Start from an arbitrary configuration S;
    while ( ! IsStable(S) ) &#123;
        u = GetUnsatisfied(S);
        su = - su;
    &#125;
    return S;
&#125;
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 结论<span class="symbol">:</span>一定会停下来成为稳定态,最多迭代<span class="variable">$\</span>sum_e|<span class="params">w_e</span>|<span class="variable">$次</span></span><br><span class="line"></span><br><span class="line">    - <span class="variable">$\</span>Phi(S)=\sum_&#123;e\ is\ good&#125;|<span class="params">w_e</span>|<span class="variable">$</span></span><br><span class="line"><span class="variable"></span>    - 设u是不满足的</span><br><span class="line">      - <span class="variable">$\</span>sum_&#123;e∈(u,v)\&amp;\ e\ is\ bad&#125;|<span class="params">w_e</span>|≥\sum_&#123;e∈(u,v)\&amp;\ e\ is\ good&#125;|<span class="params">w_e</span>|+<span class="number">1</span><span class="variable">$</span></span><br><span class="line"><span class="variable"></span>      - 即坏边边权和至少为好边边权和加<span class="number">1</span></span><br><span class="line">    - 将u的颜色反转,会使得跟u有关的e从坏边变好边,好边变坏边.</span><br><span class="line">      - <span class="variable">$\</span>Phi(S<span class="string">&#x27;)=\Phi(S)-\sum_&#123;e∈(u&#x27;</span>,v)\&amp;\ e\ is\ bad&#125;|<span class="params">w_e</span>|+\sum_&#123;e∈(u<span class="string">&#x27;,v)\&amp;\ e\ is\ good&#125;|w_e|$</span></span><br><span class="line"><span class="string">      - 那么由u为不满足的得知$\Phi(S&#x27;</span>)≥\Phi(S)+<span class="number">1</span><span class="variable">$</span></span><br><span class="line"><span class="variable"></span></span><br><span class="line">  - 这是多项式时间吗<span class="string">?*</span>*不是**,因为时间为与W有关的,实际的复杂度与logW有关,是伪多项式的</span><br><span class="line"></span><br><span class="line">- 【例题】最大割问题<span class="symbol">:</span>给一个无向图G=(u,v)每条边都有正边权<span class="variable">$w</span>_e<span class="variable">$,</span>找一个分割(A,B),使得<span class="variable">$w</span>(A,B)=\sum_&#123;\\u∈A,v∈B&#125;w_&#123;uv&#125;<span class="variable">$最</span>大</span><br><span class="line"></span><br><span class="line">- 转化为Hopfield神经网络</span><br><span class="line"></span><br><span class="line"><span class="comment">### 2.8 Randomized Algorithm 随机算法</span></span><br><span class="line"></span><br><span class="line">- 用随机的决策处理最坏的情况</span><br><span class="line"></span><br><span class="line">- 基本的性质：</span><br><span class="line"></span><br><span class="line">  - 用非常高的概率给出正确答案</span><br><span class="line">  - 总是正确的，并且在期望中运行的很有效率</span><br><span class="line"></span><br><span class="line">- 【例子】面试问题：</span><br><span class="line"></span><br><span class="line">  - 有M个人要雇佣，N个人要进行面试，设面试费用为<span class="variable">$C</span>_i<span class="variable">$,</span>雇佣费用为<span class="variable">$C</span>_h<span class="variable">$</span></span><br><span class="line"><span class="variable"></span></span><br><span class="line">  - <span class="variable">$c_i</span>&lt;&lt;c_h<span class="variable">$</span></span><br><span class="line"><span class="variable"></span></span><br><span class="line">  - 分析面试cost</span><br><span class="line"></span><br><span class="line">  - 全部面试再选择人总cost=<span class="variable">$O</span>(NC_i+MC_h)<span class="variable">$</span></span><br><span class="line"><span class="variable"></span></span><br><span class="line">    - <span class="symbol">solution1:</span>从第一个到最后一个每找到更好的人就雇佣,worst <span class="keyword">case</span> = O(<span class="variable">$NC</span>_h<span class="variable">$)</span></span><br><span class="line"></span><br><span class="line">      - <span class="string">``</span><span class="string">`cpp</span></span><br><span class="line"><span class="string">        int Hiring ( EventType C[ ], int N )</span></span><br><span class="line"><span class="string">        &#123;   /* candidate 0 is a least-qualified dummy candidate */</span></span><br><span class="line"><span class="string">            int Best = 0;</span></span><br><span class="line"><span class="string">            int BestQ = the quality of candidate 0;</span></span><br><span class="line"><span class="string">            for ( i=1; i&lt;=N; i++ ) &#123;</span></span><br><span class="line"><span class="string">                Qi = interview( i ); /* Ci */</span></span><br><span class="line"><span class="string">                if ( Qi &gt; BestQ ) &#123;</span></span><br><span class="line"><span class="string">                    BestQ = Qi;</span></span><br><span class="line"><span class="string">                    Best = i;</span></span><br><span class="line"><span class="string">                    hire( i );  /* Ch */</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">            return Best;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br></pre></td></tr></table></figure>

  - 这里的最坏的情况是所有人都是升序的排列,每一个人都要录取

- solution2:假设每个人都是随机来的,那么设X为录取数量

  - E[X]=$\sum_&#123;j=1&#125;^Nj·Pr[X=j]$
  - 其中Xi被录取时为1,不被录取为0
  - 那么计算每一个人被录取的概率即可算出E[X]
  - $E[x_i]=Pr[i被录取]=\frac&#123;1&#125;&#123;i&#125;$
  - $E[x]=\sum E[x_i]=lnN$
  - 花费为$O(C_hlnN+NC_i)$

- solution3:我们直接打乱顺序

  - ```cpp
    int RandomizedHiring ( EventType C[ ], int N )
    &#123;   /* candidate 0 is a least-qualified dummy candidate */
        int Best = 0;
        int BestQ = the quality of candidate 0;
    
        randomly permute the list of candidates;
    
        for ( i=1; i&lt;=N; i++ ) &#123;
            Qi = interview( i ); /* Ci */
            if ( Qi &gt; BestQ ) &#123;
                BestQ = Qi;
                Best = i;
                hire( i );  /* Ch */
            &#125;
        &#125;
    <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      - 如何生成随机顺序?</span><br><span class="line"></span><br><span class="line">        - 对于序列A[i]我们使用P[i]为随机生成的数组,使用P[i]的大小为对应相同i的A[i]排序</span><br><span class="line"></span><br><span class="line">- 【例题】在线雇佣问题</span><br><span class="line"></span><br><span class="line">  - 面试完就要给出结果,只能hire一个人,不能反悔</span><br><span class="line"></span><br><span class="line">  - 输入序列C[ ],人数N,参数k</span><br><span class="line"></span><br><span class="line">  - solution:</span><br><span class="line"></span><br><span class="line">    - 在前k次面试中试出最好的<span class="keyword">BestQ</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">    - 在从k+<span class="number">1</span>开始面试时,一旦找到比<span class="keyword">BestQ好的就选择这个人hire,并且break</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">    - ```cpp</span><br><span class="line">      int OnlineHiring ( EventType C[ ], int N, int k )</span><br><span class="line">      &#123;</span><br><span class="line">          int <span class="keyword">Best </span>= N;</span><br><span class="line">          int <span class="keyword">BestQ </span>= -  ;</span><br><span class="line">          for ( i=<span class="number">1</span><span class="comment">; i&lt;=k; i++ ) &#123;</span></span><br><span class="line">              Qi = interview( i );</span><br><span class="line">              if ( Qi &gt; <span class="keyword">BestQ </span>)   <span class="keyword">BestQ </span>= Qi;</span><br><span class="line">          &#125;</span><br><span class="line">          for ( i=k+<span class="number">1</span><span class="comment">; i&lt;=N; i++ ) &#123;</span></span><br><span class="line">              Qi = interview( i );</span><br><span class="line">              if ( Qi &gt; <span class="keyword">BestQ </span>) &#123;</span><br><span class="line">                  <span class="keyword">Best </span>= i;</span><br><span class="line">                  <span class="keyword">break;</span></span><br><span class="line"><span class="keyword"></span>              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          return <span class="keyword">Best;</span></span><br><span class="line"><span class="keyword"></span>      &#125;</span><br></pre></td></tr></table></figure>

- k的选择?多大概率得到的是最好的?

  - 设$S$为第i个是最优的,即i&gt;k,且k+1到i-1之间没有比BestQ更大的
  - $P[Best\ one\ in\ i]=\frac&#123;1&#125;&#123;N&#125;$即i是最好的概率
  - $P[No\ one\ hired\ at\ pos\ k+1\ to\ i-1]=\frac&#123;k&#125;&#123;i-1&#125;$
  - $Pr[S]=\sum_&#123;\\i=k&#125;^&#123;N-1&#125;\frac&#123;k+1&#125;&#123;N(i-1)&#125;=\frac&#123;k&#125;&#123;N&#125;\sum_&#123;i=k&#125;^&#123;N-1&#125;\&lt;img src = &quot;ADS笔记\image-20220624112801071.png&quot;&gt; alt=&quot;image-20220624112801071&quot; style=&quot;zoom:40%;&quot; /&gt;

  - 则求导知$k=\frac&#123;N&#125;&#123;e&#125;$时P最大为$\frac&#123;1&#125;&#123;e&#125;$

</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="2-9-Parallel-Algorithm-并行算法">2.9 Parallel Algorithm 并行算法</h3>
<ul>
<li>
<p>硬件并行</p>
</li>
<li>
<p>并行算法</p>
<ul>
<li>
<p>PRAM模型</p>
</li>
<li>
<p>WD模<img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220624114823335.png"> alt=“image-20220624114823335” style=“zoom:50%;” /&gt;</p>
</li>
<li>
<p>当一个proces<img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220624115122011.png"> alt=“image-20220624115122011” style=“zoom:50%;” /&gt;</p>
</li>
<li>
<p>当要<img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220624115443182.png"> alt=“image-20220624115443182” style=“zoom:50%;” /&gt;</p>
<ul>
<li>
<pre><code class="language-cpp">for Pi 1&lt;=i&lt;=n pardo//并行
  A(i)=B(i);
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 可能会产生冲突</span><br><span class="line"></span><br><span class="line">  - <span class="constructor">E(Exclusive排他)</span>REW:不可对同一位置进行读写</span><br><span class="line">  - <span class="constructor">C(Concurrent并存的)</span>REW:可以对同一位置读,不可以同时写</span><br><span class="line">  - CRCW:可读可写(冲突)</span><br><span class="line">    - Arbitrary rule 任意取一个写入</span><br><span class="line">    - Priority rule 编号最小的访问写入</span><br><span class="line">    - Common rule 写入相同时写入,否则不可写入</span><br><span class="line"></span><br><span class="line">- 【例题】输入<span class="constructor">A(1)</span>,...<span class="constructor">A(<span class="params">n</span>)</span>,计算<span class="constructor">A(1)</span>+<span class="constructor">A(2)</span>+...+<span class="constructor">A(<span class="params">n</span>)</span></span><br><span class="line"></span><br><span class="line">  - 处理器读入<span class="constructor">O(1)</span></span><br><span class="line"></span><br><span class="line">  - 二分求和<span class="constructor">O(<span class="params">logN</span>)</span></span><br><span class="line"></span><br><span class="line">    - 第一轮全部的处理器被使用</span><br><span class="line">    - 第二轮一半的处理器被使用</span><br><span class="line">    -<span class="operator"> ...</span></span><br><span class="line"><span class="operator">    </span>- 最后一轮只有两个被使用后输出总和</span><br><span class="line"></span><br><span class="line">  - &lt;img src = <span class="string">&quot;ADS笔记\image-20220624131323699.png&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">  - ```cpp</span><br><span class="line">    <span class="keyword">for</span> Pi,<span class="number">1</span>&lt;=<span class="number">1</span>&lt;n pardo:</span><br><span class="line">      <span class="constructor">B(0,<span class="params">i</span>)</span>=<span class="constructor">A(<span class="params">i</span>)</span><span class="comment">//并行读入</span></span><br><span class="line">    <span class="keyword">for</span> h=<span class="number">1</span> <span class="keyword">to</span> log<span class="constructor">_2(<span class="params">n</span>)</span> <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">if</span>(i&lt;=n/(<span class="number">2</span>^h))</span><br><span class="line">        <span class="constructor">B(<span class="params">h</span>,<span class="params">i</span>)</span>=<span class="constructor">B(<span class="params">h</span>-1,2i-1)</span>+<span class="constructor">B(<span class="params">h</span>-1,2i)</span>;</span><br><span class="line">      <span class="keyword">else</span> stay idle<span class="comment">//指令idle不做工作但也是指令</span></span><br><span class="line">        <span class="comment">//有浪费</span></span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span> output <span class="constructor">B(<span class="params">logn</span>,1)</span> <span class="keyword">else</span> stay idle</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>WD(Work Depth)模型</p>
<ul>
<li>
<pre><code class="language-cpp">for Pi,1&lt;i&lt;=n pardo:
   B(0,i):=A(i)
for h = 1 to log n 
    for Pi, 1&lt;=i&lt;=n/(2^h)  pardo
        B(h,i) := B(h-1,2i-1) + B(h-1,2i)
for i = 1 pardo
   output  B(log n, 1)
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- 如何估计一个并行算法?</span><br><span class="line"></span><br><span class="line">  - Work Load:操作的总次数W(n)</span><br><span class="line">  - Worst case running time:T(n)</span><br><span class="line">  - 设处理器个数P(n)</span><br><span class="line">  - 则<span class="symbol">$</span>W(n)=P(n)T(n)<span class="symbol">$</span></span><br><span class="line">  - 实际使用的时间=<span class="symbol">$</span>\<span class="built_in">frac</span>&#123;W(n)&#125;&#123;P&#125;<span class="symbol">$</span>,当<span class="symbol">$</span>P&lt;\<span class="built_in">frac</span>&#123;W(n)&#125;&#123;T(n)&#125;<span class="symbol">$</span>时,时间为<span class="symbol">$</span>\<span class="built_in">frac</span>&#123;W(n)&#125;&#123;p&#125;+T(n)<span class="symbol">$</span></span><br><span class="line">  - 即一个并行算法一定可以在<span class="symbol">$</span>O(\<span class="built_in">frac</span>&#123;W(n)&#125;&#123;p&#125;+T(n))<span class="symbol">$</span>内实现</span><br><span class="line"></span><br><span class="line">- 【例题】求上面WD模型解决该问题的Work Load</span><br><span class="line"></span><br><span class="line">  - WD模型的work load为<span class="symbol">$</span>n+\<span class="built_in">frac</span>&#123;n&#125;&#123;<span class="number">2</span>^<span class="number">1</span>&#125;+...+\<span class="built_in">frac</span>&#123;n&#125;&#123;<span class="number">2</span>^k&#125;=<span class="number">2</span>n<span class="symbol">$</span></span><br><span class="line">  - WD模型的W(n)=<span class="number">2</span>n,T(n)=<span class="number">2</span>+<span class="built_in">log</span> n</span><br><span class="line"></span><br><span class="line">- 【例题】求前缀和</span><br><span class="line"></span><br><span class="line">  - 输入A(<span class="number">1</span>),...A(n),计算<span class="symbol">$</span>\sum_1^<span class="number">1</span>A(i),\sum_1^<span class="number">2</span>A(i),...,\sum_1^<span class="literal">nA</span>(i)<span class="symbol">$</span></span><br><span class="line"></span><br><span class="line">  - <span class="symbol">$</span>C(h,i)=\sum_&#123;\\k=<span class="number">1</span>&#125;^&#123;\alpha&#125;A(k)<span class="symbol">$</span>,其中α为(<span class="number">0</span>,α)为节点(h,i)的最右节点</span><br><span class="line"></span><br><span class="line">    - `<span class="keyword">if</span>(i==<span class="number">1</span>)`:<span class="symbol">$</span>C(h,i)=B(h,i)<span class="symbol">$</span>,即**左路径的C(h,i)与B(h,i)相等**</span><br><span class="line">    - `<span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)`:<span class="symbol">$</span>C(h,i)=C(h+<span class="number">1</span>,i/<span class="number">2</span>)<span class="symbol">$</span>,即说明的是**同一条右路径的C(h,i)相等**</span><br><span class="line">    - `<span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">1</span>&amp;&amp;i!=<span class="number">1</span>)`:<span class="symbol">$</span>C(h,i)=C(h+<span class="number">1</span>,(i<span class="number">-1</span>)/<span class="number">2</span>)+B(h,i)<span class="symbol">$</span>,找到父亲节点的左兄弟,再加上自己的B(h,i)</span><br><span class="line"></span><br><span class="line">  - ```cpp</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">Pi</span> , <span class="number">1</span> ≤ i ≤ n pardo</span><br><span class="line">      B(<span class="number">0</span>, i) := A(i) <span class="comment">//O(1)</span></span><br><span class="line">    <span class="keyword">for</span> h = <span class="number">1</span> to <span class="built_in">log</span> n<span class="comment">//O(logn)</span></span><br><span class="line">      <span class="keyword">for</span> i , <span class="number">1</span> ≤ i ≤ n/(<span class="number">2</span>^h) pardo<span class="comment">//O(1)</span></span><br><span class="line">        B(h, i) := B(h - <span class="number">1</span>, <span class="number">2</span>i - <span class="number">1</span>) + B(h - <span class="number">1</span>, <span class="number">2</span>i)</span><br><span class="line">        <span class="comment">//先算B(h,i)</span></span><br><span class="line">    <span class="keyword">for</span> h = <span class="built_in">log</span> n to <span class="number">0</span><span class="comment">//O(logn)</span></span><br><span class="line">      <span class="keyword">for</span> i even, <span class="number">1</span> ≤ i ≤ n/(<span class="number">2</span>^h) pardo<span class="comment">//O(1)</span></span><br><span class="line">        C(h, i) := C(h + <span class="number">1</span>, i/<span class="number">2</span>)</span><br><span class="line">      <span class="keyword">for</span> i = <span class="number">1</span> pardo<span class="comment">//O(1)</span></span><br><span class="line">        C(h, <span class="number">1</span>) := B(h, <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">for</span> i odd, <span class="number">3</span> ≤ i ≤ n/(<span class="number">2</span>^h) pardo<span class="comment">//O(1)</span></span><br><span class="line">        C(h, i) := C(h + <span class="number">1</span>, (i - <span class="number">1</span>)/<span class="number">2</span>) + B(h, i)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">Pi</span> , <span class="number">1</span> ≤ i ≤ n pardo<span class="comment">//O(1)</span></span><br><span class="line">      Output C(<span class="number">0</span>, i)</span><br></pre></td></tr></table></figure>

- time = T(n) = O(logN)+O(logN)=O(logN)
- work load = W(n)=O (n)+O(n)=O(n)

</code></pre>
</li>
</ul>
</li>
<li>
<p>【例题】数组归并</p>
<ul>
<li>
<p>两个单调不减的数组AB合并为C</p>
<ul>
<li>
<p>化简问题：两个数组的元素个数m=n，且AB中的元素不重复，logn为整数</p>
</li>
<li>
<p>引入<code>RANK(j,A)</code>表示B[j]在A中位于第几位,计算A和B的所有RANK,然后用以下方法归并:</p>
<ul>
<li>
<pre><code class="language-cpp">for Pi,1≤i≤n pardo:
  C(i+RANK(i,B)):=A(i)
for Pi,1≤j≤n pardo:
  C(i+RANK(j,A)):=B(i)
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 只要给出rank函数,我们可以在<span class="built_in">O</span>(<span class="number">1</span>)时间内和<span class="built_in">O</span>(n+m)的workload中给出合并</span><br><span class="line"></span><br><span class="line">- RANK函数</span><br><span class="line"></span><br><span class="line">  - 二分搜索:</span><br><span class="line"></span><br><span class="line">    - ```cpp</span><br><span class="line">      <span class="keyword">for</span> Pi , <span class="number">1</span> ≤ <span class="selector-tag">i</span> ≤ n  pardo:</span><br><span class="line">          <span class="built_in">RANK</span>(<span class="selector-tag">i</span>, B) := <span class="built_in">BS</span>(<span class="built_in">A</span>(i), B)</span><br><span class="line">          <span class="built_in">RANK</span>(<span class="selector-tag">i</span>, A) := <span class="built_in">BS</span>(<span class="built_in">B</span>(i), A)</span><br></pre></td></tr></table></figure>

- T(n)=O(logn)

- W(n)=O(nlogn)

</code></pre>
</li>
<li>
<p>Serial Ranking</p>
<ul>
<li>
<pre><code class="language-cpp">i = j = 0; 
while ( i ≤ n || j ≤ m ) &#123;
    if ( A(i+1) &lt; B(j+1) )
        RANK(++i, B) = j;
    else RANK(++j, A) = i;
&#125;
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        - <span class="constructor">T(<span class="params">n</span>)</span>=<span class="constructor">W(<span class="params">n</span>)</span>=<span class="constructor">O(<span class="params">n</span>+<span class="params">m</span>)</span></span><br><span class="line"></span><br><span class="line">      - Parallel Ranking</span><br><span class="line"></span><br><span class="line">        - &lt;img src = <span class="string">&quot;ADS笔记\image-20220624143214438.png&quot;</span>&gt;</span><br><span class="line">        - 步骤一：令$p=\frac&#123;n&#125;&#123;logn&#125;$，把两个数组分别等分成P组，间隔为log n，并计算每个小组中的RANK</span><br><span class="line">        - 步骤二：Actual Ranking 有<span class="number">2</span>p个规模为<span class="constructor">O(<span class="params">log</span> <span class="params">n</span>)</span>的子问题，所以总的时间复杂度还是log n，但是work load变成了<span class="constructor">O(<span class="params">n</span>)</span>级别</span><br><span class="line"></span><br><span class="line">- 【例题】最大值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  - 方法一：把求和的+换成max,时间<span class="constructor">T(<span class="params">n</span>)</span>=<span class="constructor">O(1)</span>,<span class="constructor">W(<span class="params">n</span>)</span>=$n^<span class="number">2</span>$</span><br><span class="line"></span><br><span class="line">  - 方法二：分为$\sqrt&#123;n&#125;$组,在每一组里找最大值</span><br><span class="line"></span><br><span class="line">    - 有$\sqrt n$个组,得到$\sqrt n$个 最大值,耗时<span class="constructor">T($\<span class="params">sqrt</span> <span class="params">n$</span>)</span>,workload为<span class="constructor">W($\<span class="params">sqrt</span>&#123;<span class="params">n</span>&#125;$)</span></span><br><span class="line">    - <span class="constructor">$T(<span class="params">n</span>)</span>≤<span class="constructor">T(\<span class="params">sqrt</span> <span class="params">n</span>)</span>+c_1$</span><br><span class="line">    - $W (n)≤\sqrt&#123;n&#125;<span class="constructor">W(\<span class="params">sqrt</span>&#123;<span class="params">n</span>&#125;)</span>+c_2·n$</span><br><span class="line">    - <span class="constructor">$T(<span class="params">n</span>)</span>=<span class="constructor">O(<span class="params">loglogn</span>)</span>,<span class="constructor">W(<span class="params">n</span>)</span>=<span class="constructor">O(<span class="params">nloglogn</span>)</span>$</span><br><span class="line"></span><br><span class="line">  - 方法三：分为$h=loglog\ n$组,在每一组里找最大值</span><br><span class="line"></span><br><span class="line">    - <span class="constructor">$T(<span class="params">n</span>)</span>=<span class="constructor">O(<span class="params">loglogn</span>)</span>,<span class="constructor">W(<span class="params">n</span>)</span>=<span class="constructor">O(<span class="params">n</span>)</span>$</span><br><span class="line"></span><br><span class="line">  - 随机算法,高概率<span class="constructor">$T(<span class="params">n</span>)</span>=<span class="constructor">O(1)</span>,<span class="constructor">W(<span class="params">n</span>)</span>=<span class="constructor">O(<span class="params">n</span>)</span>$</span><br><span class="line"></span><br><span class="line">    - 【Theorem】The algorithm finds the maximum among n elements. With very high probability it runs <span class="keyword">in</span> <span class="constructor">O(1)</span> time <span class="keyword">and</span> <span class="constructor">O(<span class="params">n</span>)</span> work. The probability <span class="keyword">of</span> not finishing within this time <span class="keyword">and</span> work complexity is <span class="constructor">$O(1<span class="operator">/</span><span class="params">n</span>^<span class="params">c</span>)</span>$<span class="keyword">for</span> some positive constant c.</span><br><span class="line"></span><br><span class="line">    - ```cpp</span><br><span class="line">      <span class="keyword">while</span> (there is an element larger than M) &#123;</span><br><span class="line">        <span class="keyword">for</span> (each element larger than M)</span><br><span class="line">          Throw it into a random place <span class="keyword">in</span> a <span class="keyword">new</span> <span class="constructor">B(<span class="params">n7</span><span class="operator">/</span>8)</span>;</span><br><span class="line">        Compute a <span class="keyword">new</span> M;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-10-External-Sorting-外部排序">2.10 External Sorting 外部排序</h3>
<ul>
<li>
<p>为什么不直接在磁盘上进行快排？</p>
<ul>
<li>磁盘I/O的效率太低了，需要找到磁道和扇区</li>
</ul>
</li>
<li>
<p>解决方法：使用tapes进行排序</p>
<ul>
<li>tape的特点：只能顺序地访问，不能像内存中的数组一样直接寻址</li>
<li>至少需要3条tapes</li>
</ul>
</li>
<li>
<p>假如内存里最多可以保持M条记录，对N个元素进行排序</p>
<ul>
<li>每次读出M个数据放进内存进行排序，然后放在tapes中</li>
<li>一共需要进行的循环的次数(passes)为1+$\lceil log_2(N/M) \rceil$向上取整(2路归并)</li>
</ul>
</li>
<li>
<p>【例题】10M组数据，每条128B大小，Memory的大小为4MB，问需要几次pass？</p>
</li>
<li>
<p>答：passes=$1+\lceil log_2(1280MB/4MB) \rceil=9$</p>
</li>
<li>
<p>优化:减少passes的次数</p>
<ul>
<li>使用k-way的Merge:需要2k个tapes</li>
</ul>
</li>
<li>
<p>优化:更少的Tape</p>
<ul>
<li>如何使用3个tapes进行2-way merge?
<ul>
<li><strong>使用不均匀的分割!</strong></li>
<li><strong>合并的次数相比于对半分变多了,但是不需要进行磁带的复制</strong>,更加节约时间</li>
</ul>
</li>
<li>尽量将Run的次数拆分为斐波那契数列,不足的话可以加空的runs.</li>
<li>对于k-way的,则为$F_N^{(k)}=F_{N-1}^{(k)}+F_{N-2}^{(k)}+…+F_{1}^{(k)}$
<ul>
<li>需要k+1个tapes</li>
<li><strong>k不是越长越好</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<p>优化:更长的run</p>
<ul>
<li>
<p>从堆里找root,这个root和下一个进入堆的比较,如果root更小,进来的参与堆排序,否则不参与堆排序即不进入run,<strong>把root进入run</strong></p>
</li>
<li>
<p>直到堆中所有的元素都不能进入run,换一个run</p>
<img src="/undefined/ADS%E7%AC%94%E8%AE%B0/image-20220624154401589.png">
</li>
<li>
<p>如果内存可以容纳M个元素，则这种方法生成的run的均长度为2M</p>
</li>
<li>
<p>再输入的元素接近已经排好序的状态时非常work</p>
</li>
</ul>
</li>
<li>
<p>优化:更小的合并时间:</p>
<ul>
<li>优先合并两个run更小的</li>
<li>即长为2,4,5,6的run,先合并2,4变成6,再合并5,6变成11,再合并两个11</li>
</ul>
</li>
<li>
<p>使用buffer</p>
<ul>
<li>并行的实际上是对buffer的读和写</li>
<li>对于一个k路归并,需要2k个输入buffer和2个输出buffer来进行并行操作</li>
</ul>
</li>
<li>
<p>【例题】</p>
</li>
<li>
<p>Suppose we have the internal memory that can handle 12 numbers at a time, and the following two runs on the tapes:</p>
<p><strong>Run 1</strong>: 1, 3, 5, 7, 8, 9, 10, 12</p>
<p><strong>Run 2</strong>: 2, 4, 6, 15, 20, 25, 30, 32</p>
<p>Use 2-way merge with 4 input buffers and 2 output buffers for parallel operations. Which of the following three operations are NOT done in parallel?</p>
<p>A.1 and 2 are written onto the third tape; 3 and 4 are merged into an output buffer; 6 and 15 are read into an input buffer</p>
<p>B.3 and 4 are written onto the third tape; 5 and 6 are merged into an output buffer; 8 and 9 are read into an input buffer</p>
<p>C.5 and 6 are written onto the third tape; 7 and 8 are merged into an output buffer; 20 and 25 are read into an input buffer</p>
<p>D.7 and 8 are written onto the third tape; 9 and 15 are merged into an output buffer; 10 and 12 are read into an input buffer</p>
</li>
<li>
<p>答:D,首先能handle 12个numbers,说明一个buffer有2个number,那么第一轮从两个tape读入一个block</p>
<p><img src="http://file.cc98.org/v2-upload/woklmhuz.jpg" alt="img"></p>
</li>
</ul>


        <hr>
        <!-- Pager -->
        <ul class="pager">
          
          
          <li class="next">
            <a href="/undefined/OOP笔记/" data-toggle="tooltip" data-placement="top" title="OOP笔记">Next Post &rarr;</a>
          </li>
          
        </ul>

        
        <!-- tip start -->
        <!-- tip -->
<!-- tip start -->
<div class="tip">
  <p>
    
      如果您喜欢此博客或发现它对您有用，则欢迎对此发表评论。 也欢迎您共享此博客，以便更多人可以参与。 如果博客中使用的图像侵犯了您的版权，请与作者联系以将其删除。 谢谢 ！
    
  </p>
</div>
<!-- tip end -->

        <!-- tip end -->
        

        
        <!-- Sharing Srtart -->
        <!-- Social Social Share Post -->
<!-- Docs:https://github.com/overtrue/share.js -->

<div class="social-share" data-initialized="true" data-disabled="tencent ,douban ,qzone ,linkedin ,facebook ,google ,diandian" data-wechat-qrcode-helper="" align="center">
  <ul class="list-inline text-center social-share-ul">
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon icon-twitter">
        <i class="fa fa-twitter fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a class="social-share-icon icon-wechat">
        <i class="fa fa-weixin fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon icon-weibo">
        <i class="fa fa-weibo fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon icon-qq">
        <i class="fa fa-qq fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon" href="mailto:?subject=ADS笔记&body=Hi,I found this website and thought you might like it http://Hualingz.cn/undefined/ADS笔记/">
        <i class="fa fa-envelope fa-1x" aria-hidden="true"></i>
      </a>
    </li>
  </ul>
</div>

<!-- css & js -->
<!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css"> -->
<script defer="defer" async="true" src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>

        <!-- Sharing End -->
        
        <hr>

        <!-- comments start -->
        <!-- 1. gitalk comment -->

  <!-- gitalk start -->
  <!-- Docs:https://github.com/gitalk/gitalk/blob/master/readme-cn.md -->

  <div id="gitalk-container"></div>

  
    <!-- <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.js"></script> -->
    <script src="/js/comment/gitalk.js"></script>
  

  <script>
    var gitalk = new Gitalk({
      clientID: '',
      clientSecret: '',
      repo: '',
      owner: '',
      admin: '',
      id: 'Sun Jun 26 2022 00:39:59 GMT+0800', // Ensure uniqueness and length less than 50
      distractionFreeMode: false, // Facebook-like distraction free mode
      perPage: 10,
      pagerDirection: 'last',
      createIssueManually: false,
      language: 'en',
      proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token'
    });
    gitalk.render('gitalk-container');

    var gtFolded = () => {
      setTimeout(function () {
        let markdownBody = document.getElementsByClassName("markdown-body");
        let list = Array.from(markdownBody);
        list.forEach(item => {
          if (item.clientHeight > 250) {
            item.classList.add('gt-comment-body-folded');
            item.style.maxHeight = '250px';
            item.title = 'Click to Expand';
            item.onclick = function () {
              item.classList.remove('gt-comment-body-folded');
              item.style.maxHeight = '';
              item.title = '';
              item.onclick = null;
            };
          }
        })
      }, 800);
    }
  </script>

  <!-- gitalk end -->


<!-- 2. gitment comment -->


<!-- 3. disqus comment -->


        <!-- comments end -->
        <hr>

      </div>

      <!-- Catalog: Tabe of Content -->
      <!-- Table of Contents -->

    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">目录</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">ADS</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-Advanced-Data-Structure"><span class="toc-nav-number">1.1.</span> <span class="toc-nav-text">1.Advanced Data Structure</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-1-Tree"><span class="toc-nav-number">1.1.1.</span> <span class="toc-nav-text">1.1 Tree</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-1-1-AVL-Tree"><span class="toc-nav-number">1.1.1.1.</span> <span class="toc-nav-text">1.1.1  AVL Tree</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-1-2-Splay-Tree"><span class="toc-nav-number">1.1.1.2.</span> <span class="toc-nav-text">1.1.2 Splay Tree</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E3%80%90%E8%A1%A5%E5%85%85%E3%80%91%E4%BB%A3%E4%BB%B7%E8%AE%A1%E7%AE%97"><span class="toc-nav-number">1.1.1.3.</span> <span class="toc-nav-text">【补充】代价计算</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E3%80%90%E8%A1%A5%E5%85%85%E3%80%91%E5%9D%87%E6%91%8A%E4%BB%A3%E4%BB%B7%E7%9A%84%E5%88%86%E6%9E%90"><span class="toc-nav-number">1.1.1.4.</span> <span class="toc-nav-text">【补充】均摊代价的分析</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-1-3-%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-nav-number">1.1.1.5.</span> <span class="toc-nav-text">1.1.3 红黑树</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-1-4-B-%E6%A0%91"><span class="toc-nav-number">1.1.1.6.</span> <span class="toc-nav-text">1.1.4 B+树</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-3-Heap"><span class="toc-nav-number">1.1.2.</span> <span class="toc-nav-text">1.3 Heap</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-3-1-Leftist-Heap-%E5%B7%A6%E5%80%BE%E5%A0%86"><span class="toc-nav-number">1.1.2.1.</span> <span class="toc-nav-text">1.3.1 Leftist Heap 左倾堆</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-3-2-Skew-Heap%E6%96%9C%E5%A0%86"><span class="toc-nav-number">1.1.2.2.</span> <span class="toc-nav-text">1.3.2 Skew Heap斜堆</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-4-%E4%BA%8C%E9%A1%B9%E9%98%9F%E5%88%97"><span class="toc-nav-number">1.1.3.</span> <span class="toc-nav-text">1.4 二项队列</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-Algorithms"><span class="toc-nav-number">1.2.</span> <span class="toc-nav-text">2. Algorithms</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-1-BackTracking"><span class="toc-nav-number">1.2.1.</span> <span class="toc-nav-text">2.1 BackTracking</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-1-1-Basic-Idea"><span class="toc-nav-number">1.2.1.1.</span> <span class="toc-nav-text">2.1.1 Basic Idea</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-1-2-%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98"><span class="toc-nav-number">1.2.1.2.</span> <span class="toc-nav-text">2.1.2 八皇后问题</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-1-3-%E5%8A%A0%E6%B2%B9%E7%AB%99%E9%97%AE%E9%A2%98"><span class="toc-nav-number">1.2.1.3.</span> <span class="toc-nav-text">2.1.3 加油站问题</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-1-3-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%9A%84%E6%A8%A1%E6%9D%BF"><span class="toc-nav-number">1.2.1.4.</span> <span class="toc-nav-text">2.1.3 回溯算法的模板</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-1-4-Tic-Tac-Toe"><span class="toc-nav-number">1.2.1.5.</span> <span class="toc-nav-text">2.1.4 Tic-Tac-Toe</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-1-5-%E5%89%AA%E6%9E%9D"><span class="toc-nav-number">1.2.1.6.</span> <span class="toc-nav-text">2.1.5 剪枝</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-2-Conquer-%E5%88%86%E6%B2%BB%E6%B3%95"><span class="toc-nav-number">1.2.2.</span> <span class="toc-nav-text">2.2 Conquer 分治法</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-2-1-Closest-Points-Problem"><span class="toc-nav-number">1.2.2.1.</span> <span class="toc-nav-text">2.2.1 Closest Points Problem</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-2-4-%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BF%AD%E4%BB%A3"><span class="toc-nav-number">1.2.2.2.</span> <span class="toc-nav-text">2.2.4 基本的迭代</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-3-Dynamic-Programming-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-nav-number">1.2.3.</span> <span class="toc-nav-text">2.3 Dynamic Programming 动态规划</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-5-NP-Completeness-NP%E5%AE%8C%E5%85%A8%E6%80%A7"><span class="toc-nav-number">1.2.4.</span> <span class="toc-nav-text">2.5 NP-Completeness NP完全性</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-6-Approximation-%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95"><span class="toc-nav-number">1.2.5.</span> <span class="toc-nav-text">2.6 Approximation 近似算法</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-7-Local-Search-%E5%B1%80%E9%83%A8%E6%90%9C%E7%B4%A2"><span class="toc-nav-number">1.2.6.</span> <span class="toc-nav-text">2.7 Local Search 局部搜索</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-9-Parallel-Algorithm-%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95"><span class="toc-nav-number">1.2.7.</span> <span class="toc-nav-text">2.9 Parallel Algorithm 并行算法</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-10-External-Sorting-%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F"><span class="toc-nav-number">1.2.8.</span> <span class="toc-nav-text">2.10 External Sorting 外部排序</span></a></li></ol></li></ol></li></ol>
        
        </div>
      </aside>
    



      <!-- Sidebar Container -->
      <div class="
                col-lg-8 col-lg-offset-1
                col-md-10 col-md-offset-1
                sidebar-container">

        <!-- Featured Tags -->
        
        <section>
          <!-- no hr -->
          <h5>
            <a href="/tags/">特色标签</a>
          </h5>
          <div class="tags">
            
            <a class="tag" href="/tags/#高级数据结构" title="高级数据结构">高级数据结构</a>
            
          </div>
        </section>
        

        <!-- Friends Blog -->
        
        <hr>
        <h5>链友</h5>
        <ul class="list-inline">

          
        </ul>
        
      </div>
    </div>
  </div>
</article>



<!-- anchorjs start -->
<!-- async load function -->
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script type="text/javascript">
  // async load function
  function async (u, c) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) {
      o.addEventListener('load', function(e) {
        c(null, e);
      }, false);
    }
    s.parentNode.insertBefore(o, s);
  };
</script>
<script type="text/javascript">
  //anchor-js, Doc:http://bryanbraun.github.io/anchorjs/
  async ("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js", function() {
    anchors.options = {
      visible: 'hover',
      placement: 'left',
      // icon: 'ℬ'
      icon: '❡'
    };
    anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
  });
</script>
<style>
  /* place left on bigger screen */
  @media all and (min-width: 800px) {
    .anchorjs-link {
      position: absolute;
      left: -0.75em;
      font-size: 1.1em;
      margin-top: -0.1em;
    }
  }
</style>

<!-- anchorjs end -->



		<!-- Footer (contains ThemeColor、viewer) -->
		<!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center">
          

          
            <li>
              <a target="_blank" href="https://github.com/Hualeez">
                <span class="fa-stack fa-lg">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
          

          

          

          

          

          

          

        </ul>
        <p class="copyright text-muted">
          Copyright &copy;
          Hualingz
          2022
          <br>
          Theme by
          <a target="_blank" rel="noopener" href="http://beantech.org">BeanTech</a>
          <span style="display: inline-block; margin: 0 5px;">
            <i class="fa fa-heart"></i>
          </span>
          re-Ported by
          <a target="_blank" rel="noopener" href="https://v-vincen.life/">Live My Life</a>
          |
          <iframe style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0" width="91px" height="20px" src="https://ghbtns.com/github-btn.html?user=V-Vincen&repo=V-Vincen.github.io&type=star&count=true"></iframe>
        </p>
      </div>
    </div>
  </div>
</footer>

<a id="rocket" href="#top" class=""></a>


  <!-- jQuery -->
  <script type="text/javascript" src="/js/jquery.min.js"></script>
  <!-- Bootstrap Core JavaScript -->
  <script type="text/javascript" src="/js/bootstrap.min.js"></script>
  <!-- Custom Theme JavaScript -->
  <script type="text/javascript" src="/js/hux-blog.min.js"></script>
  <!-- catalog -->
  <script async="true" type="text/javascript" src="/js/catalog.js"></script>
  <!-- totop(rocket) -->
  <script async="true" type="text/javascript" src="/js/totop.js"></script>

  
    <!-- Busuanzi JavaScript -->
    <script async="async" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <!-- Scroll start -->
    <script async="async" type="text/javascript" src="/js/scroll.js"></script>
    <!-- Scroll end -->
  

  
    <!-- LangSelect start -->
    <script type="text/javascript" src="/js/langselect.js"></script>
    <!-- LangSelect end -->
  

  
    <!-- Mouseclick -->
    <script type="text/javascript" src="/js/mouseclick.js" content='The first step is as good as half over...,Laugh and grow fat...,Man proposes God disposes...,When all else is lost the future still remains...,Wasting time is robbing oneself...,Sharp tools make good work...,Cease to struggle and you cease to live...,A friend in need is a friend indeed...,Faith can move mountains...' color='#9933CC,#339933,#66CCCC,#FF99CC,#CCCCFF,#6666CC,#663399,#66CC99,#FF0033'></script>
  

  
    <!-- ribbon -->
    <script type="text/javascript" src="/js/ribbonDynamic.js"></script>
  

  






  <!-- viewer start -->
  <!-- viewer start (Picture preview) -->
  
    <script async="async" type="text/javascript" src="/js/viewer/viewer.min.js"></script>
    <script async="async" type="text/javascript" src="/js/viewer/pic-viewer.js"></script>
  

  <!-- viewer end -->


<script>
  // async load function
  function async (u, c) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) {
      o.addEventListener('load', function (e) {
        c(null, e);
      }, false);
    }
    s.parentNode.insertBefore(o, s);
  }

  // fastClick.js
  async ("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function () {
    var $nav = document.querySelector("nav");
    if ($nav)
      FastClick.attach($nav);
    }
  )
</script>

<!-- Because of the native support for backtick-style fenced code blocks right within the Markdown is landed in Github Pages, From V1.6, There is no need for Highlight.js, so Huxblog drops it officially. -
https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0 - https://help.github.com/articles/creating-and-highlighting-code-blocks/ -->
<!-- <script> async ("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function () { hljs.initHighlightingOnLoad(); }) </script> <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet"> -->

<!-- jquery.tagcloud.js -->
<!-- <script> // only load tagcloud.js in tag.html if ($('#tag_cloud').length !== 0) { async ("http://Hualingz.cn/js/jquery.tagcloud.js", function () { $.fn.tagcloud.defaults = { // size: { start: 1, end: 1, unit: 'em' }, color: {
start: '#bbbbee', end: '#0085a1' } }; $('#tag_cloud a').tagcloud(); }) } </script> -->


		<!-- Search -->
		
		<div class="popup search-popup local-search-popup">
  <span class="popup-btn-close">
    ESC
  </span>
  <div class="container">
    <div class="row">
      <!-- <div class="col-md-9 col-md-offset-1"> -->
      <div class="col-lg-9 col-lg-offset-1 col-md-10 col-md-offset-1 local-search-content">

        <div class="local-search-header clearfix">

          <div class="local-search-input-wrapper">
            <span class="search-icon">
              <i class="fa fa-search fa-lg" style="margin: 25px 10px 25px 20px;"></i>
            </span>
            <input autocomplete="off" placeholder="搜索..." type="text" id="local-search-input">
          </div>
        </div>
        <div id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>


  
    <script src="/js/ziploader.js"></script>
  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.json";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    // monitor main search box;
    var onPopupClose = function (e) {
      $('.popup').fadeOut(300);
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $('.popup').fadeIn(300);
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }
    // get search zip version
    $.get('/searchVersion.json?t=' + (+new Date()), function (res) {
      if (localStorage.getItem('searchVersion') !== res) {
        localStorage.setItem('searchVersion', res);
        initSearchJson();
      }
    });

    function initSearchJson() {
      initLoad(['/search.flv'], {
        loadOptions: {
          success: function (obj) {
            localStorage.setItem('searchJson', obj['search.json'])
          },
          error: function (e) {
            return console.log(e)
          }
        },
        returnOptions: {
          'json': TYPE_TEXT
        },
        mimeOptions: {
          'json': 'application/json'
        }
      })
    }
    // search function;
    var searchFunc = function (search_id, content_id) {
      'use strict';
      isfetched = true;
      var datas = JSON.parse(localStorage.getItem('searchJson'));
      // console.log(search_id)
      var input = document.getElementById(search_id);
      var resultContent = document.getElementById(content_id);
      var inputEventFunction = function () {
        var searchText = input.value.trim().toLowerCase();
        var keywords = searchText.split(/[\s\-]+/);
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        var resultItems = [];
        if (searchText.length > 0) {
          // perform local searching
          datas.forEach(function (data) {
            var isMatch = false;
            var hitCount = 0;
            var searchTextCount = 0;
            var title = data.title
              ? data.title.trim()
              : '';
            var titleInLowerCase = title.toLowerCase();
            var content = data.content
              ? data.content.trim().replace(/<[^>]+>/g, "")
              : '';
            var contentInLowerCase = content.toLowerCase();
            var articleUrl = decodeURIComponent(data.url);

            var date = data.date;
            var dateTime = date.replace(/T/, " ").replace(/.000Z/, "");
            var imgUrl = data.header_img;
            


            var indexOfTitle = [];
            var indexOfContent = [];
            // only match articles with not empty titles
            keywords.forEach(function (keyword) {
              function getIndexByWord(word, text, caseSensitive) {
                var wordLen = word.length;
                if (wordLen === 0) {
                  return [];
                }
                var startPosition = 0,
                  position = [],
                  index = [];
                if (!caseSensitive) {
                  text = text.toLowerCase();
                  word = word.toLowerCase();
                }
                while ((position = text.indexOf(word, startPosition)) > -1) {
                  index.push({position: position, word: word});
                  startPosition = position + wordLen;
                }
                return index;
              }
              indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
              indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
            });
            if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
              isMatch = true;
              hitCount = indexOfTitle.length + indexOfContent.length;
            }
            // show search results
            if (isMatch) {
              // sort index by position of keyword
              [indexOfTitle, indexOfContent].forEach(function (index) {
                index.sort(function (itemLeft, itemRight) {
                  if (itemRight.position !== itemLeft.position) {
                    return itemRight.position - itemLeft.position;
                  } else {
                    return itemLeft.word.length - itemRight.word.length;
                  }
                });
              });
              // merge hits into slices
              function mergeIntoSlice(text, start, end, index) {
                var item = index[index.length - 1];
                var position = item.position;
                var word = item.word;
                var hits = [];
                var searchTextCountInSlice = 0;
                while (position + word.length <= end && index.length != 0) {
                  if (word === searchText) {
                    searchTextCountInSlice++;
                  }
                  hits.push({position: position, length: word.length});
                  var wordEnd = position + word.length;
                  // move to next position of hit
                  index.pop();
                  while (index.length != 0) {
                    item = index[index.length - 1];
                    position = item.position;
                    word = item.word;
                    if (wordEnd > position) {
                      index.pop();
                    } else {
                      break;
                    }
                  }
                }
                searchTextCount += searchTextCountInSlice;
                return {hits: hits, start: start, end: end, searchTextCount: searchTextCountInSlice};
              }
              var slicesOfTitle = [];
              if (indexOfTitle.length != 0) {
                slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
              }
              var slicesOfContent = [];
              while (indexOfContent.length != 0) {
                var item = indexOfContent[indexOfContent.length - 1];
                var position = item.position;
                var word = item.word;
                // cut out 100 characters
                var start = position - 20;
                var end = position + 80;
                if (start < 0) {
                  start = 0;
                }
                if (end < position + word.length) {
                  end = position + word.length;
                }
                if (end > content.length) {
                  end = content.length;
                }
                slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
              }
              // sort slices in content by search text's count and hits' count
              slicesOfContent.sort(function (sliceLeft, sliceRight) {
                if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                  return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                  return sliceRight.hits.length - sliceLeft.hits.length;
                } else {
                  return sliceLeft.start - sliceRight.start;
                }
              });
              // select top N slices in content
              var upperBound = parseInt('1');
              if (upperBound >= 0) {
                slicesOfContent = slicesOfContent.slice(0, upperBound);
              }
              // highlight title and content
              function highlightKeyword(text, slice) {
                var result = '';
                var prevEnd = slice.start;
                slice.hits.forEach(function (hit) {
                  result += text.substring(prevEnd, hit.position);
                  var end = hit.position + hit.length;
                  result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                  prevEnd = end;
                });
                result += text.substring(prevEnd, slice.end);
                return result;
              }
              var resultItem = '';

              // if (slicesOfTitle.length != 0) {   resultItem += "<li><a target='_blank' href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>"; } else {   resultItem += "<li><a target='_blank' href='" +
              // articleUrl + "' class='search-result-title'>" + title + "</a>"; } slicesOfContent.forEach(function (slice) {   resultItem += "<a target='_blank' href='" + articleUrl + "'><p class=\"search-result\">" + highlightKeyword(content, slice) +
              // "...</p></a>"; }); resultItem += "</li>";

              if (slicesOfTitle.length != 0) {
                resultItem += "<a target='_blank' href='" + articleUrl + "' class='search-result'><div class='search-result-left'><div class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</div><time class='search-result-date'>" + dateTime + "</time>";
              } else {
                resultItem += "<a target='_blank' href='" + articleUrl + "' class='search-result'><div class='search-result-left'><div class='search-result-title'>" + title + "</div><time class='search-result-date'>" + dateTime + "</time>";
              }
              slicesOfContent.forEach(function (slice) {
                resultItem += "<p class=\"search-result-content\">" + highlightKeyword(content, slice) + "...</p>";
              });
              resultItem += "</div><div class='search-result-right'><img class='media-image' src='" + imgUrl + "' width='64px' height='48px'></img></div></a>";

              resultItems.push({item: resultItem, searchTextCount: searchTextCount, hitCount: hitCount, id: resultItems.length});
            }
          })
        };

        if (keywords.length === 1 && keywords[0] === "") {
          resultContent.innerHTML = '<div id="no-result"></div>'
        } else if (resultItems.length === 0) {
          resultContent.innerHTML = '<div id="no-result"></div>'
        } else {
          resultItems.sort(function (resultLeft, resultRight) {
            if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
              return resultRight.searchTextCount - resultLeft.searchTextCount;
            } else if (resultLeft.hitCount !== resultRight.hitCount) {
              return resultRight.hitCount - resultLeft.hitCount;
            } else {
              return resultRight.id - resultLeft.id;
            }
          });
          var searchResultList = '<div class=\"search-result-list\">';
          resultItems.forEach(function (result) {
            searchResultList += result.item;
          })
          searchResultList += "</div>";
          resultContent.innerHTML = searchResultList;
        }
      }
      if ('auto' === 'auto') {
        input.addEventListener('input', inputEventFunction);
      } else {
        $('.search-icon').click(inputEventFunction);
        input.addEventListener('keypress', function (event) {
          if (event.keyCode === 13) {
            inputEventFunction();
          }
        });
      }
      // remove loading animation
      $('body').css('overflow', '');
      proceedsearch();
    }
    // handle and trigger popup window;
    $('.popup-trigger').click(function (e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc('local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });
    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function (e) {
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 && $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });

    document.addEventListener('mouseup', (e) => {
      var _con = document.querySelector(".local-search-content");
      if (_con) {
        if (!_con.contains(e.target)) {
          onPopupClose();
        }
      }
    });
  </script>


		
	<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
